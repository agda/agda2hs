<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Haskell.Prelude</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--no-auto-inline</a> <a id="30" class="Symbol">#-}</a>
<a id="34" class="Keyword">module</a> <a id="41" href="Haskell.Prelude.html" class="Module">Haskell.Prelude</a> <a id="57" class="Keyword">where</a>

<a id="64" class="Keyword">open</a> <a id="69" class="Keyword">import</a> <a id="76" href="Haskell.Prim.html" class="Module">Haskell.Prim</a>
<a id="89" class="Keyword">open</a> <a id="94" href="Haskell.Prim.html" class="Module">Haskell.Prim</a> <a id="107" class="Keyword">public</a> <a id="114" class="Keyword">using</a>
  <a id="122" class="Symbol">(</a> <a id="124" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="128" class="Symbol">;</a> <a id="130" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a><a id="134" class="Symbol">;</a> <a id="136" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a><a id="141" class="Symbol">;</a> <a id="143" href="Agda.Builtin.Char.html#238" class="Postulate">Char</a><a id="147" class="Symbol">;</a> <a id="149" href="Agda.Builtin.Int.html#245" class="Datatype">Integer</a><a id="156" class="Symbol">;</a>
    <a id="162" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="166" class="Symbol">;</a> <a id="168" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="170" class="Symbol">;</a> <a id="172" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="175" class="Symbol">;</a> <a id="177" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a><a id="180" class="Symbol">;</a> <a id="182" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="186" class="Symbol">;</a> <a id="188" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="191" class="Symbol">;</a> <a id="193" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="194" class="Symbol">;</a> <a id="196" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="198" class="Symbol">;</a>
    <a id="204" href="Haskell.Prim.html#3411" class="Datatype">TypeError</a><a id="213" class="Symbol">;</a> <a id="215" href="Haskell.Prim.html#2596" class="Datatype">⊥</a><a id="216" class="Symbol">;</a> <a id="218" href="Haskell.Prim.html#2275" class="Function">iNumberNat</a><a id="228" class="Symbol">;</a> <a id="230" href="Haskell.Prim.html#2428" class="Function">lengthNat</a><a id="239" class="Symbol">;</a>
    <a id="245" href="Haskell.Prim.html#3177" class="Datatype">IsTrue</a><a id="251" class="Symbol">;</a> <a id="253" href="Haskell.Prim.html#3242" class="Datatype">IsFalse</a><a id="260" class="Symbol">;</a> <a id="262" href="Haskell.Prim.html#3311" class="Datatype">NonEmpty</a><a id="270" class="Symbol">;</a>
    <a id="276" href="Haskell.Prim.html#2804" class="Datatype">All</a><a id="279" class="Symbol">;</a> <a id="281" href="Haskell.Prim.html#2886" class="InductiveConstructor">allNil</a><a id="287" class="Symbol">;</a> <a id="289" href="Haskell.Prim.html#2909" class="InductiveConstructor">allCons</a><a id="296" class="Symbol">;</a>
    <a id="302" href="Haskell.Prim.html#2981" class="Datatype">Any</a><a id="305" class="Symbol">;</a> <a id="307" href="Haskell.Prim.html#3063" class="InductiveConstructor">anyHere</a><a id="314" class="Symbol">;</a> <a id="316" href="Haskell.Prim.html#3116" class="InductiveConstructor">anyThere</a><a id="324" class="Symbol">;</a>
    <a id="330" href="Haskell.Prim.html#1296" class="Function">id</a><a id="332" class="Symbol">;</a> <a id="334" href="Haskell.Prim.html#1330" class="Function Operator">_∘_</a><a id="337" class="Symbol">;</a> <a id="339" href="Haskell.Prim.html#1480" class="Function Operator">_$_</a><a id="342" class="Symbol">;</a> <a id="344" href="Haskell.Prim.html#1383" class="Function">flip</a><a id="348" class="Symbol">;</a> <a id="350" href="Haskell.Prim.html#1434" class="Function">const</a><a id="355" class="Symbol">;</a>
    <a id="361" href="Haskell.Prim.html#1713" class="Function Operator">if_then_else_</a><a id="374" class="Symbol">;</a> <a id="376" href="Haskell.Prim.html#1609" class="Function Operator">case_of_</a><a id="384" class="Symbol">;</a>
    <a id="390" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a><a id="396" class="Symbol">;</a> <a id="398" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a><a id="405" class="Symbol">;</a> <a id="407" href="Agda.Builtin.FromNeg.html#196" class="Record">Negative</a><a id="415" class="Symbol">;</a> <a id="417" href="Agda.Builtin.FromNeg.html#283" class="Field">fromNeg</a><a id="424" class="Symbol">;</a>
    <a id="430" href="Agda.Builtin.FromString.html#202" class="Record">IsString</a><a id="438" class="Symbol">;</a> <a id="440" href="Agda.Builtin.FromString.html#292" class="Field">fromString</a><a id="450" class="Symbol">;</a>
    <a id="456" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="459" class="Symbol">;</a> <a id="461" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="465" class="Symbol">;</a>
    <a id="471" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="472" class="Symbol">;</a> <a id="474" href="Haskell.Prim.html#1193" class="Generalizable">b</a><a id="475" class="Symbol">;</a> <a id="477" href="Haskell.Prim.html#1195" class="Generalizable">c</a><a id="478" class="Symbol">;</a> <a id="480" href="Haskell.Prim.html#1197" class="Generalizable">d</a><a id="481" class="Symbol">;</a> <a id="483" href="Haskell.Prim.html#1199" class="Generalizable">e</a><a id="484" class="Symbol">;</a> <a id="486" href="Haskell.Prim.html#1209" class="Generalizable">f</a><a id="487" class="Symbol">;</a> <a id="489" href="Haskell.Prim.html#1211" class="Generalizable">m</a><a id="490" class="Symbol">;</a> <a id="492" href="Haskell.Prim.html#1213" class="Generalizable">s</a><a id="493" class="Symbol">;</a> <a id="495" href="Haskell.Prim.html#1215" class="Generalizable">t</a> <a id="497" class="Symbol">)</a>

<a id="500" class="Keyword">open</a> <a id="505" class="Keyword">import</a> <a id="512" href="Haskell.Prim.Absurd.html" class="Module">Haskell.Prim.Absurd</a>      <a id="537" class="Keyword">public</a>
<a id="544" class="Keyword">open</a> <a id="549" class="Keyword">import</a> <a id="556" href="Haskell.Prim.Applicative.html" class="Module">Haskell.Prim.Applicative</a> <a id="581" class="Keyword">public</a>
<a id="588" class="Keyword">open</a> <a id="593" class="Keyword">import</a> <a id="600" href="Haskell.Prim.Bool.html" class="Module">Haskell.Prim.Bool</a>        <a id="625" class="Keyword">public</a>
<a id="632" class="Keyword">open</a> <a id="637" class="Keyword">import</a> <a id="644" href="Haskell.Prim.Bounded.html" class="Module">Haskell.Prim.Bounded</a>     <a id="669" class="Keyword">public</a>
<a id="676" class="Keyword">open</a> <a id="681" class="Keyword">import</a> <a id="688" href="Haskell.Prim.Char.html" class="Module">Haskell.Prim.Char</a>        <a id="713" class="Keyword">public</a>
<a id="720" class="Keyword">open</a> <a id="725" class="Keyword">import</a> <a id="732" href="Haskell.Prim.Double.html" class="Module">Haskell.Prim.Double</a>      <a id="757" class="Keyword">public</a>
<a id="764" class="Keyword">open</a> <a id="769" class="Keyword">import</a> <a id="776" href="Haskell.Prim.Either.html" class="Module">Haskell.Prim.Either</a>      <a id="801" class="Keyword">public</a>
<a id="808" class="Keyword">open</a> <a id="813" class="Keyword">import</a> <a id="820" href="Haskell.Prim.Enum.html" class="Module">Haskell.Prim.Enum</a>        <a id="845" class="Keyword">public</a>
<a id="852" class="Keyword">open</a> <a id="857" class="Keyword">import</a> <a id="864" href="Haskell.Prim.Eq.html" class="Module">Haskell.Prim.Eq</a>          <a id="889" class="Keyword">public</a>
<a id="896" class="Keyword">open</a> <a id="901" class="Keyword">import</a> <a id="908" href="Haskell.Prim.Foldable.html" class="Module">Haskell.Prim.Foldable</a>    <a id="933" class="Keyword">public</a>
<a id="940" class="Keyword">open</a> <a id="945" class="Keyword">import</a> <a id="952" href="Haskell.Prim.Functor.html" class="Module">Haskell.Prim.Functor</a>     <a id="977" class="Keyword">public</a>
<a id="984" class="Keyword">open</a> <a id="989" class="Keyword">import</a> <a id="996" href="Haskell.Prim.Int.html" class="Module">Haskell.Prim.Int</a>         <a id="1021" class="Keyword">public</a>
<a id="1028" class="Keyword">open</a> <a id="1033" class="Keyword">import</a> <a id="1040" href="Haskell.Prim.Integer.html" class="Module">Haskell.Prim.Integer</a>     <a id="1065" class="Keyword">public</a>
<a id="1072" class="Keyword">open</a> <a id="1077" class="Keyword">import</a> <a id="1084" href="Haskell.Prim.IO.html" class="Module">Haskell.Prim.IO</a>          <a id="1109" class="Keyword">public</a>
<a id="1116" class="Keyword">open</a> <a id="1121" class="Keyword">import</a> <a id="1128" href="Haskell.Prim.List.html" class="Module">Haskell.Prim.List</a>        <a id="1153" class="Keyword">public</a>
<a id="1160" class="Keyword">open</a> <a id="1165" class="Keyword">import</a> <a id="1172" href="Haskell.Prim.Maybe.html" class="Module">Haskell.Prim.Maybe</a>       <a id="1197" class="Keyword">public</a>
<a id="1204" class="Keyword">open</a> <a id="1209" class="Keyword">import</a> <a id="1216" href="Haskell.Prim.Monad.html" class="Module">Haskell.Prim.Monad</a>       <a id="1241" class="Keyword">public</a>
<a id="1248" class="Keyword">open</a> <a id="1253" class="Keyword">import</a> <a id="1260" href="Haskell.Prim.Monoid.html" class="Module">Haskell.Prim.Monoid</a>      <a id="1285" class="Keyword">public</a>
<a id="1292" class="Keyword">open</a> <a id="1297" class="Keyword">import</a> <a id="1304" href="Haskell.Prim.Num.html" class="Module">Haskell.Prim.Num</a>         <a id="1329" class="Keyword">public</a>
<a id="1336" class="Keyword">open</a> <a id="1341" class="Keyword">import</a> <a id="1348" href="Haskell.Prim.Ord.html" class="Module">Haskell.Prim.Ord</a>         <a id="1373" class="Keyword">public</a>
<a id="1380" class="Keyword">open</a> <a id="1385" class="Keyword">import</a> <a id="1392" href="Haskell.Prim.Show.html" class="Module">Haskell.Prim.Show</a>        <a id="1417" class="Keyword">public</a>
<a id="1424" class="Keyword">open</a> <a id="1429" class="Keyword">import</a> <a id="1436" href="Haskell.Prim.String.html" class="Module">Haskell.Prim.String</a>      <a id="1461" class="Keyword">public</a>
<a id="1468" class="Keyword">open</a> <a id="1473" class="Keyword">import</a> <a id="1480" href="Haskell.Prim.Traversable.html" class="Module">Haskell.Prim.Traversable</a> <a id="1505" class="Keyword">public</a>
<a id="1512" class="Keyword">open</a> <a id="1517" class="Keyword">import</a> <a id="1524" href="Haskell.Prim.Tuple.html" class="Module">Haskell.Prim.Tuple</a>       <a id="1549" class="Keyword">public</a> <a id="1556" class="Keyword">hiding</a> <a id="1563" class="Symbol">(</a><a id="1564" href="Haskell.Prim.Tuple.html#588" class="Function">first</a><a id="1569" class="Symbol">;</a> <a id="1571" href="Haskell.Prim.Tuple.html#647" class="Function">second</a><a id="1577" class="Symbol">;</a> <a id="1579" href="Haskell.Prim.Tuple.html#708" class="Function Operator">_***_</a><a id="1584" class="Symbol">)</a>
<a id="1586" class="Keyword">open</a> <a id="1591" class="Keyword">import</a> <a id="1598" href="Haskell.Prim.Word.html" class="Module">Haskell.Prim.Word</a>        <a id="1623" class="Keyword">public</a>

<a id="1631" class="Comment">-- Problematic features</a>
<a id="1655" class="Comment">--  - [Partial]:  Could pass implicit/instance arguments to prove totality.</a>
<a id="1731" class="Comment">--  - [Float]:    Or Float (Agda floats are Doubles)</a>
<a id="1784" class="Comment">--  - [Infinite]: Define colists and map to Haskell lists?</a>

<a id="1844" class="Comment">-- Missing from the Haskell Prelude:</a>
<a id="1881" class="Comment">--</a>
<a id="1884" class="Comment">--     Float        [Float]</a>
<a id="1912" class="Comment">--     Rational</a>
<a id="1928" class="Comment">--</a>
<a id="1931" class="Comment">--     Real(toRational),</a>
<a id="1956" class="Comment">--     Integral(quot, rem, div, mod, quotRem, divMod, toInteger),</a>
<a id="2022" class="Comment">--     Fractional((/), recip, fromRational),</a>
<a id="2067" class="Comment">--     Floating(pi, exp, log, sqrt, (**), logBase, sin, cos, tan,</a>
<a id="2133" class="Comment">--              asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh),</a>
<a id="2207" class="Comment">--     RealFrac(properFraction, truncate, round, ceiling, floor),</a>
<a id="2273" class="Comment">--     RealFloat(floatRadix, floatDigits, floatRange, decodeFloat,</a>
<a id="2340" class="Comment">--               encodeFloat, exponent, significand, scaleFloat, isNaN,</a>
<a id="2412" class="Comment">--               isInfinite, isDenormalized, isIEEE, isNegativeZero, atan2),</a>
<a id="2489" class="Comment">--</a>
<a id="2492" class="Comment">--     subtract, even, odd, gcd, lcm, (^), (^^),</a>
<a id="2541" class="Comment">--     fromIntegral, realToFrac,</a>
<a id="2574" class="Comment">--</a>
<a id="2577" class="Comment">--     foldr1, foldl1, maximum, minimum      [Partial]</a>
<a id="2632" class="Comment">--</a>
<a id="2635" class="Comment">--     until [Partial]</a>
<a id="2658" class="Comment">--</a>
<a id="2661" class="Comment">--     iterate, repeat, cycle          [Infinite]</a>
<a id="2711" class="Comment">--</a>
<a id="2714" class="Comment">--     ReadS, Read(readsPrec, readList),</a>
<a id="2755" class="Comment">--     reads, readParen, read, lex,</a>
<a id="2791" class="Comment">--</a>
<a id="2794" class="Comment">--     IO, putChar, putStr, putStrLn, print,</a>
<a id="2839" class="Comment">--     getChar, getLine, getContents, interact,</a>
<a id="2887" class="Comment">--     FilePath, readFile, writeFile, appendFile, readIO, readLn,</a>
<a id="2953" class="Comment">--     IOError, ioError, userError,</a>


<a id="2991" class="Comment">--------------------------------------------------</a>
<a id="3042" class="Comment">-- Functions</a>

<a id="3056" class="Keyword">infixr</a> <a id="3063" class="Number">0</a> <a id="3065" href="Haskell.Prelude.html#3071" class="Function Operator">_$!_</a>

<a id="_$!_"></a><a id="3071" href="Haskell.Prelude.html#3071" class="Function Operator">_$!_</a> <a id="3076" class="Symbol">:</a> <a id="3078" class="Symbol">(</a><a id="3079" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3081" class="Symbol">→</a> <a id="3083" href="Haskell.Prim.html#1193" class="Generalizable">b</a><a id="3084" class="Symbol">)</a> <a id="3086" class="Symbol">→</a> <a id="3088" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3090" class="Symbol">→</a> <a id="3092" href="Haskell.Prim.html#1193" class="Generalizable">b</a>
<a id="3094" href="Haskell.Prelude.html#3071" class="Function Operator">_$!_</a> <a id="3099" class="Symbol">=</a> <a id="3101" href="Haskell.Prim.html#1480" class="Function Operator">_$_</a>

<a id="seq"></a><a id="3106" href="Haskell.Prelude.html#3106" class="Function">seq</a> <a id="3110" class="Symbol">:</a> <a id="3112" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3114" class="Symbol">→</a> <a id="3116" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="3118" class="Symbol">→</a> <a id="3120" href="Haskell.Prim.html#1193" class="Generalizable">b</a>
<a id="3122" href="Haskell.Prelude.html#3106" class="Function">seq</a> <a id="3126" class="Symbol">=</a> <a id="3128" href="Haskell.Prim.html#1434" class="Function">const</a> <a id="3134" href="Haskell.Prim.html#1296" class="Function">id</a>

<a id="asTypeOf"></a><a id="3138" href="Haskell.Prelude.html#3138" class="Function">asTypeOf</a> <a id="3147" class="Symbol">:</a> <a id="3149" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3151" class="Symbol">→</a> <a id="3153" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3155" class="Symbol">→</a> <a id="3157" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3159" href="Haskell.Prelude.html#3138" class="Function">asTypeOf</a> <a id="3168" href="Haskell.Prelude.html#3168" class="Bound">x</a> <a id="3170" class="Symbol">_</a> <a id="3172" class="Symbol">=</a> <a id="3174" href="Haskell.Prelude.html#3168" class="Bound">x</a>

<a id="undefined"></a><a id="3177" href="Haskell.Prelude.html#3177" class="Function">undefined</a> <a id="3187" class="Symbol">:</a> <a id="3189" class="Symbol">{@</a><a id="3191" class="Symbol">0</a> <a id="3193" class="Symbol">@(</a><a id="3195" class="Keyword">tactic</a> <a id="3202" href="Haskell.Prim.Absurd.html#614" class="Function">absurd</a><a id="3208" class="Symbol">)</a> <a id="3210" href="Haskell.Prelude.html#3210" class="Bound">i</a> <a id="3212" class="Symbol">:</a> <a id="3214" href="Haskell.Prim.html#2596" class="Datatype">⊥</a><a id="3215" class="Symbol">}</a> <a id="3217" class="Symbol">→</a> <a id="3219" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3221" href="Haskell.Prelude.html#3177" class="Function">undefined</a> <a id="3231" class="Symbol">{</a><a id="3232" class="Argument">i</a> <a id="3234" class="Symbol">=</a> <a id="3236" class="Symbol">()}</a>

<a id="error"></a><a id="3241" href="Haskell.Prelude.html#3241" class="Function">error</a> <a id="3247" class="Symbol">:</a> <a id="3249" class="Symbol">{@</a><a id="3251" class="Symbol">0</a> <a id="3253" class="Symbol">@(</a><a id="3255" class="Keyword">tactic</a> <a id="3262" href="Haskell.Prim.Absurd.html#614" class="Function">absurd</a><a id="3268" class="Symbol">)</a> <a id="3270" href="Haskell.Prelude.html#3270" class="Bound">i</a> <a id="3272" class="Symbol">:</a> <a id="3274" href="Haskell.Prim.html#2596" class="Datatype">⊥</a><a id="3275" class="Symbol">}</a> <a id="3277" class="Symbol">→</a> <a id="3279" href="Haskell.Prim.String.html#344" class="Function">String</a> <a id="3286" class="Symbol">→</a> <a id="3288" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3290" href="Haskell.Prelude.html#3241" class="Function">error</a> <a id="3296" class="Symbol">{</a><a id="3297" class="Argument">i</a> <a id="3299" class="Symbol">=</a> <a id="3301" class="Symbol">()}</a> <a id="3305" href="Haskell.Prelude.html#3305" class="Bound">err</a>

<a id="errorWithoutStackTrace"></a><a id="3310" href="Haskell.Prelude.html#3310" class="Function">errorWithoutStackTrace</a> <a id="3333" class="Symbol">:</a> <a id="3335" class="Symbol">{@</a><a id="3337" class="Symbol">0</a> <a id="3339" class="Symbol">@(</a><a id="3341" class="Keyword">tactic</a> <a id="3348" href="Haskell.Prim.Absurd.html#614" class="Function">absurd</a><a id="3354" class="Symbol">)</a> <a id="3356" href="Haskell.Prelude.html#3356" class="Bound">i</a> <a id="3358" class="Symbol">:</a> <a id="3360" href="Haskell.Prim.html#2596" class="Datatype">⊥</a><a id="3361" class="Symbol">}</a> <a id="3363" class="Symbol">→</a> <a id="3365" href="Haskell.Prim.String.html#344" class="Function">String</a> <a id="3372" class="Symbol">→</a> <a id="3374" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3376" href="Haskell.Prelude.html#3310" class="Function">errorWithoutStackTrace</a> <a id="3399" class="Symbol">{</a><a id="3400" class="Argument">i</a> <a id="3402" class="Symbol">=</a> <a id="3404" class="Symbol">()}</a> <a id="3408" href="Haskell.Prelude.html#3408" class="Bound">err</a>

<a id="3413" class="Comment">-------------------------------------------------</a>
<a id="3463" class="Comment">-- More List functions</a>
<a id="3486" class="Comment">--   These uses Eq, Ord, or Foldable, so can&#39;t go in Prim.List without</a>
<a id="3557" class="Comment">--   turning those dependencies around.</a>

<a id="reverse"></a><a id="3598" href="Haskell.Prelude.html#3598" class="Function">reverse</a> <a id="3606" class="Symbol">:</a> <a id="3608" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3613" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3615" class="Symbol">→</a> <a id="3617" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3622" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3624" href="Haskell.Prelude.html#3598" class="Function">reverse</a> <a id="3632" class="Symbol">=</a> <a id="3634" href="Haskell.Prim.Foldable.html#566" class="Field">foldl</a> <a id="3640" class="Symbol">(</a><a id="3641" href="Haskell.Prim.html#1383" class="Function">flip</a> <a id="3646" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="3649" class="Symbol">)</a> <a id="3651" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="3655" class="Keyword">infixl</a> <a id="3662" class="Number">9</a> <a id="3664" href="Haskell.Prelude.html#3801" class="Function Operator">_!!_</a> <a id="3669" href="Haskell.Prelude.html#3676" class="Function Operator">_!!ᴺ_</a>

<a id="_!!ᴺ_"></a><a id="3676" href="Haskell.Prelude.html#3676" class="Function Operator">_!!ᴺ_</a> <a id="3682" class="Symbol">:</a> <a id="3684" class="Symbol">(</a><a id="3685" href="Haskell.Prelude.html#3685" class="Bound">xs</a> <a id="3688" class="Symbol">:</a> <a id="3690" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3695" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3696" class="Symbol">)</a> <a id="3698" class="Symbol">(</a><a id="3699" href="Haskell.Prelude.html#3699" class="Bound">n</a> <a id="3701" class="Symbol">:</a> <a id="3703" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a><a id="3706" class="Symbol">)</a> <a id="3708" class="Symbol">→</a> <a id="3710" class="Symbol">@</a><a id="3711" class="Symbol">0</a> <a id="3713" class="Symbol">⦃</a> <a id="3715" href="Haskell.Prim.html#3177" class="Datatype">IsTrue</a> <a id="3722" class="Symbol">(</a><a id="3723" href="Haskell.Prelude.html#3699" class="Bound">n</a> <a id="3725" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="3727" href="Haskell.Prim.html#2428" class="Function">lengthNat</a> <a id="3737" href="Haskell.Prelude.html#3685" class="Bound">xs</a><a id="3739" class="Symbol">)</a> <a id="3741" class="Symbol">⦄</a> <a id="3743" class="Symbol">→</a> <a id="3745" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3747" class="Symbol">(</a><a id="3748" href="Haskell.Prelude.html#3748" class="Bound">x</a> <a id="3750" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3752" href="Haskell.Prelude.html#3752" class="Bound">xs</a><a id="3754" class="Symbol">)</a> <a id="3756" href="Haskell.Prelude.html#3676" class="Function Operator">!!ᴺ</a> <a id="3760" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="3766" class="Symbol">=</a> <a id="3768" href="Haskell.Prelude.html#3748" class="Bound">x</a>
<a id="3770" class="Symbol">(</a><a id="3771" href="Haskell.Prelude.html#3771" class="Bound">x</a> <a id="3773" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3775" href="Haskell.Prelude.html#3775" class="Bound">xs</a><a id="3777" class="Symbol">)</a> <a id="3779" href="Haskell.Prelude.html#3676" class="Function Operator">!!ᴺ</a> <a id="3783" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3787" href="Haskell.Prelude.html#3787" class="Bound">n</a> <a id="3789" class="Symbol">=</a> <a id="3791" href="Haskell.Prelude.html#3775" class="Bound">xs</a> <a id="3794" href="Haskell.Prelude.html#3676" class="Function Operator">!!ᴺ</a> <a id="3798" href="Haskell.Prelude.html#3787" class="Bound">n</a>

<a id="_!!_"></a><a id="3801" href="Haskell.Prelude.html#3801" class="Function Operator">_!!_</a> <a id="3806" class="Symbol">:</a> <a id="3808" class="Symbol">(</a><a id="3809" href="Haskell.Prelude.html#3809" class="Bound">xs</a> <a id="3812" class="Symbol">:</a> <a id="3814" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3819" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3820" class="Symbol">)</a> <a id="3822" class="Symbol">(</a><a id="3823" href="Haskell.Prelude.html#3823" class="Bound">n</a> <a id="3825" class="Symbol">:</a> <a id="3827" href="Haskell.Prim.Int.html#367" class="Datatype">Int</a><a id="3830" class="Symbol">)</a>
     <a id="3837" class="Symbol">→</a> <a id="3839" class="Symbol">⦃</a> <a id="3841" class="Symbol">@</a><a id="3842" class="Symbol">0</a> <a id="3844" href="Haskell.Prelude.html#3844" class="Bound">nn</a> <a id="3847" class="Symbol">:</a> <a id="3849" href="Haskell.Prim.Int.html#2472" class="Function">IsNonNegativeInt</a> <a id="3866" href="Haskell.Prelude.html#3823" class="Bound">n</a> <a id="3868" class="Symbol">⦄</a>
     <a id="3875" class="Symbol">→</a> <a id="3877" class="Symbol">⦃</a> <a id="3879" class="Symbol">@</a><a id="3880" class="Symbol">0</a> <a id="3882" href="Haskell.Prelude.html#3882" class="Bound">_</a>  <a id="3885" class="Symbol">:</a> <a id="3887" href="Haskell.Prim.html#3177" class="Datatype">IsTrue</a> <a id="3894" class="Symbol">(</a><a id="3895" href="Haskell.Prim.Int.html#2664" class="Function">intToNat</a> <a id="3904" href="Haskell.Prelude.html#3823" class="Bound">n</a> <a id="3906" class="Symbol">{{</a><a id="3908" href="Haskell.Prelude.html#3844" class="Bound">nn</a><a id="3910" class="Symbol">}}</a> <a id="3913" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="3915" href="Haskell.Prim.html#2428" class="Function">lengthNat</a> <a id="3925" href="Haskell.Prelude.html#3809" class="Bound">xs</a><a id="3927" class="Symbol">)</a> <a id="3929" class="Symbol">⦄</a> <a id="3931" class="Symbol">→</a> <a id="3933" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3935" href="Haskell.Prelude.html#3935" class="Bound">xs</a> <a id="3938" href="Haskell.Prelude.html#3801" class="Function Operator">!!</a> <a id="3941" href="Haskell.Prelude.html#3941" class="Bound">n</a> <a id="3943" class="Symbol">=</a> <a id="3945" href="Haskell.Prelude.html#3935" class="Bound">xs</a> <a id="3948" href="Haskell.Prelude.html#3676" class="Function Operator">!!ᴺ</a> <a id="3952" href="Haskell.Prim.Int.html#2664" class="Function">intToNat</a> <a id="3961" href="Haskell.Prelude.html#3941" class="Bound">n</a>

<a id="lookup"></a><a id="3964" href="Haskell.Prelude.html#3964" class="Function">lookup</a> <a id="3971" class="Symbol">:</a> <a id="3973" class="Symbol">⦃</a> <a id="3975" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="3978" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3980" class="Symbol">⦄</a> <a id="3982" class="Symbol">→</a> <a id="3984" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3986" class="Symbol">→</a> <a id="3988" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3993" class="Symbol">(</a><a id="3994" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3996" href="Haskell.Prim.Tuple.html#169" class="Record Operator">×</a> <a id="3998" href="Haskell.Prim.html#1193" class="Generalizable">b</a><a id="3999" class="Symbol">)</a> <a id="4001" class="Symbol">→</a> <a id="4003" href="Haskell.Prim.Maybe.html#101" class="Datatype">Maybe</a> <a id="4009" href="Haskell.Prim.html#1193" class="Generalizable">b</a>
<a id="4011" href="Haskell.Prelude.html#3964" class="Function">lookup</a> <a id="4018" href="Haskell.Prelude.html#4018" class="Bound">x</a> <a id="4020" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>              <a id="4036" class="Symbol">=</a> <a id="4038" href="Haskell.Prim.Maybe.html#142" class="InductiveConstructor">Nothing</a>
<a id="4046" href="Haskell.Prelude.html#3964" class="Function">lookup</a> <a id="4053" href="Haskell.Prelude.html#4053" class="Bound">x</a> <a id="4055" class="Symbol">((</a><a id="4057" href="Haskell.Prelude.html#4057" class="Bound">x₁</a> <a id="4060" href="Haskell.Prim.Tuple.html#211" class="InductiveConstructor Operator">,</a> <a id="4062" href="Haskell.Prelude.html#4062" class="Bound">y</a><a id="4063" class="Symbol">)</a> <a id="4065" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4067" href="Haskell.Prelude.html#4067" class="Bound">xs</a><a id="4069" class="Symbol">)</a> <a id="4071" class="Symbol">=</a> <a id="4073" href="Haskell.Prim.html#1713" class="Function Operator">if</a> <a id="4076" href="Haskell.Prelude.html#4053" class="Bound">x</a> <a id="4078" href="Haskell.Prim.Eq.html#453" class="Field Operator">==</a> <a id="4081" href="Haskell.Prelude.html#4057" class="Bound">x₁</a> <a id="4084" href="Haskell.Prim.html#1713" class="Function Operator">then</a> <a id="4089" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a> <a id="4094" href="Haskell.Prelude.html#4062" class="Bound">y</a> <a id="4096" href="Haskell.Prim.html#1713" class="Function Operator">else</a> <a id="4101" href="Haskell.Prelude.html#3964" class="Function">lookup</a> <a id="4108" href="Haskell.Prelude.html#4053" class="Bound">x</a> <a id="4110" href="Haskell.Prelude.html#4067" class="Bound">xs</a>


<a id="4115" class="Comment">-------------------------------------------------</a>
<a id="4165" class="Comment">-- Unsafe functions</a>

<a id="coerce"></a><a id="4186" href="Haskell.Prelude.html#4186" class="Function">coerce</a> <a id="4193" class="Symbol">:</a> <a id="4195" class="Symbol">@</a><a id="4196" class="Symbol">0</a> <a id="4198" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4200" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4202" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="4204" class="Symbol">→</a> <a id="4206" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4208" class="Symbol">→</a> <a id="4210" href="Haskell.Prim.html#1193" class="Generalizable">b</a>
<a id="4212" href="Haskell.Prelude.html#4186" class="Function">coerce</a> <a id="4219" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="4224" href="Haskell.Prelude.html#4224" class="Bound">x</a> <a id="4226" class="Symbol">=</a> <a id="4228" href="Haskell.Prelude.html#4224" class="Bound">x</a>

<a id="IsJust"></a><a id="4231" href="Haskell.Prelude.html#4231" class="Function">IsJust</a> <a id="4238" class="Symbol">:</a> <a id="4240" href="Haskell.Prim.Maybe.html#101" class="Datatype">Maybe</a> <a id="4246" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4248" class="Symbol">→</a> <a id="4250" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="4254" href="Haskell.Prelude.html#4231" class="Function">IsJust</a> <a id="4261" href="Haskell.Prim.Maybe.html#142" class="InductiveConstructor">Nothing</a>  <a id="4270" class="Symbol">=</a> <a id="4272" href="Haskell.Prim.html#2596" class="Datatype">⊥</a>
<a id="4274" href="Haskell.Prelude.html#4231" class="Function">IsJust</a> <a id="4281" class="Symbol">(</a><a id="4282" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a> <a id="4287" class="Symbol">_)</a> <a id="4290" class="Symbol">=</a> <a id="4292" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

<a id="fromJust"></a><a id="4295" href="Haskell.Prelude.html#4295" class="Function">fromJust</a> <a id="4304" class="Symbol">:</a> <a id="4306" class="Symbol">(</a><a id="4307" href="Haskell.Prelude.html#4307" class="Bound">x</a> <a id="4309" class="Symbol">:</a> <a id="4311" href="Haskell.Prim.Maybe.html#101" class="Datatype">Maybe</a> <a id="4317" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="4318" class="Symbol">)</a> <a id="4320" class="Symbol">→</a> <a id="4322" class="Symbol">@</a><a id="4323" class="Symbol">0</a> <a id="4325" class="Symbol">{</a><a id="4326" href="Haskell.Prelude.html#4231" class="Function">IsJust</a> <a id="4333" href="Haskell.Prelude.html#4307" class="Bound">x</a><a id="4334" class="Symbol">}</a> <a id="4336" class="Symbol">→</a> <a id="4338" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="4340" href="Haskell.Prelude.html#4295" class="Function">fromJust</a> <a id="4349" href="Haskell.Prim.Maybe.html#142" class="InductiveConstructor">Nothing</a>  <a id="4358" class="Symbol">=</a> <a id="4360" href="Haskell.Prelude.html#3241" class="Function">error</a> <a id="4366" class="String">&quot;fromJust Nothing&quot;</a>
<a id="4385" href="Haskell.Prelude.html#4295" class="Function">fromJust</a> <a id="4394" class="Symbol">(</a><a id="4395" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a> <a id="4400" href="Haskell.Prelude.html#4400" class="Bound">x</a><a id="4401" class="Symbol">)</a> <a id="4403" class="Symbol">=</a> <a id="4405" href="Haskell.Prelude.html#4400" class="Bound">x</a>
</pre></body></html>
<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Haskell.Prelude</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--no-auto-inline</a> <a id="30" class="Symbol">#-}</a>
<a id="34" class="Keyword">module</a> <a id="41" href="Haskell.Prelude.html" class="Module">Haskell.Prelude</a> <a id="57" class="Keyword">where</a>

<a id="64" class="Keyword">open</a> <a id="69" class="Keyword">import</a> <a id="76" href="Haskell.Prim.html" class="Module">Haskell.Prim</a>
<a id="89" class="Keyword">open</a> <a id="94" href="Haskell.Prim.html" class="Module">Haskell.Prim</a> <a id="107" class="Keyword">public</a> <a id="114" class="Keyword">using</a>
  <a id="122" class="Symbol">(</a> <a id="124" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="128" class="Symbol">;</a> <a id="130" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a><a id="134" class="Symbol">;</a> <a id="136" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a><a id="141" class="Symbol">;</a> <a id="143" href="Agda.Builtin.Char.html#238" class="Postulate">Char</a><a id="147" class="Symbol">;</a> <a id="149" href="Agda.Builtin.Int.html#245" class="Datatype">Integer</a><a id="156" class="Symbol">;</a>
    <a id="162" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="166" class="Symbol">;</a> <a id="168" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="170" class="Symbol">;</a> <a id="172" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="175" class="Symbol">;</a> <a id="177" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a><a id="180" class="Symbol">;</a> <a id="182" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="186" class="Symbol">;</a> <a id="188" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="191" class="Symbol">;</a> <a id="193" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="194" class="Symbol">;</a> <a id="196" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a><a id="198" class="Symbol">;</a>
    <a id="204" href="Haskell.Prim.html#3215" class="Datatype">TypeError</a><a id="213" class="Symbol">;</a> <a id="215" href="Haskell.Prim.html#2596" class="Datatype">⊥</a><a id="216" class="Symbol">;</a> <a id="218" href="Haskell.Prim.html#2275" class="Function">iNumberNat</a><a id="228" class="Symbol">;</a> <a id="230" href="Haskell.Prim.html#2981" class="Datatype">IsTrue</a><a id="236" class="Symbol">;</a> <a id="238" href="Haskell.Prim.html#3046" class="Datatype">IsFalse</a><a id="245" class="Symbol">;</a>
    <a id="251" href="Haskell.Prim.html#2804" class="Datatype">All</a><a id="254" class="Symbol">;</a> <a id="256" href="Haskell.Prim.html#2886" class="InductiveConstructor">allNil</a><a id="262" class="Symbol">;</a> <a id="264" href="Haskell.Prim.html#2909" class="InductiveConstructor">allCons</a><a id="271" class="Symbol">;</a> <a id="273" href="Haskell.Prim.html#3115" class="Datatype">NonEmpty</a><a id="281" class="Symbol">;</a> <a id="283" href="Haskell.Prim.html#2428" class="Function">lengthNat</a><a id="292" class="Symbol">;</a>
    <a id="298" href="Haskell.Prim.html#1296" class="Function">id</a><a id="300" class="Symbol">;</a> <a id="302" href="Haskell.Prim.html#1330" class="Function Operator">_∘_</a><a id="305" class="Symbol">;</a> <a id="307" href="Haskell.Prim.html#1480" class="Function Operator">_$_</a><a id="310" class="Symbol">;</a> <a id="312" href="Haskell.Prim.html#1383" class="Function">flip</a><a id="316" class="Symbol">;</a> <a id="318" href="Haskell.Prim.html#1434" class="Function">const</a><a id="323" class="Symbol">;</a>
    <a id="329" href="Haskell.Prim.html#1713" class="Function Operator">if_then_else_</a><a id="342" class="Symbol">;</a> <a id="344" href="Haskell.Prim.html#1609" class="Function Operator">case_of_</a><a id="352" class="Symbol">;</a>
    <a id="358" href="Agda.Builtin.FromNat.html#196" class="Record">Number</a><a id="364" class="Symbol">;</a> <a id="366" href="Agda.Builtin.FromNat.html#281" class="Field">fromNat</a><a id="373" class="Symbol">;</a> <a id="375" href="Agda.Builtin.FromNeg.html#196" class="Record">Negative</a><a id="383" class="Symbol">;</a> <a id="385" href="Agda.Builtin.FromNeg.html#283" class="Field">fromNeg</a><a id="392" class="Symbol">;</a>
    <a id="398" href="Agda.Builtin.FromString.html#202" class="Record">IsString</a><a id="406" class="Symbol">;</a> <a id="408" href="Agda.Builtin.FromString.html#292" class="Field">fromString</a><a id="418" class="Symbol">;</a>
    <a id="424" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="427" class="Symbol">;</a> <a id="429" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="433" class="Symbol">;</a>
    <a id="439" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="440" class="Symbol">;</a> <a id="442" href="Haskell.Prim.html#1193" class="Generalizable">b</a><a id="443" class="Symbol">;</a> <a id="445" href="Haskell.Prim.html#1195" class="Generalizable">c</a><a id="446" class="Symbol">;</a> <a id="448" href="Haskell.Prim.html#1197" class="Generalizable">d</a><a id="449" class="Symbol">;</a> <a id="451" href="Haskell.Prim.html#1199" class="Generalizable">e</a><a id="452" class="Symbol">;</a> <a id="454" href="Haskell.Prim.html#1209" class="Generalizable">f</a><a id="455" class="Symbol">;</a> <a id="457" href="Haskell.Prim.html#1211" class="Generalizable">m</a><a id="458" class="Symbol">;</a> <a id="460" href="Haskell.Prim.html#1213" class="Generalizable">s</a><a id="461" class="Symbol">;</a> <a id="463" href="Haskell.Prim.html#1215" class="Generalizable">t</a> <a id="465" class="Symbol">)</a>

<a id="468" class="Keyword">open</a> <a id="473" class="Keyword">import</a> <a id="480" href="Haskell.Prim.Absurd.html" class="Module">Haskell.Prim.Absurd</a>      <a id="505" class="Keyword">public</a>
<a id="512" class="Keyword">open</a> <a id="517" class="Keyword">import</a> <a id="524" href="Haskell.Prim.Applicative.html" class="Module">Haskell.Prim.Applicative</a> <a id="549" class="Keyword">public</a>
<a id="556" class="Keyword">open</a> <a id="561" class="Keyword">import</a> <a id="568" href="Haskell.Prim.Bool.html" class="Module">Haskell.Prim.Bool</a>        <a id="593" class="Keyword">public</a>
<a id="600" class="Keyword">open</a> <a id="605" class="Keyword">import</a> <a id="612" href="Haskell.Prim.Bounded.html" class="Module">Haskell.Prim.Bounded</a>     <a id="637" class="Keyword">public</a>
<a id="644" class="Keyword">open</a> <a id="649" class="Keyword">import</a> <a id="656" href="Haskell.Prim.Char.html" class="Module">Haskell.Prim.Char</a>        <a id="681" class="Keyword">public</a>
<a id="688" class="Keyword">open</a> <a id="693" class="Keyword">import</a> <a id="700" href="Haskell.Prim.Double.html" class="Module">Haskell.Prim.Double</a>      <a id="725" class="Keyword">public</a>
<a id="732" class="Keyword">open</a> <a id="737" class="Keyword">import</a> <a id="744" href="Haskell.Prim.Either.html" class="Module">Haskell.Prim.Either</a>      <a id="769" class="Keyword">public</a>
<a id="776" class="Keyword">open</a> <a id="781" class="Keyword">import</a> <a id="788" href="Haskell.Prim.Enum.html" class="Module">Haskell.Prim.Enum</a>        <a id="813" class="Keyword">public</a>
<a id="820" class="Keyword">open</a> <a id="825" class="Keyword">import</a> <a id="832" href="Haskell.Prim.Eq.html" class="Module">Haskell.Prim.Eq</a>          <a id="857" class="Keyword">public</a>
<a id="864" class="Keyword">open</a> <a id="869" class="Keyword">import</a> <a id="876" href="Haskell.Prim.Foldable.html" class="Module">Haskell.Prim.Foldable</a>    <a id="901" class="Keyword">public</a>
<a id="908" class="Keyword">open</a> <a id="913" class="Keyword">import</a> <a id="920" href="Haskell.Prim.Functor.html" class="Module">Haskell.Prim.Functor</a>     <a id="945" class="Keyword">public</a>
<a id="952" class="Keyword">open</a> <a id="957" class="Keyword">import</a> <a id="964" href="Haskell.Prim.Int.html" class="Module">Haskell.Prim.Int</a>         <a id="989" class="Keyword">public</a>
<a id="996" class="Keyword">open</a> <a id="1001" class="Keyword">import</a> <a id="1008" href="Haskell.Prim.Integer.html" class="Module">Haskell.Prim.Integer</a>     <a id="1033" class="Keyword">public</a>
<a id="1040" class="Keyword">open</a> <a id="1045" class="Keyword">import</a> <a id="1052" href="Haskell.Prim.IO.html" class="Module">Haskell.Prim.IO</a>          <a id="1077" class="Keyword">public</a>
<a id="1084" class="Keyword">open</a> <a id="1089" class="Keyword">import</a> <a id="1096" href="Haskell.Prim.List.html" class="Module">Haskell.Prim.List</a>        <a id="1121" class="Keyword">public</a>
<a id="1128" class="Keyword">open</a> <a id="1133" class="Keyword">import</a> <a id="1140" href="Haskell.Prim.Maybe.html" class="Module">Haskell.Prim.Maybe</a>       <a id="1165" class="Keyword">public</a>
<a id="1172" class="Keyword">open</a> <a id="1177" class="Keyword">import</a> <a id="1184" href="Haskell.Prim.Monad.html" class="Module">Haskell.Prim.Monad</a>       <a id="1209" class="Keyword">public</a>
<a id="1216" class="Keyword">open</a> <a id="1221" class="Keyword">import</a> <a id="1228" href="Haskell.Prim.Monoid.html" class="Module">Haskell.Prim.Monoid</a>      <a id="1253" class="Keyword">public</a>
<a id="1260" class="Keyword">open</a> <a id="1265" class="Keyword">import</a> <a id="1272" href="Haskell.Prim.Num.html" class="Module">Haskell.Prim.Num</a>         <a id="1297" class="Keyword">public</a>
<a id="1304" class="Keyword">open</a> <a id="1309" class="Keyword">import</a> <a id="1316" href="Haskell.Prim.Ord.html" class="Module">Haskell.Prim.Ord</a>         <a id="1341" class="Keyword">public</a>
<a id="1348" class="Keyword">open</a> <a id="1353" class="Keyword">import</a> <a id="1360" href="Haskell.Prim.Show.html" class="Module">Haskell.Prim.Show</a>        <a id="1385" class="Keyword">public</a>
<a id="1392" class="Keyword">open</a> <a id="1397" class="Keyword">import</a> <a id="1404" href="Haskell.Prim.String.html" class="Module">Haskell.Prim.String</a>      <a id="1429" class="Keyword">public</a>
<a id="1436" class="Keyword">open</a> <a id="1441" class="Keyword">import</a> <a id="1448" href="Haskell.Prim.Traversable.html" class="Module">Haskell.Prim.Traversable</a> <a id="1473" class="Keyword">public</a>
<a id="1480" class="Keyword">open</a> <a id="1485" class="Keyword">import</a> <a id="1492" href="Haskell.Prim.Tuple.html" class="Module">Haskell.Prim.Tuple</a>       <a id="1517" class="Keyword">public</a> <a id="1524" class="Keyword">hiding</a> <a id="1531" class="Symbol">(</a><a id="1532" href="Haskell.Prim.Tuple.html#452" class="Function">first</a><a id="1537" class="Symbol">;</a> <a id="1539" href="Haskell.Prim.Tuple.html#511" class="Function">second</a><a id="1545" class="Symbol">;</a> <a id="1547" href="Haskell.Prim.Tuple.html#572" class="Function Operator">_***_</a><a id="1552" class="Symbol">)</a>
<a id="1554" class="Keyword">open</a> <a id="1559" class="Keyword">import</a> <a id="1566" href="Haskell.Prim.Word.html" class="Module">Haskell.Prim.Word</a>        <a id="1591" class="Keyword">public</a>

<a id="1599" class="Comment">-- Problematic features</a>
<a id="1623" class="Comment">--  - [Partial]:  Could pass implicit/instance arguments to prove totality.</a>
<a id="1699" class="Comment">--  - [Float]:    Or Float (Agda floats are Doubles)</a>
<a id="1752" class="Comment">--  - [Infinite]: Define colists and map to Haskell lists?</a>

<a id="1812" class="Comment">-- Missing from the Haskell Prelude:</a>
<a id="1849" class="Comment">--</a>
<a id="1852" class="Comment">--     Float        [Float]</a>
<a id="1880" class="Comment">--     Rational</a>
<a id="1896" class="Comment">--</a>
<a id="1899" class="Comment">--     Real(toRational),</a>
<a id="1924" class="Comment">--     Integral(quot, rem, div, mod, quotRem, divMod, toInteger),</a>
<a id="1990" class="Comment">--     Fractional((/), recip, fromRational),</a>
<a id="2035" class="Comment">--     Floating(pi, exp, log, sqrt, (**), logBase, sin, cos, tan,</a>
<a id="2101" class="Comment">--              asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh),</a>
<a id="2175" class="Comment">--     RealFrac(properFraction, truncate, round, ceiling, floor),</a>
<a id="2241" class="Comment">--     RealFloat(floatRadix, floatDigits, floatRange, decodeFloat,</a>
<a id="2308" class="Comment">--               encodeFloat, exponent, significand, scaleFloat, isNaN,</a>
<a id="2380" class="Comment">--               isInfinite, isDenormalized, isIEEE, isNegativeZero, atan2),</a>
<a id="2457" class="Comment">--</a>
<a id="2460" class="Comment">--     subtract, even, odd, gcd, lcm, (^), (^^),</a>
<a id="2509" class="Comment">--     fromIntegral, realToFrac,</a>
<a id="2542" class="Comment">--</a>
<a id="2545" class="Comment">--     foldr1, foldl1, maximum, minimum      [Partial]</a>
<a id="2600" class="Comment">--</a>
<a id="2603" class="Comment">--     until [Partial]</a>
<a id="2626" class="Comment">--</a>
<a id="2629" class="Comment">--     iterate, repeat, cycle          [Infinite]</a>
<a id="2679" class="Comment">--</a>
<a id="2682" class="Comment">--     ReadS, Read(readsPrec, readList),</a>
<a id="2723" class="Comment">--     reads, readParen, read, lex,</a>
<a id="2759" class="Comment">--</a>
<a id="2762" class="Comment">--     IO, putChar, putStr, putStrLn, print,</a>
<a id="2807" class="Comment">--     getChar, getLine, getContents, interact,</a>
<a id="2855" class="Comment">--     FilePath, readFile, writeFile, appendFile, readIO, readLn,</a>
<a id="2921" class="Comment">--     IOError, ioError, userError,</a>


<a id="2959" class="Comment">--------------------------------------------------</a>
<a id="3010" class="Comment">-- Functions</a>

<a id="3024" class="Keyword">infixr</a> <a id="3031" class="Number">0</a> <a id="3033" href="Haskell.Prelude.html#3039" class="Function Operator">_$!_</a>

<a id="_$!_"></a><a id="3039" href="Haskell.Prelude.html#3039" class="Function Operator">_$!_</a> <a id="3044" class="Symbol">:</a> <a id="3046" class="Symbol">(</a><a id="3047" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3049" class="Symbol">→</a> <a id="3051" href="Haskell.Prim.html#1193" class="Generalizable">b</a><a id="3052" class="Symbol">)</a> <a id="3054" class="Symbol">→</a> <a id="3056" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3058" class="Symbol">→</a> <a id="3060" href="Haskell.Prim.html#1193" class="Generalizable">b</a>
<a id="3062" href="Haskell.Prelude.html#3039" class="Function Operator">_$!_</a> <a id="3067" class="Symbol">=</a> <a id="3069" href="Haskell.Prim.html#1480" class="Function Operator">_$_</a>

<a id="seq"></a><a id="3074" href="Haskell.Prelude.html#3074" class="Function">seq</a> <a id="3078" class="Symbol">:</a> <a id="3080" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3082" class="Symbol">→</a> <a id="3084" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="3086" class="Symbol">→</a> <a id="3088" href="Haskell.Prim.html#1193" class="Generalizable">b</a>
<a id="3090" href="Haskell.Prelude.html#3074" class="Function">seq</a> <a id="3094" class="Symbol">=</a> <a id="3096" href="Haskell.Prim.html#1434" class="Function">const</a> <a id="3102" href="Haskell.Prim.html#1296" class="Function">id</a>

<a id="asTypeOf"></a><a id="3106" href="Haskell.Prelude.html#3106" class="Function">asTypeOf</a> <a id="3115" class="Symbol">:</a> <a id="3117" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3119" class="Symbol">→</a> <a id="3121" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3123" class="Symbol">→</a> <a id="3125" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3127" href="Haskell.Prelude.html#3106" class="Function">asTypeOf</a> <a id="3136" href="Haskell.Prelude.html#3136" class="Bound">x</a> <a id="3138" class="Symbol">_</a> <a id="3140" class="Symbol">=</a> <a id="3142" href="Haskell.Prelude.html#3136" class="Bound">x</a>

<a id="undefined"></a><a id="3145" href="Haskell.Prelude.html#3145" class="Function">undefined</a> <a id="3155" class="Symbol">:</a> <a id="3157" class="Symbol">{@</a><a id="3159" class="Symbol">0</a> <a id="3161" class="Symbol">@(</a><a id="3163" class="Keyword">tactic</a> <a id="3170" href="Haskell.Prim.Absurd.html#614" class="Function">absurd</a><a id="3176" class="Symbol">)</a> <a id="3178" href="Haskell.Prelude.html#3178" class="Bound">i</a> <a id="3180" class="Symbol">:</a> <a id="3182" href="Haskell.Prim.html#2596" class="Datatype">⊥</a><a id="3183" class="Symbol">}</a> <a id="3185" class="Symbol">→</a> <a id="3187" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3189" href="Haskell.Prelude.html#3145" class="Function">undefined</a> <a id="3199" class="Symbol">{</a><a id="3200" class="Argument">i</a> <a id="3202" class="Symbol">=</a> <a id="3204" class="Symbol">()}</a>

<a id="error"></a><a id="3209" href="Haskell.Prelude.html#3209" class="Function">error</a> <a id="3215" class="Symbol">:</a> <a id="3217" class="Symbol">{@</a><a id="3219" class="Symbol">0</a> <a id="3221" class="Symbol">@(</a><a id="3223" class="Keyword">tactic</a> <a id="3230" href="Haskell.Prim.Absurd.html#614" class="Function">absurd</a><a id="3236" class="Symbol">)</a> <a id="3238" href="Haskell.Prelude.html#3238" class="Bound">i</a> <a id="3240" class="Symbol">:</a> <a id="3242" href="Haskell.Prim.html#2596" class="Datatype">⊥</a><a id="3243" class="Symbol">}</a> <a id="3245" class="Symbol">→</a> <a id="3247" href="Haskell.Prim.String.html#344" class="Function">String</a> <a id="3254" class="Symbol">→</a> <a id="3256" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3258" href="Haskell.Prelude.html#3209" class="Function">error</a> <a id="3264" class="Symbol">{</a><a id="3265" class="Argument">i</a> <a id="3267" class="Symbol">=</a> <a id="3269" class="Symbol">()}</a> <a id="3273" href="Haskell.Prelude.html#3273" class="Bound">err</a>

<a id="errorWithoutStackTrace"></a><a id="3278" href="Haskell.Prelude.html#3278" class="Function">errorWithoutStackTrace</a> <a id="3301" class="Symbol">:</a> <a id="3303" class="Symbol">{@</a><a id="3305" class="Symbol">0</a> <a id="3307" class="Symbol">@(</a><a id="3309" class="Keyword">tactic</a> <a id="3316" href="Haskell.Prim.Absurd.html#614" class="Function">absurd</a><a id="3322" class="Symbol">)</a> <a id="3324" href="Haskell.Prelude.html#3324" class="Bound">i</a> <a id="3326" class="Symbol">:</a> <a id="3328" href="Haskell.Prim.html#2596" class="Datatype">⊥</a><a id="3329" class="Symbol">}</a> <a id="3331" class="Symbol">→</a> <a id="3333" href="Haskell.Prim.String.html#344" class="Function">String</a> <a id="3340" class="Symbol">→</a> <a id="3342" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3344" href="Haskell.Prelude.html#3278" class="Function">errorWithoutStackTrace</a> <a id="3367" class="Symbol">{</a><a id="3368" class="Argument">i</a> <a id="3370" class="Symbol">=</a> <a id="3372" class="Symbol">()}</a> <a id="3376" href="Haskell.Prelude.html#3376" class="Bound">err</a>

<a id="3381" class="Comment">-------------------------------------------------</a>
<a id="3431" class="Comment">-- More List functions</a>
<a id="3454" class="Comment">--   These uses Eq, Ord, or Foldable, so can&#39;t go in Prim.List without</a>
<a id="3525" class="Comment">--   turning those dependencies around.</a>

<a id="reverse"></a><a id="3566" href="Haskell.Prelude.html#3566" class="Function">reverse</a> <a id="3574" class="Symbol">:</a> <a id="3576" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3581" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3583" class="Symbol">→</a> <a id="3585" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3590" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3592" href="Haskell.Prelude.html#3566" class="Function">reverse</a> <a id="3600" class="Symbol">=</a> <a id="3602" href="Haskell.Prim.Foldable.html#566" class="Field">foldl</a> <a id="3608" class="Symbol">(</a><a id="3609" href="Haskell.Prim.html#1383" class="Function">flip</a> <a id="3614" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="3617" class="Symbol">)</a> <a id="3619" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="3623" class="Keyword">infixl</a> <a id="3630" class="Number">9</a> <a id="3632" href="Haskell.Prelude.html#3769" class="Function Operator">_!!_</a> <a id="3637" href="Haskell.Prelude.html#3644" class="Function Operator">_!!ᴺ_</a>

<a id="_!!ᴺ_"></a><a id="3644" href="Haskell.Prelude.html#3644" class="Function Operator">_!!ᴺ_</a> <a id="3650" class="Symbol">:</a> <a id="3652" class="Symbol">(</a><a id="3653" href="Haskell.Prelude.html#3653" class="Bound">xs</a> <a id="3656" class="Symbol">:</a> <a id="3658" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3663" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3664" class="Symbol">)</a> <a id="3666" class="Symbol">(</a><a id="3667" href="Haskell.Prelude.html#3667" class="Bound">n</a> <a id="3669" class="Symbol">:</a> <a id="3671" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a><a id="3674" class="Symbol">)</a> <a id="3676" class="Symbol">→</a> <a id="3678" class="Symbol">@</a><a id="3679" class="Symbol">0</a> <a id="3681" class="Symbol">⦃</a> <a id="3683" href="Haskell.Prim.html#2981" class="Datatype">IsTrue</a> <a id="3690" class="Symbol">(</a><a id="3691" href="Haskell.Prelude.html#3667" class="Bound">n</a> <a id="3693" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="3695" href="Haskell.Prim.html#2428" class="Function">lengthNat</a> <a id="3705" href="Haskell.Prelude.html#3653" class="Bound">xs</a><a id="3707" class="Symbol">)</a> <a id="3709" class="Symbol">⦄</a> <a id="3711" class="Symbol">→</a> <a id="3713" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3715" class="Symbol">(</a><a id="3716" href="Haskell.Prelude.html#3716" class="Bound">x</a> <a id="3718" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3720" href="Haskell.Prelude.html#3720" class="Bound">xs</a><a id="3722" class="Symbol">)</a> <a id="3724" href="Haskell.Prelude.html#3644" class="Function Operator">!!ᴺ</a> <a id="3728" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="3734" class="Symbol">=</a> <a id="3736" href="Haskell.Prelude.html#3716" class="Bound">x</a>
<a id="3738" class="Symbol">(</a><a id="3739" href="Haskell.Prelude.html#3739" class="Bound">x</a> <a id="3741" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3743" href="Haskell.Prelude.html#3743" class="Bound">xs</a><a id="3745" class="Symbol">)</a> <a id="3747" href="Haskell.Prelude.html#3644" class="Function Operator">!!ᴺ</a> <a id="3751" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3755" href="Haskell.Prelude.html#3755" class="Bound">n</a> <a id="3757" class="Symbol">=</a> <a id="3759" href="Haskell.Prelude.html#3743" class="Bound">xs</a> <a id="3762" href="Haskell.Prelude.html#3644" class="Function Operator">!!ᴺ</a> <a id="3766" href="Haskell.Prelude.html#3755" class="Bound">n</a>

<a id="_!!_"></a><a id="3769" href="Haskell.Prelude.html#3769" class="Function Operator">_!!_</a> <a id="3774" class="Symbol">:</a> <a id="3776" class="Symbol">(</a><a id="3777" href="Haskell.Prelude.html#3777" class="Bound">xs</a> <a id="3780" class="Symbol">:</a> <a id="3782" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3787" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3788" class="Symbol">)</a> <a id="3790" class="Symbol">(</a><a id="3791" href="Haskell.Prelude.html#3791" class="Bound">n</a> <a id="3793" class="Symbol">:</a> <a id="3795" href="Haskell.Prim.Int.html#367" class="Datatype">Int</a><a id="3798" class="Symbol">)</a>
     <a id="3805" class="Symbol">→</a> <a id="3807" class="Symbol">⦃</a> <a id="3809" class="Symbol">@</a><a id="3810" class="Symbol">0</a> <a id="3812" href="Haskell.Prelude.html#3812" class="Bound">nn</a> <a id="3815" class="Symbol">:</a> <a id="3817" href="Haskell.Prim.Int.html#2469" class="Function">IsNonNegativeInt</a> <a id="3834" href="Haskell.Prelude.html#3791" class="Bound">n</a> <a id="3836" class="Symbol">⦄</a>
     <a id="3843" class="Symbol">→</a> <a id="3845" class="Symbol">⦃</a> <a id="3847" class="Symbol">@</a><a id="3848" class="Symbol">0</a> <a id="3850" href="Haskell.Prelude.html#3850" class="Bound">_</a>  <a id="3853" class="Symbol">:</a> <a id="3855" href="Haskell.Prim.html#2981" class="Datatype">IsTrue</a> <a id="3862" class="Symbol">(</a><a id="3863" href="Haskell.Prim.Int.html#2661" class="Function">intToNat</a> <a id="3872" href="Haskell.Prelude.html#3791" class="Bound">n</a> <a id="3874" class="Symbol">{{</a><a id="3876" href="Haskell.Prelude.html#3812" class="Bound">nn</a><a id="3878" class="Symbol">}}</a> <a id="3881" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="3883" href="Haskell.Prim.html#2428" class="Function">lengthNat</a> <a id="3893" href="Haskell.Prelude.html#3777" class="Bound">xs</a><a id="3895" class="Symbol">)</a> <a id="3897" class="Symbol">⦄</a> <a id="3899" class="Symbol">→</a> <a id="3901" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="3903" href="Haskell.Prelude.html#3903" class="Bound">xs</a> <a id="3906" href="Haskell.Prelude.html#3769" class="Function Operator">!!</a> <a id="3909" href="Haskell.Prelude.html#3909" class="Bound">n</a> <a id="3911" class="Symbol">=</a> <a id="3913" href="Haskell.Prelude.html#3903" class="Bound">xs</a> <a id="3916" href="Haskell.Prelude.html#3644" class="Function Operator">!!ᴺ</a> <a id="3920" href="Haskell.Prim.Int.html#2661" class="Function">intToNat</a> <a id="3929" href="Haskell.Prelude.html#3909" class="Bound">n</a>

<a id="lookup"></a><a id="3932" href="Haskell.Prelude.html#3932" class="Function">lookup</a> <a id="3939" class="Symbol">:</a> <a id="3941" class="Symbol">⦃</a> <a id="3943" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="3946" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3948" class="Symbol">⦄</a> <a id="3950" class="Symbol">→</a> <a id="3952" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3954" class="Symbol">→</a> <a id="3956" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3961" class="Symbol">(</a><a id="3962" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3964" href="Haskell.Prim.Tuple.html#169" class="Record Operator">×</a> <a id="3966" href="Haskell.Prim.html#1193" class="Generalizable">b</a><a id="3967" class="Symbol">)</a> <a id="3969" class="Symbol">→</a> <a id="3971" href="Haskell.Prim.Maybe.html#101" class="Datatype">Maybe</a> <a id="3977" href="Haskell.Prim.html#1193" class="Generalizable">b</a>
<a id="3979" href="Haskell.Prelude.html#3932" class="Function">lookup</a> <a id="3986" href="Haskell.Prelude.html#3986" class="Bound">x</a> <a id="3988" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>              <a id="4004" class="Symbol">=</a> <a id="4006" href="Haskell.Prim.Maybe.html#142" class="InductiveConstructor">Nothing</a>
<a id="4014" href="Haskell.Prelude.html#3932" class="Function">lookup</a> <a id="4021" href="Haskell.Prelude.html#4021" class="Bound">x</a> <a id="4023" class="Symbol">((</a><a id="4025" href="Haskell.Prelude.html#4025" class="Bound">x₁</a> <a id="4028" href="Haskell.Prim.Tuple.html#211" class="InductiveConstructor Operator">,</a> <a id="4030" href="Haskell.Prelude.html#4030" class="Bound">y</a><a id="4031" class="Symbol">)</a> <a id="4033" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4035" href="Haskell.Prelude.html#4035" class="Bound">xs</a><a id="4037" class="Symbol">)</a> <a id="4039" class="Symbol">=</a> <a id="4041" href="Haskell.Prim.html#1713" class="Function Operator">if</a> <a id="4044" href="Haskell.Prelude.html#4021" class="Bound">x</a> <a id="4046" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="4049" href="Haskell.Prelude.html#4025" class="Bound">x₁</a> <a id="4052" href="Haskell.Prim.html#1713" class="Function Operator">then</a> <a id="4057" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a> <a id="4062" href="Haskell.Prelude.html#4030" class="Bound">y</a> <a id="4064" href="Haskell.Prim.html#1713" class="Function Operator">else</a> <a id="4069" href="Haskell.Prelude.html#3932" class="Function">lookup</a> <a id="4076" href="Haskell.Prelude.html#4021" class="Bound">x</a> <a id="4078" href="Haskell.Prelude.html#4035" class="Bound">xs</a>


<a id="4083" class="Comment">-------------------------------------------------</a>
<a id="4133" class="Comment">-- Unsafe functions</a>

<a id="coerce"></a><a id="4154" href="Haskell.Prelude.html#4154" class="Function">coerce</a> <a id="4161" class="Symbol">:</a> <a id="4163" class="Symbol">@</a><a id="4164" class="Symbol">0</a> <a id="4166" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4168" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4170" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="4172" class="Symbol">→</a> <a id="4174" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4176" class="Symbol">→</a> <a id="4178" href="Haskell.Prim.html#1193" class="Generalizable">b</a>
<a id="4180" href="Haskell.Prelude.html#4154" class="Function">coerce</a> <a id="4187" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="4192" href="Haskell.Prelude.html#4192" class="Bound">x</a> <a id="4194" class="Symbol">=</a> <a id="4196" href="Haskell.Prelude.html#4192" class="Bound">x</a>

<a id="IsJust"></a><a id="4199" href="Haskell.Prelude.html#4199" class="Function">IsJust</a> <a id="4206" class="Symbol">:</a> <a id="4208" href="Haskell.Prim.Maybe.html#101" class="Datatype">Maybe</a> <a id="4214" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4216" class="Symbol">→</a> <a id="4218" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="4222" href="Haskell.Prelude.html#4199" class="Function">IsJust</a> <a id="4229" href="Haskell.Prim.Maybe.html#142" class="InductiveConstructor">Nothing</a>  <a id="4238" class="Symbol">=</a> <a id="4240" href="Haskell.Prim.html#2596" class="Datatype">⊥</a>
<a id="4242" href="Haskell.Prelude.html#4199" class="Function">IsJust</a> <a id="4249" class="Symbol">(</a><a id="4250" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a> <a id="4255" class="Symbol">_)</a> <a id="4258" class="Symbol">=</a> <a id="4260" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

<a id="fromJust"></a><a id="4263" href="Haskell.Prelude.html#4263" class="Function">fromJust</a> <a id="4272" class="Symbol">:</a> <a id="4274" class="Symbol">(</a><a id="4275" href="Haskell.Prelude.html#4275" class="Bound">x</a> <a id="4277" class="Symbol">:</a> <a id="4279" href="Haskell.Prim.Maybe.html#101" class="Datatype">Maybe</a> <a id="4285" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="4286" class="Symbol">)</a> <a id="4288" class="Symbol">→</a> <a id="4290" class="Symbol">@</a><a id="4291" class="Symbol">0</a> <a id="4293" class="Symbol">{</a><a id="4294" href="Haskell.Prelude.html#4199" class="Function">IsJust</a> <a id="4301" href="Haskell.Prelude.html#4275" class="Bound">x</a><a id="4302" class="Symbol">}</a> <a id="4304" class="Symbol">→</a> <a id="4306" href="Haskell.Prim.html#1191" class="Generalizable">a</a>
<a id="4308" href="Haskell.Prelude.html#4263" class="Function">fromJust</a> <a id="4317" href="Haskell.Prim.Maybe.html#142" class="InductiveConstructor">Nothing</a>  <a id="4326" class="Symbol">=</a> <a id="4328" href="Haskell.Prelude.html#3209" class="Function">error</a> <a id="4334" class="String">&quot;fromJust Nothing&quot;</a>
<a id="4353" href="Haskell.Prelude.html#4263" class="Function">fromJust</a> <a id="4362" class="Symbol">(</a><a id="4363" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a> <a id="4368" href="Haskell.Prelude.html#4368" class="Bound">x</a><a id="4369" class="Symbol">)</a> <a id="4371" class="Symbol">=</a> <a id="4373" href="Haskell.Prelude.html#4368" class="Bound">x</a>
</pre></body></html>
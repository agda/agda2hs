<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorials &mdash; agda2hs  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Features" href="features.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> agda2hs
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html#imports">Imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html#rewrite-rules-and-prelude-imports">Rewrite rules and Prelude imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html#emacs-mode">Emacs mode</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#how-to-build-a-small-library-in-agda2hs">How to build a small library in agda2hs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#compilation">Compilation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-manage-structure-and-dependencies-of-a-bigger-repository">How to manage structure and dependencies of a bigger repository?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Compilation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#how-and-what-to-prove">How (and what) to prove?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#constructor-constraints">Constructor constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-or-predicate">Function or Predicate?</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">agda2hs</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">Tutorials</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/tutorials.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorials">
<h1>Tutorials<a class="headerlink" href="#tutorials" title="Permalink to this heading"></a></h1>
<p>The repositories relevant to the tutorials can be found <a class="reference external" href="https://github.com/wcqaguxa/agda2hs-examples">on github</a>.</p>
<section id="how-to-build-a-small-library-in-agda2hs">
<h2>How to build a small library in agda2hs<a class="headerlink" href="#how-to-build-a-small-library-in-agda2hs" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://github.com/agda/agda2hs/tree/master/tutorials/example-basics">Example source code</a></p>
<p>After <a class="reference external" href="https://agda.github.io/agda2hs/introduction.html">installing agda2hs</a>, it’s time to write a small library. See the folder example-basics for the files described in this document.</p>
<p>The minimum required to write a library in Agda2Hs is a top-level folder with at least one <code class="docutils literal notranslate"><span class="pre">.agda</span></code> file and an <code class="docutils literal notranslate"><span class="pre">.agda-lib</span></code> file. In the case of example-basics, it looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">example</span><span class="o">-</span><span class="n">basics</span> <span class="p">[</span><span class="n">project</span> <span class="n">root</span><span class="p">]</span>
 <span class="o">-</span> <span class="n">HelloWorld</span><span class="o">.</span><span class="n">agda</span>
 <span class="o">-</span> <span class="n">example</span><span class="o">-</span><span class="n">basics</span><span class="o">.</span><span class="n">agda</span><span class="o">-</span><span class="n">lib</span>
</pre></div>
</div>
<p>More details about Agda’s library management can be found <a class="reference external" href="https://agda.readthedocs.io/en/v2.6.0.1/tools/package-system.html">in the documentation</a>.</p>
<p>This is how the <code class="docutils literal notranslate"><span class="pre">example-basics.agda-lib</span></code> file looks for our project:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span><span class="p">:</span> <span class="n">example</span><span class="o">-</span><span class="n">basics</span>
<span class="n">include</span><span class="p">:</span> <span class="o">.</span>
<span class="n">depend</span><span class="p">:</span> <span class="n">agda2hs</span>
<span class="n">flags</span><span class="p">:</span> <span class="o">--</span><span class="n">erasure</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">include</span></code> label specifies the current folder as the path for files to be included in the library. For our toy example it works perfectly, but for a bigger library it might be handy to place all the <code class="docutils literal notranslate"><span class="pre">.agda</span></code> files in a single repository such as <code class="docutils literal notranslate"><span class="pre">src</span></code>.</p>
<p>The only dependency we need so far is <code class="docutils literal notranslate"><span class="pre">agda2hs</span></code>, as that is where <code class="docutils literal notranslate"><span class="pre">Haskell.Prelude</span></code> and agda2hs pragmas live.</p>
<p>Finally, to be able to  import modules we need in this example, erasure needs to be enabled. We add it as a flag.</p>
<p>Let’s look at the <code class="docutils literal notranslate"><span class="pre">HelloWorld.agda</span></code> file now:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="n">HelloWorld</span><span class="w"> </span><span class="kr">where</span>

<span class="kr">open</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="n">Haskell.Prelude</span>

<span class="c1">--defining a type synonym</span>
Entry<span class="w"> </span><span class="ow">=</span><span class="w"> </span>Int<span class="w"> </span>×<span class="w"> </span>List<span class="w"> </span>String

<span class="c1">--defining a datatype</span>
<span class="kr">data</span><span class="w"> </span>Tree<span class="w"> </span><span class="o">(</span>a<span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="kt">Set</span><span class="o">)</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="nf">Leaf</span><span class="w">   </span><span class="ow">:</span><span class="w"> </span>a<span class="w"> </span><span class="ow">→</span><span class="w"> </span>Tree<span class="w"> </span>a
<span class="w">    </span><span class="nf">Branch</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>a<span class="w"> </span><span class="ow">→</span><span class="w"> </span>Tree<span class="w"> </span>a<span class="w"> </span><span class="ow">→</span><span class="w"> </span>Tree<span class="w"> </span>a<span class="w"> </span><span class="ow">→</span><span class="w"> </span>Tree<span class="w"> </span>a

<span class="c1">--agda2hs pragmas</span>
<span class="cm">{-# COMPILE AGDA2HS Entry #-}</span>

<span class="cm">{-# COMPILE AGDA2HS Tree #-}</span>
</pre></div>
</div>
<p>Let’s look at the first line:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">HelloWorld</span><span class="w"> </span><span class="kr">where</span>
</pre></div>
</div>
<p>Specifying the module name is not strictly necessary for the compilation to work. If missing, the agda2hs compiler will simply take the file name as the module name in Haskell. However, if the file name does not confine to Haskell module naming standards, the resulting Haskell file will be incorrect. Since Agda module naming rules are the same as Haskell’s, encapsulating the file in a properly named module is a good practice to create correct Haskell files.</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="kr">open</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="n">Haskell.Prelude</span>
</pre></div>
</div>
<p>This part is necessary to access Haskell types used in the type synonym example.</p>
<p>Next comes the definition of a type synonym and a datatype. However, they are meaningless without the <code class="docutils literal notranslate"><span class="pre">COMPILE</span> <span class="pre">AGDA2HS</span></code> pragmas. For every new construct (Entry, Tree in this example), there should be one <code class="docutils literal notranslate"><span class="pre">{-#</span> <span class="pre">COMPILE</span> <span class="pre">AGDA2HS</span> <span class="pre">&lt;construct-name&gt;</span> <span class="pre">#-}</span></code> pragma. If the pragma is missing, the relevant agda code will be skipped during compilation.</p>
<p>In general the pragmas can be placed anywhere in the code after the definition, but it is a good practice to place them just under the relevant definition. If the name is misspelled in the pragma, the compiler will issue a warning but continue proceeding.</p>
<section id="compilation">
<h3>Compilation<a class="headerlink" href="#compilation" title="Permalink to this heading"></a></h3>
<p>To verify our code is correct, you can load the Agda file using <code class="docutils literal notranslate"><span class="pre">C-c</span> <span class="pre">C-l</span></code>. In order to compile the file, run <code class="docutils literal notranslate"><span class="pre">agda2hs</span> <span class="pre">HelloWorld.agda</span></code> and verify that the haskell file <code class="docutils literal notranslate"><span class="pre">HelloWorld.hs</span></code> works as expected.</p>
</section>
</section>
<section id="how-to-manage-structure-and-dependencies-of-a-bigger-repository">
<h2>How to manage structure and dependencies of a bigger repository?<a class="headerlink" href="#how-to-manage-structure-and-dependencies-of-a-bigger-repository" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://github.com/agda/agda2hs/tree/master/tutorials/example-structure">Example source code</a></p>
<p>Ideally, a working repository should have more than one file. The repository <code class="docutils literal notranslate"><span class="pre">example-structure</span></code> contains an example of a minimally bigger project, with intuition on how to manage a bigger codebase.</p>
<p>The source code of agda resides in <code class="docutils literal notranslate"><span class="pre">/src/agda</span></code>, which is reflected in the path included in <code class="docutils literal notranslate"><span class="pre">example-structure.agda-lib</span></code> file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span><span class="p">:</span> <span class="n">example</span><span class="o">-</span><span class="n">structure</span>
<span class="n">include</span><span class="p">:</span> <span class="o">./</span><span class="n">src</span><span class="o">/</span><span class="n">agda</span>
<span class="n">depend</span><span class="p">:</span> <span class="n">agda2hs</span>
<span class="n">flags</span><span class="p">:</span> <span class="o">--</span><span class="n">erasure</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">agda</span></code> folder contains two files: <code class="docutils literal notranslate"><span class="pre">Definition.agda</span></code>, which contains a declaration of a data type <code class="docutils literal notranslate"><span class="pre">CountDown</span></code> and <code class="docutils literal notranslate"><span class="pre">Usage.agda</span></code>, which contains its constructor. Usually, there is no good reason to split those in two files, but it gives a good opportunity to show how these would interact under <code class="docutils literal notranslate"><span class="pre">agda2hs</span></code>.</p>
<p>To use the module <code class="docutils literal notranslate"><span class="pre">Definition</span></code> in <code class="docutils literal notranslate"><span class="pre">Usage.agda</span></code>, it has to be imported:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="kr">open</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="n">Definition</span>
</pre></div>
</div>
<p>It does not have to be specified for agda2hs to compile this import. If the import is used by any of the compiled code, the relevant Haskell module will be likewise imported in the target file; the irrelevant imports are automatically skipped.</p>
<p>However, both files need to import <code class="docutils literal notranslate"><span class="pre">Haskell.Prelude</span></code> independently of each other to be able to use it.</p>
<section id="id1">
<h3>Compilation<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<p>In principle, <code class="docutils literal notranslate"><span class="pre">agda2hs</span></code> has to be invoked on file-by-file basis and to define a compilation of a whole folder, additional scripting is necessary. However, since <code class="docutils literal notranslate"><span class="pre">Definition</span></code> is imported in <code class="docutils literal notranslate"><span class="pre">Usage</span></code>, when compiling the latter, the former also will be compiled as it is a dependency. Thus, in our example, it is only necessary to execute <code class="docutils literal notranslate"><span class="pre">agda2hs</span></code> once.</p>
<p>Since the target repository is different than the source, it has to be specified as an argument. An example script, to be executed from the root of <code class="docutils literal notranslate"><span class="pre">example-structure</span></code> is placed in <code class="docutils literal notranslate"><span class="pre">script.sh</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>agda2hs<span class="w"> </span>./src/agda/Usage.agda<span class="w"> </span>-o<span class="w"> </span>./src/haskell/
</pre></div>
</div>
</section>
</section>
<section id="how-and-what-to-prove">
<h2>How (and what) to prove?<a class="headerlink" href="#how-and-what-to-prove" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://github.com/agda/agda2hs/tree/master/tutorials/example-proofs">Example source code</a></p>
<p>This tutorial aims to explain how to apply different formal verification techniques compliant with agda2hs and haskell.</p>
<section id="constructor-constraints">
<h3>Constructor constraints<a class="headerlink" href="#constructor-constraints" title="Permalink to this heading"></a></h3>
<p>The code described in this section can be found in the file <code class="docutils literal notranslate"><span class="pre">Triangle.agda</span></code>.</p>
<p>Let’s say we want to have a data type describing a triangle. A first attempt might look somewhat like this:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="kr">open</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="n">Haskell.Prelude</span>

<span class="kr">data</span><span class="w"> </span>Triangle<span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="nf">MkTriangle</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="o">(</span>alpha<span class="w"> </span>beta<span class="w"> </span>gamma<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Nat<span class="o">)</span>
<span class="w">           </span><span class="ow">→</span><span class="w"> </span>Triangle

<span class="cm">{-# COMPILE AGDA2HS Triangle #-}</span>
</pre></div>
</div>
<p>It’s defined with three angles, because maybe thats the only property we are interested in so far. However, three arbitrary angle values do not make a triangle. First of all, they cannot be negative - to make things easier we use natural numbers (<code class="docutils literal notranslate"><span class="pre">Nat</span></code>) to represent the angle values. But that is not enough, three angles can constitute a triangle only if they sum up to 180 degrees and at most one angle is right or obtuse. This can be modeled in Agda:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="kr">open</span><span class="w"> </span><span class="kr">import</span><span class="w"> </span><span class="n">Haskell.Prelude</span>

<span class="nf">countBiggerThan</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>⦃<span class="w"> </span>Ord<span class="w"> </span>a<span class="w"> </span>⦄<span class="w"> </span><span class="ow">→</span><span class="w"> </span>List<span class="w"> </span>a<span class="w"> </span><span class="ow">→</span><span class="w"> </span>a<span class="w"> </span><span class="ow">→</span><span class="w"> </span>Int<span class="w"> </span>
countBiggerThan<span class="w"> </span>xs<span class="w"> </span>b<span class="w"> </span><span class="ow">=</span><span class="w"> </span>length<span class="w"> </span><span class="o">(</span>filter<span class="w"> </span><span class="o">(</span><span class="ow">λ</span><span class="w"> </span>x<span class="w"> </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>x<span class="w"> </span>&gt;=<span class="w"> </span>b<span class="o">))</span><span class="w"> </span>xs<span class="o">)</span>

<span class="cm">{-# COMPILE AGDA2HS countBiggerThan #-}</span>

<span class="kr">data</span><span class="w"> </span>Triangle<span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="nf">MkTriangle</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="o">(</span>alpha<span class="w"> </span>beta<span class="w"> </span>gamma<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Nat<span class="o">)</span>
<span class="w">        </span><span class="ow">→</span><span class="w"> </span>⦃<span class="w"> </span>@0<span class="w"> </span>h₁<span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="o">(((</span>alpha<span class="w"> </span>+<span class="w"> </span>beta<span class="w"> </span>+<span class="w"> </span>gamma<span class="o">)</span><span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="mi">180</span><span class="o">)</span><span class="w"> </span>≡<span class="w"> </span>True<span class="w"> </span><span class="o">)</span>⦄
<span class="w">        </span><span class="ow">→</span><span class="w"> </span>@0<span class="w"> </span>⦃<span class="w"> </span><span class="o">((</span>countBiggerThan
<span class="w">     </span><span class="o">(</span>alpha<span class="w"> </span>∷<span class="w"> </span>beta<span class="w"> </span>∷<span class="w">  </span>gamma<span class="w"> </span>∷<span class="w"> </span>[]<span class="o">)</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span>&lt;=<span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span>≡<span class="w"> </span>True<span class="w"> </span><span class="o">)</span><span class="w"> </span>⦄
<span class="w">           </span><span class="ow">→</span><span class="w"> </span>Triangle

<span class="cm">{-# COMPILE AGDA2HS Triangle #-}</span>
</pre></div>
</div>
<p>Adding two hypotheses to the type signature of MkTriangle does the trick.
Notice the use of double brackets, which signify the use of <a class="reference external" href="https://agda.readthedocs.io/en/latest/language/instance-arguments.html">instance arguments</a>: they allow Agda to infer the hypotheses if they are present in the context, instead of having them manually applied each and every time.</p>
<p>These hypotheses cannot be compiled to Haskell, therefore they have to be erased. This is done by annotating them with <a class="reference internal" href="features.html#quantity"><span class="std std-ref">0-quantity parameters</span></a>. To correctly annotate a hypothesis with quantity, it has to be explicitly named: in this case h₁. Alternatively, it can also be applied to the whole bracket, like in the second hypothesis.</p>
<p>The helper function <code class="docutils literal notranslate"><span class="pre">countBiggerThan</span></code> could also operate solely on natural numbers, but this way it show another example of using instance arguments, which map to Haskell’s typeclass constraints.</p>
<p>You might want to ask, what is the point of adding hypotheses if they will be erased in Haskell anyway? If you write the remainder of the code in Haskell, it is indeed the case. However, defining the data type in Agda requires the hypotheses to be present when constructing variables of that type:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="nf">createTriangle</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>Nat<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>Nat<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>Nat<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>Maybe<span class="w"> </span>Triangle
createTriangle<span class="w"> </span>alpha<span class="w"> </span>beta<span class="w"> </span>gamma<span class="w"> </span>
<span class="w">    </span><span class="ow">=</span><span class="w"> </span>if<span class="w"> </span><span class="o">(</span>countBiggerThan<span class="w"> </span><span class="o">(</span>alpha<span class="w"> </span>∷<span class="w"> </span>beta<span class="w"> </span>∷<span class="w">  </span>gamma<span class="w"> </span>∷<span class="w"> </span>[]<span class="o">)</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span>&lt;=<span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="w">        </span>then<span class="w"> </span>if<span class="w"> </span><span class="o">(</span>alpha<span class="w"> </span>+<span class="w"> </span>beta<span class="w"> </span>+<span class="w"> </span>gamma<span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="o">)</span>
<span class="w">            </span>then<span class="w"> </span>Just<span class="w"> </span><span class="o">(</span>MkTriangle<span class="w"> </span>alpha<span class="w"> </span>beta<span class="w"> </span>gamma<span class="o">)</span><span class="w"> </span>
<span class="w">            </span>else<span class="w"> </span>Nothing
<span class="w">        </span>else<span class="w"> </span>Nothing

<span class="cm">{-# COMPILE AGDA2HS createTriangle #-}</span>
</pre></div>
</div>
<p>Unfortunately, the instance arguments are inferred only if presented in exactly the same shape as hypotheses in the constructor, which is the cause of perceived redundancy of the if-then-else statement - chaining the hypotheses with <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> (the AND operator defined in <code class="docutils literal notranslate"><span class="pre">Haskell.Prim.Bool</span></code> in Agda2hs) will not allow for the reference to be inferred automatically, and the proofs would have to be provided manually. An example for that can be seen in the alternative <code class="docutils literal notranslate"><span class="pre">createTriangle₁</span></code> function:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="nf">createTriangle₁</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>Nat<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>Nat<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>Nat<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>Maybe<span class="w"> </span>Triangle
createTriangle₁<span class="w"> </span>alpha<span class="w"> </span>beta<span class="w"> </span>gamma<span class="w"> </span>
<span class="w">    </span><span class="ow">=</span><span class="w"> </span>if<span class="w"> </span><span class="o">((</span>countBiggerThan<span class="w"> </span><span class="o">(</span>alpha<span class="w"> </span>∷<span class="w"> </span>beta<span class="w"> </span>∷<span class="w">  </span>gamma<span class="w"> </span>∷<span class="w"> </span>[]<span class="o">)</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span>&lt;=<span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span>
<span class="w">            </span>&amp;&amp;<span class="w"> </span><span class="o">(</span>alpha<span class="w"> </span>+<span class="w"> </span>beta<span class="w"> </span>+<span class="w"> </span>gamma<span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="o">))</span><span class="w"> </span>
<span class="w">        </span>then<span class="w"> </span><span class="o">(</span><span class="ow">λ</span><span class="w"> </span>⦃<span class="w"> </span>h₁<span class="w"> </span>⦄<span class="w"> </span><span class="ow">→</span><span class="w">  </span>Just<span class="w"> </span><span class="o">(</span>MkTriangle<span class="w"> </span>alpha<span class="w"> </span>beta<span class="w"> </span>gamma<span class="w"> </span>
<span class="w">            </span>⦃<span class="w"> </span>&amp;&amp;-rightTrue<span class="w"> </span>
<span class="w">                    </span><span class="o">(</span>countBiggerThan<span class="w"> </span><span class="o">(</span>alpha<span class="w"> </span>∷<span class="w"> </span>beta<span class="w"> </span>∷<span class="w">  </span>gamma<span class="w"> </span>∷<span class="w"> </span>[]<span class="o">)</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span>&lt;=<span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span>
<span class="w">                    </span><span class="o">(</span>alpha<span class="w"> </span>+<span class="w"> </span>beta<span class="w"> </span>+<span class="w"> </span>gamma<span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="o">)</span><span class="w"> </span>
<span class="w">                    </span>h₁<span class="w"> </span>⦄<span class="w"> </span>
<span class="w">            </span>⦃<span class="w"> </span>&amp;&amp;-leftTrue<span class="w"> </span>
<span class="w">                    </span><span class="o">(</span>countBiggerThan<span class="w"> </span><span class="o">(</span>alpha<span class="w"> </span>∷<span class="w"> </span>beta<span class="w"> </span>∷<span class="w">  </span>gamma<span class="w"> </span>∷<span class="w"> </span>[]<span class="o">)</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span>&lt;=<span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span>
<span class="w">                    </span><span class="o">(</span>alpha<span class="w"> </span>+<span class="w"> </span>beta<span class="w"> </span>+<span class="w"> </span>gamma<span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="o">)</span><span class="w"> </span>
<span class="w">                    </span>h₁<span class="w"> </span>⦄<span class="o">)</span><span class="w"> </span><span class="o">)</span>
<span class="w">        </span>else<span class="w"> </span>Nothing
<span class="w"> </span>
<span class="cm">{-# COMPILE AGDA2HS createTriangle₁ #-}</span>
</pre></div>
</div>
<p>While using this alternative function offers much cleaner Haskell code as an output (no nested if statements), however the Agda side gets a bit messier. Two things are worth noting here: first, to be able to operate on the hypothesis asserted in the if condition, the branch has to be rewritten as an anonymous function taking the assertion as instance argument. Secondly, to explicitly provide the instance arguments, it also has to be done inside the double curly brackets.</p>
<p>Lastly, the two functions used to extract conditions from the compound condition: <code class="docutils literal notranslate"><span class="pre">&amp;&amp;-rightTrue</span></code> and <code class="docutils literal notranslate"><span class="pre">&amp;&amp;-leftTrue</span></code> were defined in <code class="docutils literal notranslate"><span class="pre">Haskell.Law.Bool</span></code>. The <code class="docutils literal notranslate"><span class="pre">Law</span></code> folder contains many theorems useful for designing your own proofs. This will be expanded on in following sections.</p>
</section>
<section id="function-or-predicate">
<h3>Function or Predicate?<a class="headerlink" href="#function-or-predicate" title="Permalink to this heading"></a></h3>
<p>The code described in this section can be found in the file <code class="docutils literal notranslate"><span class="pre">Ascending.agda</span></code>.</p>
<p>We will try to define ascending order on lists, which will allow us to use statements about the order in later proofs and programs.</p>
<p>A first attempt at definition could be a function that can provide judgments on instances of lists:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="nf">isAscending</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>⦃<span class="w"> </span>iOrdA<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Ord<span class="w"> </span>a<span class="w"> </span>⦄<span class="w"> </span><span class="ow">→</span><span class="w"> </span>List<span class="w"> </span>a<span class="w"> </span><span class="ow">→</span><span class="w"> </span>Bool
isAscending<span class="w"> </span>[]<span class="w"> </span><span class="ow">=</span><span class="w"> </span>True
isAscending<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>[]<span class="o">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>True
isAscending<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>y<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>if<span class="w"> </span>x<span class="w"> </span>&lt;=<span class="w"> </span>y<span class="w"> </span>then<span class="w"> </span>isAscending<span class="w"> </span>
<span class="w">    </span><span class="o">(</span>y<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>else<span class="w"> </span>False

<span class="cm">{-# COMPILE AGDA2HS isAscending #-}</span>
</pre></div>
</div>
<p>This function can be compiled to Haskell without any issue, however, when you try using it in proofs you can notice that it is not the most handy definition: since the different cases are anonymous, invoking them is not straightforward and might require defining more proof cases with additional assertions about the values input data (an example of which can be found <a class="reference internal" href="#function-example"><span class="std std-ref">further in the tutorial</span></a>) A better definition might be a predicate, instead:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span>IsAscending₂<span class="w"> </span><span class="o">{</span>a<span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="kt">Set</span><span class="o">}</span><span class="w"> </span>⦃<span class="w"> </span>iOrdA<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Ord<span class="w"> </span>a<span class="w"> </span>⦄<span class="w"> </span><span class="ow">:</span><span class="w"> </span>List<span class="w"> </span>a<span class="w"> </span><span class="ow">→</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="nf">Empty</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>IsAscending₂<span class="w"> </span>[]
<span class="w">    </span><span class="nf">OneElem</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="o">(</span>x<span class="w"> </span><span class="ow">:</span><span class="w"> </span>a<span class="o">)</span><span class="w"> </span><span class="ow">→</span><span class="w">  </span>IsAscending₂<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>[]<span class="o">)</span>
<span class="w">    </span><span class="nf">ManyElem</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="o">(</span>x<span class="w"> </span>y<span class="w"> </span><span class="ow">:</span><span class="w"> </span>a<span class="o">)</span><span class="w"> </span><span class="o">(</span>xs<span class="w"> </span><span class="ow">:</span><span class="w"> </span>List<span class="w"> </span>a<span class="o">)</span><span class="w"> </span>
<span class="w">        </span><span class="ow">→</span><span class="w"> </span>⦃<span class="w"> </span>IsAscending₂<span class="w"> </span><span class="o">(</span>y<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>⦄
<span class="w">        </span><span class="ow">→</span><span class="w"> </span>⦃<span class="w"> </span>IsTrue<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>&lt;=<span class="w"> </span>y<span class="o">)</span><span class="w"> </span>⦄
<span class="w">        </span><span class="ow">→</span><span class="w"> </span>IsAscending₂<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>y<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span>
</pre></div>
</div>
<p>This data type cannot be compiled to Haskell, as they do not allow to match on specific values. However, some amount of equivalency can be proven between these two definitions. They are not structurally different (one evaluates to True and the other to a data type), therefore they cannot be equal per the <code class="docutils literal notranslate"><span class="pre">≡</span></code> operator. Instead, there occurs the material equivalence relation (<code class="docutils literal notranslate"><span class="pre">⇔</span></code>), such that if the function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, the predicate holds, and vice versa. Let’s try to prove it then!</p>
<p>The signature of the first direction will look like this:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="nf">proof₁</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>⦃<span class="w"> </span>iOrdA<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Ord<span class="w"> </span>a<span class="w"> </span>⦄<span class="w"> </span><span class="o">(</span>xs<span class="w"> </span><span class="ow">:</span><span class="w"> </span>List<span class="w"> </span>a<span class="o">)</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span>⦃<span class="w"> </span>IsAscending₂<span class="w"> </span>xs<span class="w"> </span>⦄<span class="w"> </span>
<span class="w">    </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>IsTrue<span class="w"> </span><span class="o">(</span>isAscending<span class="w"> </span>xs<span class="o">))</span><span class="w"> </span>
proof<span class="w"> </span>xs<span class="w"> </span><span class="ow">=</span><span class="w"> </span>?
</pre></div>
</div>
<blockquote>
<div><p>Note: in Agda, you can use <a class="reference external" href="https://agda.readthedocs.io/en/latest/tools/emacs-mode.html#commands-in-context-of-a-goal">interactive mode</a> to assist in proofs. Question marks will be loaded to open goals. THis feature doesn’t work yet seamlessly with agda2hs but the preview of context and splitting based on cases will guide with both more complicated and trivial proofs.</p>
</div></blockquote>
<p>Since there are three constructors for the <code class="docutils literal notranslate"><span class="pre">IsAscending₂</span></code> predicate, there need to be only three cases in the proof, two of which are trivial:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="nf">proof₁</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>⦃<span class="w"> </span>iOrdA<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Ord<span class="w"> </span>a<span class="w"> </span>⦄<span class="w"> </span><span class="o">(</span>xs<span class="w"> </span><span class="ow">:</span><span class="w"> </span>List<span class="w"> </span>a<span class="o">)</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span>⦃<span class="w"> </span>IsAscending₂<span class="w"> </span>xs<span class="w"> </span>⦄<span class="w"> </span>
<span class="w">    </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>IsTrue<span class="w"> </span><span class="o">(</span>isAscending<span class="w"> </span>xs<span class="o">))</span><span class="w"> </span>
proof₁<span class="w"> </span>[]<span class="w"> </span><span class="ow">=</span><span class="w"> </span>IsTrue.itsTrue<span class="w"> </span>
proof₁<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>[]<span class="o">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span>IsTrue.itsTrue
proof₁<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>⦃<span class="w"> </span><span class="o">(</span>ManyElem<span class="w"> </span><span class="ow">.</span>x<span class="w"> </span><span class="ow">.</span>x₁<span class="w"> </span><span class="ow">.</span>xs<span class="w"> </span>⦃<span class="w"> </span>h₁<span class="w"> </span>⦄<span class="w"> </span>⦃<span class="w"> </span>h₂<span class="w"> </span>⦄<span class="o">)</span><span class="w"> </span>⦄<span class="w"> </span><span class="ow">=</span><span class="w"> </span>?
</pre></div>
</div>
<p>In the third case, we need insight into the <code class="docutils literal notranslate"><span class="pre">IsAscending₂</span></code> predicate so it has to be explicitly invoked. Later in the proof we will only need the h₂ hypothesis, but because its the second implicit argument, both need to be stated. The goal is of the shape <code class="docutils literal notranslate"><span class="pre">IsTrue</span> <span class="pre">(isAscending</span> <span class="pre">xs)</span></code>, but it cannot be easily constructed. Instead, this goal can be mapped to <code class="docutils literal notranslate"><span class="pre">isAscending</span> <span class="pre">xs</span> <span class="pre">≡</span> <span class="pre">True</span></code>, which allows to use <a class="reference external" href="https://plfa.github.io/Equality/#chains-of-equations">chains of equality</a> syntax - transforming the first statement in the equation step by step until we obtain the second statement in a given equality.</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="nf">useEq</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="o">{</span>x<span class="w"> </span>y<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Bool<span class="o">}</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span>x<span class="w"> </span>≡<span class="w"> </span>y<span class="w"> </span><span class="ow">→</span><span class="w"> </span>IsTrue<span class="w"> </span>x<span class="w"> </span><span class="ow">→</span><span class="w"> </span>IsTrue<span class="w"> </span>y
useEq<span class="w"> </span><span class="o">{</span>True<span class="o">}</span><span class="w"> </span><span class="o">{</span>True<span class="o">}</span><span class="w"> </span>eq<span class="w"> </span>is<span class="w"> </span><span class="ow">=</span><span class="w"> </span>IsTrue.itsTrue

<span class="nf">reverseEq</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span>x<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Bool<span class="w"> </span><span class="o">}</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>IsTrue<span class="w"> </span>x<span class="o">)</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span>x<span class="w"> </span>≡<span class="w"> </span>True
reverseEq<span class="w"> </span><span class="o">{</span>False<span class="o">}</span><span class="w"> </span><span class="o">()</span>
reverseEq<span class="w"> </span><span class="o">{</span>True<span class="o">}</span><span class="w"> </span>input<span class="w"> </span><span class="ow">=</span><span class="w"> </span>refl<span class="w"> </span>

proof₁<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>⦃<span class="w"> </span><span class="o">(</span>ManyElem<span class="w"> </span><span class="ow">.</span>x<span class="w"> </span><span class="ow">.</span>x₁<span class="w"> </span><span class="ow">.</span>xs<span class="w"> </span>⦃<span class="w"> </span>h₁<span class="w"> </span>⦄<span class="w"> </span>⦃<span class="w"> </span>h₂<span class="w"> </span>⦄<span class="o">)</span><span class="w"> </span>⦄<span class="w"> </span><span class="ow">=</span><span class="w"> </span>useEq<span class="w"> </span><span class="o">(</span><span class="w"> </span>sym<span class="w"> </span>$
<span class="w">    </span>begin
<span class="w">        </span>isAscending<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span>
<span class="w">    </span>≡⟨⟩<span class="w"> </span>
<span class="w">        </span><span class="o">(</span>if<span class="w"> </span>x<span class="w"> </span>&lt;=<span class="w"> </span>x₁<span class="w"> </span>then<span class="w"> </span>isAscending<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>else<span class="w"> </span>False<span class="o">)</span>
<span class="w">    </span>≡⟨<span class="w"> </span>ifTrueEqThen<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>&lt;=<span class="w"> </span>x₁<span class="o">)</span><span class="w">  </span><span class="o">(</span>reverseEq<span class="w"> </span>h₂<span class="o">)</span><span class="w"> </span>⟩<span class="w"> </span>
<span class="w">        </span>isAscending<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span>
<span class="w">    </span>≡⟨<span class="w"> </span>reverseEq<span class="w"> </span><span class="o">(</span>proof₁<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span><span class="o">)</span><span class="w"> </span>⟩<span class="w"> </span>
<span class="w">        </span>True
<span class="w">    </span>∎<span class="w"> </span><span class="o">)</span><span class="w"> </span>IsTrue.itsTrue
</pre></div>
</div>
<p>Two helper functions, useEq and reverseEq, had to be added to easily operate on the goal. Even though both of them have trivial proofs, they need to be stated explicitly so that the proper type signature can be invoked. To inspect other helper functions used in the proof, try loading the source code in agda - the definitions all come from <code class="docutils literal notranslate"><span class="pre">Haskell.Prelude</span></code>.</p>
<p>The reverse direction of the iff proof is, again, substantially more complicated. First, the necessary helper proofs will be discussed.</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="c1">--reductio ad absurdum</span>
<span class="nf">absurd₁</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span><span class="o">{</span>x<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Bool<span class="o">}</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>x<span class="w"> </span>≡<span class="w"> </span>True<span class="o">)</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>x<span class="w"> </span>≡<span class="w"> </span>False<span class="o">)</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span>⊥
absurd₁<span class="w"> </span><span class="o">{</span>False<span class="o">}</span><span class="w"> </span><span class="o">()</span><span class="w"> </span>b<span class="w"> </span>
absurd₁<span class="w"> </span><span class="o">{</span>True<span class="o">}</span><span class="w"> </span>a<span class="w"> </span><span class="o">()</span>
</pre></div>
</div>
<p>Reductio ad absurdum is a necessary tactic for dealing with self-contradictory statements. If such statement is one of the input arguments, this contradiction can be discarded with the <a class="reference external" href="https://agda.readthedocs.io/en/latest/language/function-definitions.html#absurd-patterns"><code class="docutils literal notranslate"><span class="pre">()</span></code> keyword</a> in place of the contradictory argument. However, if the absurd is arising from some combination of the input arguments, it requires some helper method.</p>
<div class="highlight-agda notranslate" id="function-example"><div class="highlight"><pre><span></span><span class="c1">--inductive hypothesis for isAscending function</span>
<span class="nf">helper₁</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>⦃<span class="w"> </span>iOrdA<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Ord<span class="w"> </span>a<span class="w"> </span>⦄<span class="w"> </span><span class="o">(</span>x<span class="w"> </span><span class="ow">:</span><span class="w"> </span>a<span class="o">)</span><span class="w"> </span><span class="o">(</span>xs<span class="w"> </span><span class="ow">:</span><span class="w"> </span>List<span class="w"> </span>a<span class="o">)</span><span class="w"> </span>
<span class="w">    </span><span class="ow">→</span><span class="w"> </span>isAscending<span class="w"> </span>xs<span class="w"> </span>≡<span class="w"> </span>False<span class="w"> </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>isAscending<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">))</span><span class="w"> </span>≡<span class="w"> </span>False
helper₁<span class="w"> </span>x<span class="w"> </span>xs<span class="w"> </span>h₁<span class="w"> </span><span class="kr">with</span><span class="w"> </span><span class="o">(</span>isAscending<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">))</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span>h₂
helper₁<span class="w"> </span>x<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="ow">|</span><span class="w"> </span>True<span class="w">  </span><span class="kr">with</span><span class="w"> </span><span class="o">(</span>x<span class="w"> </span>&lt;=<span class="w"> </span>x₁<span class="o">)</span>
helper₁<span class="w"> </span>x<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="ow">|</span><span class="w"> </span>True<span class="w"> </span><span class="ow">|</span><span class="w"> </span>True<span class="w"> </span><span class="ow">=</span><span class="w"> </span>magic<span class="w"> </span><span class="o">(</span>absurd₁<span class="w"> </span>h₂<span class="w"> </span>h₁<span class="o">)</span>
helper₁<span class="w"> </span>x<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="ow">|</span><span class="w"> </span>True<span class="w"> </span><span class="ow">|</span><span class="w"> </span>False<span class="w"> </span><span class="ow">=</span><span class="w"> </span>sym<span class="w"> </span>h₂
helper₁<span class="w"> </span>x<span class="w"> </span>xs<span class="w"> </span>h₁<span class="w"> </span><span class="ow">|</span><span class="w"> </span>False<span class="w"> </span><span class="ow">=</span><span class="w"> </span>refl
</pre></div>
</div>
<p>Here is a helper method for the inductive hypothesis. Notice that where in the predicate syntax we were able to pattern-match on the different constructor, when working with a function, the only way to narrow down to different cases is to pattern match on the possible values of the function output. The <a class="reference external" href="https://agda.readthedocs.io/en/latest/language/with-abstraction.html"><code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">...</span> <span class="pre">in</span></code> syntax</a> can be used in such cases. In the first usage of the syntax, the output of the function is needed to be applied in the proof, so it needs to be saved <em>in</em> a value to be accessed in the context. This is what applying <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">h₂</span></code> achieves. In the second usage, Agda manages to simplify the necessary arguments automatically, so it is not necessary to add the assertion to the syntax.</p>
<p>The applied <code class="docutils literal notranslate"><span class="pre">absurd₁</span></code> function can be given as input argument to the <code class="docutils literal notranslate"><span class="pre">magic</span></code> function to resolve the internal contradiction. <code class="docutils literal notranslate"><span class="pre">magic</span></code> lives in <code class="docutils literal notranslate"><span class="pre">Haskell.Prim</span></code> which also needs to be imported.</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="c1">--proof for (function returns true) → predicate holds</span>
<span class="nf">theorem₂</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>⦃<span class="w"> </span>iOrdA<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Ord<span class="w"> </span>a<span class="w"> </span>⦄<span class="w"> </span><span class="o">(</span>xs<span class="w"> </span><span class="ow">:</span><span class="w"> </span>List<span class="w"> </span>a<span class="o">)</span><span class="w"> </span>
<span class="w">    </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>IsTrue<span class="w"> </span><span class="o">(</span>isAscending<span class="w"> </span>xs<span class="o">))</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span>IsAscending₂<span class="w"> </span>xs
theorem₂<span class="w"> </span>[]<span class="w"> </span>h₁<span class="w"> </span><span class="ow">=</span><span class="w"> </span>Empty
theorem₂<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>[]<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="ow">=</span><span class="w"> </span>OneElem<span class="w"> </span>x
theorem₂<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="kr">with</span><span class="w"> </span><span class="o">(</span>isAscending<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span>h₂<span class="w"> </span><span class="ow">|</span><span class="w"> </span><span class="o">(</span>x<span class="w"> </span>&lt;=<span class="w"> </span>x₁<span class="o">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span>h₃
theorem₂<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="ow">|</span><span class="w"> </span>True<span class="w">  </span><span class="ow">|</span><span class="w"> </span>True<span class="w"> </span><span class="ow">=</span><span class="w"> </span>ManyElem<span class="w"> </span>x<span class="w"> </span>x₁<span class="w"> </span>xs<span class="w">  </span>
<span class="w">    </span>⦃<span class="w"> </span>theorem₂helper<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span>⦄<span class="w"> </span>⦃<span class="w"> </span>useEq<span class="w"> </span><span class="o">(</span><span class="w"> </span>sym<span class="w"> </span>$<span class="w"> </span>h₃<span class="w"> </span><span class="o">)</span><span class="w"> </span>IsTrue.itsTrue<span class="w"> </span>⦄
theorem₂<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span><span class="o">()</span><span class="w">    </span><span class="ow">|</span><span class="w"> </span>_<span class="w">  </span><span class="ow">|</span><span class="w"> </span>False<span class="w"> </span>
theorem₂<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="ow">|</span><span class="w"> </span>False<span class="w"> </span><span class="ow">|</span><span class="w"> </span>True<span class="w"> </span><span class="ow">=</span><span class="w"> </span>magic<span class="w"> </span><span class="o">(</span>
<span class="w">         </span>absurd₁<span class="w"> </span><span class="o">(</span>reverseEq<span class="w"> </span>h₁<span class="o">)</span><span class="w"> </span><span class="o">(</span>helper₁<span class="w"> </span>x₁<span class="w"> </span>xs<span class="w"> </span>h₂<span class="o">)</span><span class="w"> </span><span class="o">)</span>
</pre></div>
</div>
<p>Finally, the proof can be constructed. The recursive case of the proof had to be split into three different cases, but in the place where one would expect to be able to use <code class="docutils literal notranslate"><span class="pre">theorem₂</span></code> recursively, <code class="docutils literal notranslate"><span class="pre">theorem₂helper</span></code> is used instead:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="c1">--recursion helper</span>
postulate3
<span class="w">   </span><span class="nf">theorem₂helper</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>⦃<span class="w"> </span>iOrdA<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Ord<span class="w"> </span>a<span class="w"> </span>⦄<span class="w"> </span><span class="o">(</span>xs<span class="w"> </span><span class="ow">:</span><span class="w"> </span>List<span class="w"> </span>a<span class="o">)</span><span class="w"> </span>
<span class="w">        </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>IsTrue<span class="w"> </span><span class="o">(</span>isAscending<span class="w"> </span>xs<span class="o">))</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span>IsAscending₂<span class="w"> </span>xs
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">theorem₂helper</span></code> is a definition of the same type as the actual proof, but without a proof attached - it was only postulated. <a class="reference external" href="https://agda.readthedocs.io/en/latest/language/postulates.html">Postulates</a> are in general a bad practice. Here it was necessary, as the termination check did not recognize that it is being applied to a recursive case. However, doesn’t this invalidate the whole proof? Since postulates are a bad practice, can we do better? Turns out, termination checks on recursive cases <a class="reference external" href="https://agda.readthedocs.io/en/latest/language/with-abstraction.html#termination-checking">is a known issue when using <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">abstraction</span></code></a>. Thus, in the next attempt, we can get rid of the postulate:</p>
<div class="highlight-agda notranslate"><div class="highlight"><pre><span></span><span class="nf">helper₂</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>⦃<span class="w"> </span>iOrdA<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Ord<span class="w"> </span>a<span class="w"> </span>⦄<span class="w"> </span><span class="o">(</span>x<span class="w"> </span><span class="ow">:</span><span class="w"> </span>a<span class="o">)</span><span class="w"> </span><span class="o">(</span>xs<span class="w"> </span><span class="ow">:</span><span class="w"> </span>List<span class="w"> </span>a<span class="o">)</span><span class="w"> </span>
<span class="w">    </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>IsTrue<span class="w"> </span><span class="o">(</span>isAscending<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)))</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>IsTrue<span class="w"> </span><span class="o">(</span>isAscending<span class="w"> </span>xs<span class="o">))</span>
helper₂<span class="w"> </span>x<span class="w"> </span>[]<span class="w"> </span>h₁<span class="w"> </span><span class="ow">=</span><span class="w"> </span>IsTrue.itsTrue
helper₂<span class="w"> </span>x<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="kr">with</span><span class="w"> </span><span class="o">(</span>x<span class="w"> </span>&lt;=<span class="w"> </span>x₁<span class="o">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span>h₂
helper₂<span class="w"> </span>x<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="ow">|</span><span class="w"> </span>True<span class="w"> </span><span class="ow">=</span><span class="w"> </span>h₁
helper₂<span class="w"> </span>x<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span><span class="o">()</span><span class="w"> </span><span class="ow">|</span><span class="w"> </span>False<span class="w"> </span>

<span class="c1">--proof for (function returns true) → predicate holds version 2</span>
<span class="nf">theorem₃</span><span class="w"> </span><span class="ow">:</span><span class="w"> </span>⦃<span class="w"> </span>iOrdA<span class="w"> </span><span class="ow">:</span><span class="w"> </span>Ord<span class="w"> </span>a<span class="w"> </span>⦄<span class="w"> </span><span class="o">(</span>xs<span class="w"> </span><span class="ow">:</span><span class="w"> </span>List<span class="w"> </span>a<span class="o">)</span><span class="w"> </span>
<span class="w">    </span><span class="ow">→</span><span class="w"> </span><span class="o">(</span>IsTrue<span class="w"> </span><span class="o">(</span>isAscending<span class="w"> </span>xs<span class="o">))</span><span class="w"> </span><span class="ow">→</span><span class="w"> </span>IsAscending₂<span class="w"> </span>xs
theorem₃<span class="w"> </span>[]<span class="w"> </span>h₁<span class="w"> </span><span class="ow">=</span><span class="w"> </span>Empty
theorem₃<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>[]<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="ow">=</span><span class="w"> </span>OneElem<span class="w"> </span>x
theorem₃<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="kr">with</span><span class="w"> </span><span class="o">(</span>theorem₃<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span><span class="o">(</span>helper₂<span class="w"> </span>x<span class="w"> </span><span class="o">(</span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="o">))</span><span class="w"> </span>
theorem₃<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="ow">|</span><span class="w"> </span>_<span class="w"> </span><span class="kr">with</span><span class="w"> </span><span class="o">(</span>x<span class="w"> </span>&lt;=<span class="w"> </span>x₁<span class="o">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span>h₂<span class="w"> </span>
theorem₃<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span>h₁<span class="w"> </span><span class="ow">|</span><span class="w"> </span>h₃<span class="w"> </span><span class="ow">|</span><span class="w"> </span>True<span class="w">  </span><span class="ow">=</span><span class="w"> </span>ManyElem<span class="w"> </span>x<span class="w"> </span>x₁<span class="w"> </span>xs<span class="w"> </span>
<span class="w">        </span>⦃<span class="w"> </span>h₃<span class="w"> </span>⦄<span class="w"> </span>⦃<span class="w"> </span>useEq<span class="w"> </span><span class="o">(</span><span class="w"> </span>sym<span class="w"> </span>$<span class="w"> </span>h₂<span class="w"> </span><span class="o">)</span><span class="w"> </span>IsTrue.itsTrue<span class="w"> </span>⦄
theorem₃<span class="w"> </span><span class="o">(</span>x<span class="w"> </span>∷<span class="w"> </span>x₁<span class="w"> </span>∷<span class="w"> </span>xs<span class="o">)</span><span class="w"> </span><span class="o">()</span><span class="w"> </span><span class="ow">|</span><span class="w"> </span>_<span class="w">  </span><span class="ow">|</span><span class="w"> </span>False<span class="w"> </span>
</pre></div>
</div>
<p>We need another helper function to obtain the correct hypothesis about the tail of the list, but thanks to this approach we can remove one of the assertions about the input values. On the other hand, we need to break up the single <code class="docutils literal notranslate"><span class="pre">with</span></code> assertion into two different lines - if both the new recursive hypothesis (<code class="docutils literal notranslate"><span class="pre">h₃</span></code>) and <code class="docutils literal notranslate"><span class="pre">h₂</span></code> were defined in the same step, Agda wouldn’t be able to implicitly apply <code class="docutils literal notranslate"><span class="pre">h₂</span></code> in the <code class="docutils literal notranslate"><span class="pre">h₁</span></code> hypothesis and reason about it being a contradiction in the last case. This way, we finally obtain a correct proof.</p>
<p>With these proofs, the differences between using these two different styles of describing properties of the code are clear, and some basic principles of building proofs were demonstrated.</p>
<p>From all the functions and data types discussed, only the first can be compiled into Haskell. The predicate type class and the proofs cannot be compiled as they use concepts that are not supported by Haskell or agda2hs. However, they shouldn’t be compiled; they should remain on the “Agda side” as the formal verification of the written code.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="features.html" class="btn btn-neutral float-left" title="Features" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Jexper Cockx, Orestis Melkonian, Lucas Escot, James Chapman, Ulf Norell.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
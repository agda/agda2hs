<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Haskell.Law.Eq.Instances</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="Haskell.Law.Eq.Instances.html" class="Module">Haskell.Law.Eq.Instances</a> <a id="33" class="Keyword">where</a>

<a id="40" class="Keyword">open</a> <a id="45" class="Keyword">import</a> <a id="52" href="Agda.Builtin.Char.Properties.html" class="Module">Agda.Builtin.Char.Properties</a> <a id="81" class="Keyword">renaming</a> <a id="90" class="Symbol">(</a><a id="91" href="Agda.Builtin.Char.Properties.html#218" class="Primitive">primCharToNatInjective</a> <a id="114" class="Symbol">to</a> <a id="117" class="Primitive">c2n-injective</a><a id="130" class="Symbol">)</a>
<a id="132" class="Keyword">open</a> <a id="137" class="Keyword">import</a> <a id="144" href="Agda.Builtin.Word.Properties.html" class="Module">Agda.Builtin.Word.Properties</a> <a id="173" class="Keyword">renaming</a> <a id="182" class="Symbol">(</a><a id="183" href="Agda.Builtin.Word.Properties.html#218" class="Primitive">primWord64ToNatInjective</a> <a id="208" class="Symbol">to</a> <a id="211" class="Primitive">w2n-injective</a><a id="224" class="Symbol">)</a>

<a id="227" class="Keyword">open</a> <a id="232" class="Keyword">import</a> <a id="239" href="Haskell.Prim.html" class="Module">Haskell.Prim</a>
<a id="252" class="Keyword">open</a> <a id="257" class="Keyword">import</a> <a id="264" href="Haskell.Prim.Eq.html" class="Module">Haskell.Prim.Eq</a>

<a id="281" class="Keyword">open</a> <a id="286" class="Keyword">import</a> <a id="293" href="Haskell.Prim.Either.html" class="Module">Haskell.Prim.Either</a> <a id="313" class="Keyword">using</a> <a id="319" class="Symbol">(</a> <a id="321" href="Haskell.Prim.Either.html#159" class="Datatype">Either</a><a id="327" class="Symbol">;</a> <a id="329" href="Haskell.Prim.Either.html#192" class="InductiveConstructor">Left</a><a id="333" class="Symbol">;</a> <a id="335" href="Haskell.Prim.Either.html#217" class="InductiveConstructor">Right</a> <a id="341" class="Symbol">)</a>
<a id="343" class="Keyword">open</a> <a id="348" class="Keyword">import</a> <a id="355" href="Haskell.Prim.Int.html" class="Module">Haskell.Prim.Int</a>    <a id="375" class="Keyword">using</a> <a id="381" class="Symbol">(</a> <a id="383" href="Haskell.Prim.Int.html#367" class="Datatype">Int</a><a id="386" class="Symbol">;</a> <a id="388" href="Haskell.Prim.Int.html#385" class="InductiveConstructor">int64</a> <a id="394" class="Symbol">)</a>
<a id="396" class="Keyword">open</a> <a id="401" class="Keyword">import</a> <a id="408" href="Haskell.Prim.Maybe.html" class="Module">Haskell.Prim.Maybe</a>
<a id="427" class="Keyword">open</a> <a id="432" class="Keyword">import</a> <a id="439" href="Haskell.Prim.Ord.html" class="Module">Haskell.Prim.Ord</a>    <a id="459" class="Keyword">using</a> <a id="465" class="Symbol">(</a> <a id="467" href="Haskell.Prim.Ord.html#466" class="Datatype">Ordering</a><a id="475" class="Symbol">;</a> <a id="477" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a><a id="479" class="Symbol">;</a> <a id="481" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a><a id="483" class="Symbol">;</a> <a id="485" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="488" class="Symbol">)</a>
<a id="490" class="Keyword">open</a> <a id="495" class="Keyword">import</a> <a id="502" href="Haskell.Prim.Tuple.html" class="Module">Haskell.Prim.Tuple</a>
<a id="521" class="Keyword">open</a> <a id="526" class="Keyword">import</a> <a id="533" href="Haskell.Prim.Word.html" class="Module">Haskell.Prim.Word</a>   <a id="553" class="Keyword">using</a> <a id="559" class="Symbol">(</a> <a id="561" href="Agda.Builtin.Word.html#208" class="Postulate">Word</a> <a id="566" class="Symbol">)</a>

<a id="569" class="Keyword">open</a> <a id="574" class="Keyword">import</a> <a id="581" href="Haskell.Extra.Dec.html" class="Module">Haskell.Extra.Dec</a>   <a id="601" class="Keyword">using</a> <a id="607" class="Symbol">(</a> <a id="609" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a> <a id="621" class="Symbol">)</a>

<a id="624" class="Keyword">open</a> <a id="629" class="Keyword">import</a> <a id="636" href="Haskell.Law.Eq.Def.html" class="Module">Haskell.Law.Eq.Def</a>
<a id="655" class="Keyword">open</a> <a id="660" class="Keyword">import</a> <a id="667" href="Haskell.Law.Equality.html" class="Module">Haskell.Law.Equality</a>

<a id="689" class="Keyword">open</a> <a id="694" class="Keyword">import</a> <a id="701" href="Haskell.Law.Either.html" class="Module">Haskell.Law.Either</a>
<a id="720" class="Keyword">open</a> <a id="725" class="Keyword">import</a> <a id="732" href="Haskell.Law.Int.html" class="Module">Haskell.Law.Int</a>
<a id="748" class="Keyword">open</a> <a id="753" class="Keyword">import</a> <a id="760" href="Haskell.Law.Integer.html" class="Module">Haskell.Law.Integer</a>
<a id="780" class="Keyword">open</a> <a id="785" class="Keyword">import</a> <a id="792" href="Haskell.Law.List.html" class="Module">Haskell.Law.List</a>    <a id="812" class="Keyword">using</a> <a id="818" class="Symbol">(</a> <a id="820" href="Haskell.Law.List.html#376" class="Function">∷-injective-left</a><a id="836" class="Symbol">;</a> <a id="838" href="Haskell.Law.List.html#453" class="Function">∷-injective-right</a> <a id="856" class="Symbol">)</a>
<a id="858" class="Keyword">open</a> <a id="863" class="Keyword">import</a> <a id="870" href="Haskell.Law.Maybe.html" class="Module">Haskell.Law.Maybe</a>
<a id="888" class="Keyword">open</a> <a id="893" class="Keyword">import</a> <a id="900" href="Haskell.Law.Nat.html" class="Module">Haskell.Law.Nat</a>

<a id="917" class="Keyword">instance</a>
  <a id="iLawfulEqNat"></a><a id="928" href="Haskell.Law.Eq.Instances.html#928" class="Function">iLawfulEqNat</a> <a id="941" class="Symbol">:</a> <a id="943" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="954" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a>
  <a id="960" href="Haskell.Law.Eq.Instances.html#928" class="Function">iLawfulEqNat</a> <a id="973" class="Symbol">.</a><a id="974" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="985" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="993" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="1001" class="Symbol">=</a> <a id="1003" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1010" href="Haskell.Law.Eq.Instances.html#928" class="Function">iLawfulEqNat</a> <a id="1023" class="Symbol">.</a><a id="1024" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1035" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="1043" class="Symbol">(</a><a id="1044" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1048" class="Symbol">_)</a> <a id="1051" class="Symbol">=</a> <a id="1053" class="Symbol">λ</a> <a id="1055" class="Symbol">()</a>
  <a id="1060" href="Haskell.Law.Eq.Instances.html#928" class="Function">iLawfulEqNat</a> <a id="1073" class="Symbol">.</a><a id="1074" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1085" class="Symbol">(</a><a id="1086" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1090" class="Symbol">_)</a> <a id="1093" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="1101" class="Symbol">=</a> <a id="1103" class="Symbol">λ</a> <a id="1105" class="Symbol">()</a>
  <a id="1110" href="Haskell.Law.Eq.Instances.html#928" class="Function">iLawfulEqNat</a> <a id="1123" class="Symbol">.</a><a id="1124" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1135" class="Symbol">(</a><a id="1136" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1140" href="Haskell.Law.Eq.Instances.html#1140" class="Bound">x</a><a id="1141" class="Symbol">)</a> <a id="1143" class="Symbol">(</a><a id="1144" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1148" href="Haskell.Law.Eq.Instances.html#1148" class="Bound">y</a><a id="1149" class="Symbol">)</a> <a id="1151" class="Symbol">=</a> <a id="1153" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a> 
    <a id="1170" class="Symbol">(</a><a id="1171" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="1176" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="1179" class="Symbol">)</a> 
    <a id="1186" href="Haskell.Law.Nat.html#86" class="Function">suc-injective</a> 
    <a id="1205" class="Symbol">(</a><a id="1206" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1217" href="Haskell.Law.Eq.Instances.html#1140" class="Bound">x</a> <a id="1219" href="Haskell.Law.Eq.Instances.html#1148" class="Bound">y</a><a id="1220" class="Symbol">)</a>

  <a id="iLawfulEqWord"></a><a id="1225" href="Haskell.Law.Eq.Instances.html#1225" class="Function">iLawfulEqWord</a> <a id="1239" class="Symbol">:</a> <a id="1241" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="1252" href="Agda.Builtin.Word.html#208" class="Postulate">Word</a>
  <a id="1259" href="Haskell.Law.Eq.Instances.html#1225" class="Function">iLawfulEqWord</a> <a id="1273" class="Symbol">.</a><a id="1274" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1285" href="Haskell.Law.Eq.Instances.html#1285" class="Bound">x</a> <a id="1287" href="Haskell.Law.Eq.Instances.html#1287" class="Bound">y</a> 
    <a id="1294" class="Keyword">with</a> <a id="1299" class="Symbol">(</a><a id="1300" href="Agda.Builtin.Word.html#264" class="Primitive">w2n</a> <a id="1304" href="Haskell.Law.Eq.Instances.html#1285" class="Bound">x</a><a id="1305" class="Symbol">)</a> <a id="1307" class="Keyword">in</a> <a id="1310" class="Argument">h₁</a> <a id="1313" class="Symbol">|</a> <a id="1315" class="Symbol">(</a><a id="1316" href="Agda.Builtin.Word.html#264" class="Primitive">w2n</a> <a id="1320" href="Haskell.Law.Eq.Instances.html#1287" class="Bound">y</a><a id="1321" class="Symbol">)</a> <a id="1323" class="Keyword">in</a> <a id="1326" class="Argument">h₂</a> 
  <a id="1332" class="Symbol">...</a> <a id="1336" class="Symbol">|</a> <a id="1338" href="Haskell.Law.Eq.Instances.html#1338" class="Bound">a</a> <a id="1340" class="Symbol">|</a> <a id="1342" href="Haskell.Law.Eq.Instances.html#1342" class="Bound">b</a>  <a id="1345" class="Symbol">=</a> <a id="1347" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a>
    <a id="1363" class="Symbol">(λ</a> <a id="1366" href="Haskell.Law.Eq.Instances.html#1366" class="Bound">h</a> <a id="1368" class="Symbol">→</a> <a id="1370" href="Haskell.Law.Eq.Instances.html#211" class="Primitive">w2n-injective</a> <a id="1384" class="Bound">x</a> <a id="1386" class="Bound">y</a> <a id="1388" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="1390" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="1394" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="1396" href="Haskell.Law.Equality.html#462" class="Function">trans</a> <a id="1402" class="Symbol">(</a><a id="1403" href="Haskell.Law.Equality.html#462" class="Function">trans</a> <a id="1409" href="Haskell.Law.Eq.Instances.html#1326" class="Bound">h₂</a> <a id="1412" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="1414" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="1418" href="Haskell.Law.Eq.Instances.html#1366" class="Bound">h</a><a id="1419" class="Symbol">)</a> <a id="1421" class="Symbol">(</a><a id="1422" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="1426" href="Haskell.Law.Eq.Instances.html#1310" class="Bound">h₁</a><a id="1428" class="Symbol">))</a>
    <a id="1435" class="Symbol">(λ</a> <a id="1438" href="Haskell.Law.Eq.Instances.html#1438" class="Bound">h</a> <a id="1440" class="Symbol">→</a> <a id="1442" href="Haskell.Law.Equality.html#462" class="Function">trans</a> <a id="1448" class="Symbol">(</a><a id="1449" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="1453" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="1455" href="Haskell.Law.Equality.html#462" class="Function">trans</a> <a id="1461" class="Symbol">(</a><a id="1462" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="1467" href="Agda.Builtin.Word.html#264" class="Primitive">w2n</a> <a id="1471" class="Symbol">(</a><a id="1472" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="1476" href="Haskell.Law.Eq.Instances.html#1438" class="Bound">h</a><a id="1477" class="Symbol">))</a> <a id="1480" href="Haskell.Law.Eq.Instances.html#1310" class="Bound">h₁</a><a id="1482" class="Symbol">)</a> <a id="1484" href="Haskell.Law.Eq.Instances.html#1326" class="Bound">h₂</a><a id="1486" class="Symbol">)</a>
    <a id="1492" class="Symbol">(</a><a id="1493" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1504" href="Haskell.Law.Eq.Instances.html#1338" class="Bound">a</a> <a id="1506" href="Haskell.Law.Eq.Instances.html#1342" class="Bound">b</a><a id="1507" class="Symbol">)</a>

  <a id="iLawfulEqBool"></a><a id="1512" href="Haskell.Law.Eq.Instances.html#1512" class="Function">iLawfulEqBool</a> <a id="1526" class="Symbol">:</a> <a id="1528" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="1539" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
  <a id="1546" href="Haskell.Law.Eq.Instances.html#1512" class="Function">iLawfulEqBool</a> <a id="1560" class="Symbol">.</a><a id="1561" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1572" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="1578" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="1584" class="Symbol">=</a> <a id="1586" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1593" href="Haskell.Law.Eq.Instances.html#1512" class="Function">iLawfulEqBool</a> <a id="1607" class="Symbol">.</a><a id="1608" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1619" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="1625" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="1631" class="Symbol">=</a> <a id="1633" class="Symbol">λ()</a>
  <a id="1639" href="Haskell.Law.Eq.Instances.html#1512" class="Function">iLawfulEqBool</a> <a id="1653" class="Symbol">.</a><a id="1654" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1665" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="1671" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="1677" class="Symbol">=</a> <a id="1679" class="Symbol">λ()</a>
  <a id="1685" href="Haskell.Law.Eq.Instances.html#1512" class="Function">iLawfulEqBool</a> <a id="1699" class="Symbol">.</a><a id="1700" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1711" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="1717" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="1723" class="Symbol">=</a> <a id="1725" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="iLawfulEqChar"></a><a id="1733" href="Haskell.Law.Eq.Instances.html#1733" class="Function">iLawfulEqChar</a> <a id="1747" class="Symbol">:</a> <a id="1749" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="1760" href="Agda.Builtin.Char.html#238" class="Postulate">Char</a>
  <a id="1767" href="Haskell.Law.Eq.Instances.html#1733" class="Function">iLawfulEqChar</a> <a id="1781" class="Symbol">.</a><a id="1782" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="1793" href="Haskell.Law.Eq.Instances.html#1793" class="Bound">x</a> <a id="1795" href="Haskell.Law.Eq.Instances.html#1795" class="Bound">y</a> 
    <a id="1802" class="Keyword">with</a> <a id="1807" class="Symbol">(</a><a id="1808" href="Agda.Builtin.Char.html#448" class="Primitive">c2n</a> <a id="1812" href="Haskell.Law.Eq.Instances.html#1793" class="Bound">x</a><a id="1813" class="Symbol">)</a> <a id="1815" class="Keyword">in</a> <a id="1818" class="Argument">h₁</a> <a id="1821" class="Symbol">|</a> <a id="1823" class="Symbol">(</a><a id="1824" href="Agda.Builtin.Char.html#448" class="Primitive">c2n</a> <a id="1828" href="Haskell.Law.Eq.Instances.html#1795" class="Bound">y</a><a id="1829" class="Symbol">)</a> <a id="1831" class="Keyword">in</a> <a id="1834" class="Argument">h₂</a> 
  <a id="1840" class="Symbol">...</a> <a id="1844" class="Symbol">|</a> <a id="1846" href="Haskell.Law.Eq.Instances.html#1846" class="Bound">a</a> <a id="1848" class="Symbol">|</a> <a id="1850" href="Haskell.Law.Eq.Instances.html#1850" class="Bound">b</a>  <a id="1853" class="Symbol">=</a> <a id="1855" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a> <a id="1867" class="Symbol">{</a> <a id="1869" href="Haskell.Law.Eq.Instances.html#1846" class="Bound">a</a> <a id="1871" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1873" href="Haskell.Law.Eq.Instances.html#1850" class="Bound">b</a> <a id="1875" class="Symbol">}</a> <a id="1877" class="Symbol">{</a> <a id="1879" class="Bound">x</a> <a id="1881" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1883" class="Bound">y</a> <a id="1885" class="Symbol">}</a> <a id="1887" class="Symbol">{</a> <a id="1889" href="Agda.Builtin.Nat.html#631" class="Primitive">eqNat</a> <a id="1895" href="Haskell.Law.Eq.Instances.html#1846" class="Bound">a</a> <a id="1897" href="Haskell.Law.Eq.Instances.html#1850" class="Bound">b</a> <a id="1899" class="Symbol">}</a> 
    <a id="1906" class="Symbol">(λ</a> <a id="1909" href="Haskell.Law.Eq.Instances.html#1909" class="Bound">h</a> <a id="1911" class="Symbol">→</a> <a id="1913" href="Haskell.Law.Eq.Instances.html#117" class="Primitive">c2n-injective</a> <a id="1927" class="Bound">x</a> <a id="1929" class="Bound">y</a> <a id="1931" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="1933" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="1937" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="1939" href="Haskell.Law.Equality.html#462" class="Function">trans</a> <a id="1945" class="Symbol">(</a><a id="1946" href="Haskell.Law.Equality.html#462" class="Function">trans</a> <a id="1952" href="Haskell.Law.Eq.Instances.html#1834" class="Bound">h₂</a> <a id="1955" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="1957" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="1961" href="Haskell.Law.Eq.Instances.html#1909" class="Bound">h</a><a id="1962" class="Symbol">)</a> <a id="1964" class="Symbol">(</a><a id="1965" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="1969" href="Haskell.Law.Eq.Instances.html#1818" class="Bound">h₁</a><a id="1971" class="Symbol">))</a>
    <a id="1978" class="Symbol">(λ</a> <a id="1981" href="Haskell.Law.Eq.Instances.html#1981" class="Bound">h</a> <a id="1983" class="Symbol">→</a> <a id="1985" href="Haskell.Law.Equality.html#462" class="Function">trans</a> <a id="1991" class="Symbol">(</a><a id="1992" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="1996" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="1998" href="Haskell.Law.Equality.html#462" class="Function">trans</a> <a id="2004" class="Symbol">(</a><a id="2005" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="2010" href="Agda.Builtin.Char.html#448" class="Primitive">c2n</a> <a id="2014" class="Symbol">(</a><a id="2015" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="2019" href="Haskell.Law.Eq.Instances.html#1981" class="Bound">h</a><a id="2020" class="Symbol">))</a> <a id="2023" href="Haskell.Law.Eq.Instances.html#1818" class="Bound">h₁</a><a id="2025" class="Symbol">)</a> <a id="2027" href="Haskell.Law.Eq.Instances.html#1834" class="Bound">h₂</a><a id="2029" class="Symbol">)</a>
    <a id="2035" class="Symbol">(</a><a id="2036" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2047" href="Haskell.Law.Eq.Instances.html#1846" class="Bound">a</a> <a id="2049" href="Haskell.Law.Eq.Instances.html#1850" class="Bound">b</a><a id="2050" class="Symbol">)</a>

  <a id="iLawfulEqEither"></a><a id="2055" href="Haskell.Law.Eq.Instances.html#2055" class="Function">iLawfulEqEither</a> <a id="2071" class="Symbol">:</a> <a id="2073" class="Symbol">⦃</a> <a id="2075" href="Haskell.Law.Eq.Instances.html#2075" class="Bound">iEqA</a> <a id="2080" class="Symbol">:</a> <a id="2082" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="2085" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="2087" class="Symbol">⦄</a> <a id="2089" class="Symbol">→</a> <a id="2091" class="Symbol">⦃</a> <a id="2093" href="Haskell.Law.Eq.Instances.html#2093" class="Bound">iEqB</a> <a id="2098" class="Symbol">:</a> <a id="2100" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="2103" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="2105" class="Symbol">⦄</a> 
    <a id="2112" class="Symbol">→</a> <a id="2114" class="Symbol">⦃</a> <a id="2116" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="2127" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="2129" class="Symbol">⦄</a> <a id="2131" class="Symbol">→</a> <a id="2133" class="Symbol">⦃</a> <a id="2135" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="2146" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="2148" class="Symbol">⦄</a> 
    <a id="2155" class="Symbol">→</a> <a id="2157" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="2168" class="Symbol">(</a><a id="2169" href="Haskell.Prim.Either.html#159" class="Datatype">Either</a> <a id="2176" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="2178" href="Haskell.Prim.html#1193" class="Generalizable">b</a><a id="2179" class="Symbol">)</a>
  <a id="2183" href="Haskell.Law.Eq.Instances.html#2055" class="Function">iLawfulEqEither</a> <a id="2199" class="Symbol">.</a><a id="2200" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2211" class="Symbol">(</a><a id="2212" href="Haskell.Prim.Either.html#192" class="InductiveConstructor">Left</a>  <a id="2218" class="Symbol">_)</a> <a id="2221" class="Symbol">(</a><a id="2222" href="Haskell.Prim.Either.html#217" class="InductiveConstructor">Right</a> <a id="2228" class="Symbol">_)</a> <a id="2231" class="Symbol">=</a> <a id="2233" class="Symbol">λ</a> <a id="2235" class="Symbol">()</a>
  <a id="2240" href="Haskell.Law.Eq.Instances.html#2055" class="Function">iLawfulEqEither</a> <a id="2256" class="Symbol">.</a><a id="2257" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2268" class="Symbol">(</a><a id="2269" href="Haskell.Prim.Either.html#217" class="InductiveConstructor">Right</a> <a id="2275" class="Symbol">_)</a> <a id="2278" class="Symbol">(</a><a id="2279" href="Haskell.Prim.Either.html#192" class="InductiveConstructor">Left</a>  <a id="2285" class="Symbol">_)</a> <a id="2288" class="Symbol">=</a> <a id="2290" class="Symbol">λ</a> <a id="2292" class="Symbol">()</a>
  <a id="2297" href="Haskell.Law.Eq.Instances.html#2055" class="Function">iLawfulEqEither</a> <a id="2313" class="Symbol">.</a><a id="2314" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2325" class="Symbol">(</a><a id="2326" href="Haskell.Prim.Either.html#192" class="InductiveConstructor">Left</a>  <a id="2332" href="Haskell.Law.Eq.Instances.html#2332" class="Bound">x</a><a id="2333" class="Symbol">)</a> <a id="2335" class="Symbol">(</a><a id="2336" href="Haskell.Prim.Either.html#192" class="InductiveConstructor">Left</a>  <a id="2342" href="Haskell.Law.Eq.Instances.html#2342" class="Bound">y</a><a id="2343" class="Symbol">)</a> <a id="2345" class="Symbol">=</a> <a id="2347" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a> 
    <a id="2364" class="Symbol">(</a><a id="2365" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="2370" href="Haskell.Prim.Either.html#192" class="InductiveConstructor">Left</a><a id="2374" class="Symbol">)</a> <a id="2376" class="Symbol">(</a><a id="2377" href="Haskell.Law.Either.html#121" class="Function">Left-injective</a><a id="2391" class="Symbol">)</a> <a id="2393" class="Symbol">(</a><a id="2394" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2405" href="Haskell.Law.Eq.Instances.html#2332" class="Bound">x</a> <a id="2407" href="Haskell.Law.Eq.Instances.html#2342" class="Bound">y</a><a id="2408" class="Symbol">)</a>
  <a id="2412" href="Haskell.Law.Eq.Instances.html#2055" class="Function">iLawfulEqEither</a> <a id="2428" class="Symbol">.</a><a id="2429" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2440" class="Symbol">(</a><a id="2441" href="Haskell.Prim.Either.html#217" class="InductiveConstructor">Right</a> <a id="2447" href="Haskell.Law.Eq.Instances.html#2447" class="Bound">x</a><a id="2448" class="Symbol">)</a> <a id="2450" class="Symbol">(</a><a id="2451" href="Haskell.Prim.Either.html#217" class="InductiveConstructor">Right</a> <a id="2457" href="Haskell.Law.Eq.Instances.html#2457" class="Bound">y</a><a id="2458" class="Symbol">)</a> <a id="2460" class="Symbol">=</a> <a id="2462" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a> 
    <a id="2479" class="Symbol">(</a><a id="2480" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="2485" href="Haskell.Prim.Either.html#217" class="InductiveConstructor">Right</a><a id="2490" class="Symbol">)</a> <a id="2492" class="Symbol">(</a><a id="2493" href="Haskell.Law.Either.html#190" class="Function">Right-injective</a><a id="2508" class="Symbol">)</a> <a id="2510" class="Symbol">(</a><a id="2511" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2522" href="Haskell.Law.Eq.Instances.html#2447" class="Bound">x</a> <a id="2524" href="Haskell.Law.Eq.Instances.html#2457" class="Bound">y</a><a id="2525" class="Symbol">)</a>

  <a id="iLawfulEqInt"></a><a id="2530" href="Haskell.Law.Eq.Instances.html#2530" class="Function">iLawfulEqInt</a> <a id="2543" class="Symbol">:</a> <a id="2545" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="2556" href="Haskell.Prim.Int.html#367" class="Datatype">Int</a>
  <a id="2562" href="Haskell.Law.Eq.Instances.html#2530" class="Function">iLawfulEqInt</a> <a id="2575" class="Symbol">.</a><a id="2576" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2587" class="Symbol">(</a><a id="2588" href="Haskell.Prim.Int.html#385" class="InductiveConstructor">int64</a> <a id="2594" href="Haskell.Law.Eq.Instances.html#2594" class="Bound">x</a><a id="2595" class="Symbol">)</a> <a id="2597" class="Symbol">(</a><a id="2598" href="Haskell.Prim.Int.html#385" class="InductiveConstructor">int64</a> <a id="2604" href="Haskell.Law.Eq.Instances.html#2604" class="Bound">y</a><a id="2605" class="Symbol">)</a> <a id="2607" class="Symbol">=</a> <a id="2609" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a>
    <a id="2625" class="Symbol">(</a><a id="2626" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="2631" href="Haskell.Prim.Int.html#385" class="InductiveConstructor">int64</a><a id="2636" class="Symbol">)</a> <a id="2638" href="Haskell.Law.Int.html#131" class="Function">int64-injective</a> <a id="2654" class="Symbol">(</a><a id="2655" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2666" href="Haskell.Law.Eq.Instances.html#2594" class="Bound">x</a> <a id="2668" href="Haskell.Law.Eq.Instances.html#2604" class="Bound">y</a><a id="2669" class="Symbol">)</a> 

  <a id="iLawfulEqInteger"></a><a id="2675" href="Haskell.Law.Eq.Instances.html#2675" class="Function">iLawfulEqInteger</a> <a id="2692" class="Symbol">:</a> <a id="2694" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="2705" href="Agda.Builtin.Int.html#245" class="Datatype">Integer</a>
  <a id="2715" href="Haskell.Law.Eq.Instances.html#2675" class="Function">iLawfulEqInteger</a> <a id="2732" class="Symbol">.</a><a id="2733" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2744" class="Symbol">(</a><a id="2745" href="Agda.Builtin.Int.html#263" class="InductiveConstructor">pos</a> <a id="2749" href="Haskell.Law.Eq.Instances.html#2749" class="Bound">n</a><a id="2750" class="Symbol">)</a>    <a id="2755" class="Symbol">(</a><a id="2756" href="Agda.Builtin.Int.html#263" class="InductiveConstructor">pos</a> <a id="2760" href="Haskell.Law.Eq.Instances.html#2760" class="Bound">m</a><a id="2761" class="Symbol">)</a>    <a id="2766" class="Symbol">=</a> <a id="2768" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a> 
    <a id="2785" class="Symbol">(</a><a id="2786" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="2791" href="Agda.Builtin.Int.html#263" class="InductiveConstructor">pos</a><a id="2794" class="Symbol">)</a> <a id="2796" href="Haskell.Law.Integer.html#90" class="Function">pos-injective</a> <a id="2810" class="Symbol">(</a><a id="2811" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2822" href="Haskell.Law.Eq.Instances.html#2749" class="Bound">n</a> <a id="2824" href="Haskell.Law.Eq.Instances.html#2760" class="Bound">m</a><a id="2825" class="Symbol">)</a>
  <a id="2829" href="Haskell.Law.Eq.Instances.html#2675" class="Function">iLawfulEqInteger</a> <a id="2846" class="Symbol">.</a><a id="2847" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2858" class="Symbol">(</a><a id="2859" href="Agda.Builtin.Int.html#263" class="InductiveConstructor">pos</a> <a id="2863" class="Symbol">_)</a>    <a id="2869" class="Symbol">(</a><a id="2870" href="Agda.Builtin.Int.html#290" class="InductiveConstructor">negsuc</a> <a id="2877" class="Symbol">_)</a> <a id="2880" class="Symbol">=</a> <a id="2882" class="Symbol">λ</a> <a id="2884" class="Symbol">()</a> 
  <a id="2890" href="Haskell.Law.Eq.Instances.html#2675" class="Function">iLawfulEqInteger</a> <a id="2907" class="Symbol">.</a><a id="2908" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2919" class="Symbol">(</a><a id="2920" href="Agda.Builtin.Int.html#290" class="InductiveConstructor">negsuc</a> <a id="2927" class="Symbol">_)</a> <a id="2930" class="Symbol">(</a><a id="2931" href="Agda.Builtin.Int.html#263" class="InductiveConstructor">pos</a> <a id="2935" class="Symbol">_)</a>    <a id="2941" class="Symbol">=</a> <a id="2943" class="Symbol">λ</a> <a id="2945" class="Symbol">()</a>
  <a id="2950" href="Haskell.Law.Eq.Instances.html#2675" class="Function">iLawfulEqInteger</a> <a id="2967" class="Symbol">.</a><a id="2968" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="2979" class="Symbol">(</a><a id="2980" href="Agda.Builtin.Int.html#290" class="InductiveConstructor">negsuc</a> <a id="2987" href="Haskell.Law.Eq.Instances.html#2987" class="Bound">n</a><a id="2988" class="Symbol">)</a> <a id="2990" class="Symbol">(</a><a id="2991" href="Agda.Builtin.Int.html#290" class="InductiveConstructor">negsuc</a> <a id="2998" href="Haskell.Law.Eq.Instances.html#2998" class="Bound">m</a><a id="2999" class="Symbol">)</a> <a id="3001" class="Symbol">=</a> <a id="3003" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a> 
    <a id="3020" class="Symbol">(</a><a id="3021" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="3026" href="Agda.Builtin.Int.html#290" class="InductiveConstructor">negsuc</a><a id="3032" class="Symbol">)</a> <a id="3034" href="Haskell.Law.Integer.html#147" class="Function">neg-injective</a> <a id="3048" class="Symbol">(</a><a id="3049" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3060" href="Haskell.Law.Eq.Instances.html#2987" class="Bound">n</a> <a id="3062" href="Haskell.Law.Eq.Instances.html#2998" class="Bound">m</a><a id="3063" class="Symbol">)</a>
  
  <a id="iLawfulEqList"></a><a id="3070" href="Haskell.Law.Eq.Instances.html#3070" class="Function">iLawfulEqList</a> <a id="3084" class="Symbol">:</a> <a id="3086" class="Symbol">⦃</a> <a id="3088" href="Haskell.Law.Eq.Instances.html#3088" class="Bound">iEqA</a> <a id="3093" class="Symbol">:</a> <a id="3095" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="3098" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3100" class="Symbol">⦄</a> <a id="3102" class="Symbol">→</a> <a id="3104" class="Symbol">⦃</a> <a id="3106" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="3117" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3119" class="Symbol">⦄</a> <a id="3121" class="Symbol">→</a> <a id="3123" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="3134" class="Symbol">(</a><a id="3135" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3140" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3141" class="Symbol">)</a>
  <a id="3145" href="Haskell.Law.Eq.Instances.html#3070" class="Function">iLawfulEqList</a> <a id="3159" class="Symbol">.</a><a id="3160" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3171" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>       <a id="3180" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>      <a id="3188" class="Symbol">=</a> <a id="3190" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="3197" href="Haskell.Law.Eq.Instances.html#3070" class="Function">iLawfulEqList</a> <a id="3211" class="Symbol">.</a><a id="3212" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3223" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>       <a id="3232" class="Symbol">(_</a> <a id="3235" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3237" class="Symbol">_)</a> <a id="3240" class="Symbol">=</a> <a id="3242" class="Symbol">λ</a> <a id="3244" class="Symbol">()</a>
  <a id="3249" href="Haskell.Law.Eq.Instances.html#3070" class="Function">iLawfulEqList</a> <a id="3263" class="Symbol">.</a><a id="3264" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3275" class="Symbol">(_</a> <a id="3278" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3280" class="Symbol">_)</a>  <a id="3284" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>      <a id="3292" class="Symbol">=</a> <a id="3294" class="Symbol">λ</a> <a id="3296" class="Symbol">()</a>
  <a id="3301" href="Haskell.Law.Eq.Instances.html#3070" class="Function">iLawfulEqList</a> <a id="3315" class="Symbol">.</a><a id="3316" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3327" class="Symbol">(</a><a id="3328" href="Haskell.Law.Eq.Instances.html#3328" class="Bound">x</a> <a id="3330" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3332" href="Haskell.Law.Eq.Instances.html#3332" class="Bound">xs</a><a id="3334" class="Symbol">)</a> <a id="3336" class="Symbol">(</a><a id="3337" href="Haskell.Law.Eq.Instances.html#3337" class="Bound">y</a> <a id="3339" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="3341" href="Haskell.Law.Eq.Instances.html#3341" class="Bound">ys</a><a id="3343" class="Symbol">)</a> 
    <a id="3350" class="Keyword">with</a> <a id="3355" class="Symbol">(</a><a id="3356" href="Haskell.Law.Eq.Instances.html#3328" class="Bound">x</a> <a id="3358" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="3361" href="Haskell.Law.Eq.Instances.html#3337" class="Bound">y</a><a id="3362" class="Symbol">)</a> <a id="3364" class="Keyword">in</a> <a id="3367" class="Argument">h₁</a>
  <a id="3372" class="Symbol">...</a> <a id="3376" class="Symbol">|</a> <a id="3378" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="3384" class="Symbol">=</a> <a id="3386" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a> 
    <a id="3403" class="Symbol">(λ</a> <a id="3406" href="Haskell.Law.Eq.Instances.html#3406" class="Bound">h</a> <a id="3408" class="Symbol">→</a> <a id="3410" href="Haskell.Law.Equality.html#307" class="Function">cong₂</a> <a id="3416" class="Symbol">(</a><a id="3417" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="3420" class="Symbol">)</a> <a id="3422" class="Symbol">(</a><a id="3423" href="Haskell.Law.Eq.Def.html#369" class="Function">equality</a> <a id="3432" class="Bound">x</a> <a id="3434" class="Bound">y</a> <a id="3436" href="Haskell.Law.Eq.Instances.html#3367" class="Bound">h₁</a><a id="3438" class="Symbol">)</a>  <a id="3441" href="Haskell.Law.Eq.Instances.html#3406" class="Bound">h</a><a id="3442" class="Symbol">)</a> 
    <a id="3449" href="Haskell.Law.List.html#453" class="Function">∷-injective-right</a> 
    <a id="3472" class="Symbol">(</a><a id="3473" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3484" class="Bound">xs</a> <a id="3487" class="Bound">ys</a><a id="3489" class="Symbol">)</a>
  <a id="3493" class="Symbol">...</a> <a id="3497" class="Symbol">|</a> <a id="3499" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="3505" class="Symbol">=</a> <a id="3507" class="Symbol">λ</a> <a id="3509" href="Haskell.Law.Eq.Instances.html#3509" class="Bound">h</a> <a id="3511" class="Symbol">→</a> <a id="3513" class="Symbol">(</a><a id="3514" href="Haskell.Law.Eq.Def.html#475" class="Function">nequality</a> <a id="3524" class="Bound">x</a> <a id="3526" class="Bound">y</a> <a id="3528" href="Haskell.Law.Eq.Instances.html#3367" class="Bound">h₁</a><a id="3530" class="Symbol">)</a> <a id="3532" class="Symbol">(</a><a id="3533" href="Haskell.Law.List.html#376" class="Function">∷-injective-left</a> <a id="3550" href="Haskell.Law.Eq.Instances.html#3509" class="Bound">h</a><a id="3551" class="Symbol">)</a>

  <a id="iLawfulEqMaybe"></a><a id="3556" href="Haskell.Law.Eq.Instances.html#3556" class="Function">iLawfulEqMaybe</a> <a id="3571" class="Symbol">:</a> <a id="3573" class="Symbol">⦃</a> <a id="3575" href="Haskell.Law.Eq.Instances.html#3575" class="Bound">iEqA</a> <a id="3580" class="Symbol">:</a> <a id="3582" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="3585" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3587" class="Symbol">⦄</a> <a id="3589" class="Symbol">→</a> <a id="3591" class="Symbol">⦃</a> <a id="3593" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="3604" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3606" class="Symbol">⦄</a> <a id="3608" class="Symbol">→</a> <a id="3610" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="3621" class="Symbol">(</a><a id="3622" href="Haskell.Prim.Maybe.html#101" class="Datatype">Maybe</a> <a id="3628" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3629" class="Symbol">)</a>
  <a id="3633" href="Haskell.Law.Eq.Instances.html#3556" class="Function">iLawfulEqMaybe</a> <a id="3648" class="Symbol">.</a><a id="3649" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3660" href="Haskell.Prim.Maybe.html#142" class="InductiveConstructor">Nothing</a>  <a id="3669" href="Haskell.Prim.Maybe.html#142" class="InductiveConstructor">Nothing</a>  <a id="3678" class="Symbol">=</a> <a id="3680" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="3687" href="Haskell.Law.Eq.Instances.html#3556" class="Function">iLawfulEqMaybe</a> <a id="3702" class="Symbol">.</a><a id="3703" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3714" href="Haskell.Prim.Maybe.html#142" class="InductiveConstructor">Nothing</a>  <a id="3723" class="Symbol">(</a><a id="3724" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a> <a id="3729" class="Symbol">_)</a> <a id="3732" class="Symbol">=</a> <a id="3734" class="Symbol">λ()</a>
  <a id="3740" href="Haskell.Law.Eq.Instances.html#3556" class="Function">iLawfulEqMaybe</a> <a id="3755" class="Symbol">.</a><a id="3756" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3767" class="Symbol">(</a><a id="3768" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a> <a id="3773" class="Symbol">_)</a> <a id="3776" href="Haskell.Prim.Maybe.html#142" class="InductiveConstructor">Nothing</a>  <a id="3785" class="Symbol">=</a> <a id="3787" class="Symbol">λ()</a>
  <a id="3793" href="Haskell.Law.Eq.Instances.html#3556" class="Function">iLawfulEqMaybe</a> <a id="3808" class="Symbol">.</a><a id="3809" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3820" class="Symbol">(</a><a id="3821" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a> <a id="3826" href="Haskell.Law.Eq.Instances.html#3826" class="Bound">x</a><a id="3827" class="Symbol">)</a> <a id="3829" class="Symbol">(</a><a id="3830" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a> <a id="3835" href="Haskell.Law.Eq.Instances.html#3835" class="Bound">y</a><a id="3836" class="Symbol">)</a> <a id="3838" class="Symbol">=</a> <a id="3840" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a> 
    <a id="3857" class="Symbol">(</a><a id="3858" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="3863" href="Haskell.Prim.Maybe.html#162" class="InductiveConstructor">Just</a><a id="3867" class="Symbol">)</a> <a id="3869" href="Haskell.Law.Maybe.html#119" class="Function">Just-injective</a> <a id="3884" class="Symbol">(</a><a id="3885" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3896" href="Haskell.Law.Eq.Instances.html#3826" class="Bound">x</a> <a id="3898" href="Haskell.Law.Eq.Instances.html#3835" class="Bound">y</a><a id="3899" class="Symbol">)</a>

  <a id="iLawfulEqOrdering"></a><a id="3904" href="Haskell.Law.Eq.Instances.html#3904" class="Function">iLawfulEqOrdering</a> <a id="3922" class="Symbol">:</a> <a id="3924" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="3935" href="Haskell.Prim.Ord.html#466" class="Datatype">Ordering</a>
  <a id="3946" href="Haskell.Law.Eq.Instances.html#3904" class="Function">iLawfulEqOrdering</a> <a id="3964" class="Symbol">.</a><a id="3965" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="3976" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a> <a id="3979" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a> <a id="3982" class="Symbol">=</a> <a id="3984" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="3991" href="Haskell.Law.Eq.Instances.html#3904" class="Function">iLawfulEqOrdering</a> <a id="4009" class="Symbol">.</a><a id="4010" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4021" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a> <a id="4024" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="4027" class="Symbol">=</a> <a id="4029" class="Symbol">λ()</a>
  <a id="4035" href="Haskell.Law.Eq.Instances.html#3904" class="Function">iLawfulEqOrdering</a> <a id="4053" class="Symbol">.</a><a id="4054" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4065" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a> <a id="4068" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a> <a id="4071" class="Symbol">=</a> <a id="4073" class="Symbol">λ()</a>
  <a id="4079" href="Haskell.Law.Eq.Instances.html#3904" class="Function">iLawfulEqOrdering</a> <a id="4097" class="Symbol">.</a><a id="4098" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4109" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="4112" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a> <a id="4115" class="Symbol">=</a> <a id="4117" class="Symbol">λ()</a>
  <a id="4123" href="Haskell.Law.Eq.Instances.html#3904" class="Function">iLawfulEqOrdering</a> <a id="4141" class="Symbol">.</a><a id="4142" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4153" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="4156" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="4159" class="Symbol">=</a> <a id="4161" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="4168" href="Haskell.Law.Eq.Instances.html#3904" class="Function">iLawfulEqOrdering</a> <a id="4186" class="Symbol">.</a><a id="4187" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4198" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="4201" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a> <a id="4204" class="Symbol">=</a> <a id="4206" class="Symbol">λ()</a>
  <a id="4212" href="Haskell.Law.Eq.Instances.html#3904" class="Function">iLawfulEqOrdering</a> <a id="4230" class="Symbol">.</a><a id="4231" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4242" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a> <a id="4245" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a> <a id="4248" class="Symbol">=</a> <a id="4250" class="Symbol">λ()</a>
  <a id="4256" href="Haskell.Law.Eq.Instances.html#3904" class="Function">iLawfulEqOrdering</a> <a id="4274" class="Symbol">.</a><a id="4275" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4286" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a> <a id="4289" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="4292" class="Symbol">=</a> <a id="4294" class="Symbol">λ()</a>
  <a id="4300" href="Haskell.Law.Eq.Instances.html#3904" class="Function">iLawfulEqOrdering</a> <a id="4318" class="Symbol">.</a><a id="4319" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4330" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a> <a id="4333" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a> <a id="4336" class="Symbol">=</a> <a id="4338" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="iLawfulEqTuple₂"></a><a id="4346" href="Haskell.Law.Eq.Instances.html#4346" class="Function">iLawfulEqTuple₂</a> <a id="4362" class="Symbol">:</a> <a id="4364" class="Symbol">⦃</a> <a id="4366" href="Haskell.Law.Eq.Instances.html#4366" class="Bound">iEqA</a> <a id="4371" class="Symbol">:</a> <a id="4373" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="4376" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4378" class="Symbol">⦄</a> <a id="4380" class="Symbol">⦃</a> <a id="4382" href="Haskell.Law.Eq.Instances.html#4382" class="Bound">iEqB</a> <a id="4387" class="Symbol">:</a> <a id="4389" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="4392" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="4394" class="Symbol">⦄</a>
    <a id="4400" class="Symbol">→</a> <a id="4402" class="Symbol">⦃</a> <a id="4404" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="4415" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4417" class="Symbol">⦄</a> <a id="4419" class="Symbol">→</a> <a id="4421" class="Symbol">⦃</a> <a id="4423" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="4434" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="4436" class="Symbol">⦄</a>
    <a id="4442" class="Symbol">→</a> <a id="4444" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="4455" class="Symbol">(</a><a id="4456" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4458" href="Haskell.Prim.Tuple.html#169" class="Record Operator">×</a> <a id="4460" href="Haskell.Prim.html#1193" class="Generalizable">b</a><a id="4461" class="Symbol">)</a>
  <a id="4465" href="Haskell.Law.Eq.Instances.html#4346" class="Function">iLawfulEqTuple₂</a> <a id="4481" class="Symbol">.</a><a id="4482" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4493" class="Symbol">(</a><a id="4494" href="Haskell.Law.Eq.Instances.html#4494" class="Bound">x₁</a> <a id="4497" href="Haskell.Prim.Tuple.html#211" class="InductiveConstructor Operator">,</a> <a id="4499" href="Haskell.Law.Eq.Instances.html#4499" class="Bound">x₂</a><a id="4501" class="Symbol">)</a> <a id="4503" class="Symbol">(</a><a id="4504" href="Haskell.Law.Eq.Instances.html#4504" class="Bound">y₁</a> <a id="4507" href="Haskell.Prim.Tuple.html#211" class="InductiveConstructor Operator">,</a> <a id="4509" href="Haskell.Law.Eq.Instances.html#4509" class="Bound">y₂</a><a id="4511" class="Symbol">)</a>
    <a id="4517" class="Keyword">with</a> <a id="4522" class="Symbol">(</a><a id="4523" href="Haskell.Law.Eq.Instances.html#4494" class="Bound">x₁</a> <a id="4526" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="4529" href="Haskell.Law.Eq.Instances.html#4504" class="Bound">y₁</a><a id="4531" class="Symbol">)</a> <a id="4533" class="Keyword">in</a> <a id="4536" class="Argument">h₁</a>
  <a id="4541" class="Symbol">...</a> <a id="4545" class="Symbol">|</a> <a id="4547" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="4553" class="Symbol">=</a> <a id="4555" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a>
    <a id="4571" class="Symbol">(λ</a> <a id="4574" href="Haskell.Law.Eq.Instances.html#4574" class="Bound">h</a> <a id="4576" class="Symbol">→</a> <a id="4578" href="Haskell.Law.Equality.html#307" class="Function">cong₂</a> <a id="4584" href="Haskell.Prim.Tuple.html#211" class="InductiveConstructor Operator">_,_</a> <a id="4588" class="Symbol">(</a><a id="4589" href="Haskell.Law.Eq.Def.html#369" class="Function">equality</a> <a id="4598" class="Bound">x₁</a> <a id="4601" class="Bound">y₁</a> <a id="4604" href="Haskell.Law.Eq.Instances.html#4536" class="Bound">h₁</a><a id="4606" class="Symbol">)</a> <a id="4608" href="Haskell.Law.Eq.Instances.html#4574" class="Bound">h</a><a id="4609" class="Symbol">)</a> 
    <a id="4616" class="Symbol">(</a><a id="4617" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="4622" href="Haskell.Prim.Tuple.html#239" class="Field">snd</a><a id="4625" class="Symbol">)</a> 
    <a id="4632" class="Symbol">(</a><a id="4633" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4644" class="Bound">x₂</a> <a id="4647" class="Bound">y₂</a><a id="4649" class="Symbol">)</a>
  <a id="4653" class="Symbol">...</a> <a id="4657" class="Symbol">|</a> <a id="4659" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="4665" class="Symbol">=</a> <a id="4667" class="Symbol">λ</a> <a id="4669" href="Haskell.Law.Eq.Instances.html#4669" class="Bound">h</a> <a id="4671" class="Symbol">→</a> <a id="4673" href="Haskell.Prim.html#2672" class="Function">exFalso</a> <a id="4681" class="Symbol">(</a><a id="4682" href="Haskell.Law.Eq.Def.html#624" class="Function">equality&#39;</a> <a id="4692" class="Bound">x₁</a> <a id="4695" class="Bound">y₁</a> <a id="4698" class="Symbol">(</a><a id="4699" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="4704" href="Haskell.Prim.Tuple.html#227" class="Field">fst</a> <a id="4708" href="Haskell.Law.Eq.Instances.html#4669" class="Bound">h</a><a id="4709" class="Symbol">))</a> <a id="4712" href="Haskell.Law.Eq.Instances.html#4536" class="Bound">h₁</a>

  <a id="iLawfulEqTuple₃"></a><a id="4718" href="Haskell.Law.Eq.Instances.html#4718" class="Function">iLawfulEqTuple₃</a> <a id="4734" class="Symbol">:</a> <a id="4736" class="Symbol">⦃</a> <a id="4738" href="Haskell.Law.Eq.Instances.html#4738" class="Bound">iEqA</a> <a id="4743" class="Symbol">:</a> <a id="4745" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="4748" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4750" class="Symbol">⦄</a> <a id="4752" class="Symbol">⦃</a> <a id="4754" href="Haskell.Law.Eq.Instances.html#4754" class="Bound">iEqB</a> <a id="4759" class="Symbol">:</a> <a id="4761" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="4764" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="4766" class="Symbol">⦄</a> <a id="4768" class="Symbol">⦃</a> <a id="4770" href="Haskell.Law.Eq.Instances.html#4770" class="Bound">iEqC</a> <a id="4775" class="Symbol">:</a> <a id="4777" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="4780" href="Haskell.Prim.html#1195" class="Generalizable">c</a> <a id="4782" class="Symbol">⦄</a>
    <a id="4788" class="Symbol">→</a> <a id="4790" class="Symbol">⦃</a> <a id="4792" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="4803" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4805" class="Symbol">⦄</a> <a id="4807" class="Symbol">→</a> <a id="4809" class="Symbol">⦃</a> <a id="4811" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="4822" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="4824" class="Symbol">⦄</a> <a id="4826" class="Symbol">→</a> <a id="4828" class="Symbol">⦃</a> <a id="4830" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="4841" href="Haskell.Prim.html#1195" class="Generalizable">c</a> <a id="4843" class="Symbol">⦄</a>
    <a id="4849" class="Symbol">→</a> <a id="4851" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="4862" class="Symbol">(</a><a id="4863" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4865" href="Haskell.Prim.Tuple.html#269" class="Datatype Operator">×</a> <a id="4867" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="4869" href="Haskell.Prim.Tuple.html#269" class="Datatype Operator">×</a> <a id="4871" href="Haskell.Prim.html#1195" class="Generalizable">c</a><a id="4872" class="Symbol">)</a>
  <a id="4876" href="Haskell.Law.Eq.Instances.html#4718" class="Function">iLawfulEqTuple₃</a> <a id="4892" class="Symbol">.</a><a id="4893" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="4904" class="Symbol">(</a><a id="4905" href="Haskell.Law.Eq.Instances.html#4905" class="Bound">x₁</a> <a id="4908" href="Haskell.Prim.Tuple.html#303" class="InductiveConstructor Operator">,</a> <a id="4910" href="Haskell.Law.Eq.Instances.html#4910" class="Bound">x₂</a> <a id="4913" href="Haskell.Prim.Tuple.html#303" class="InductiveConstructor Operator">,</a> <a id="4915" href="Haskell.Law.Eq.Instances.html#4915" class="Bound">x₃</a><a id="4917" class="Symbol">)</a> <a id="4919" class="Symbol">(</a><a id="4920" href="Haskell.Law.Eq.Instances.html#4920" class="Bound">y₁</a> <a id="4923" href="Haskell.Prim.Tuple.html#303" class="InductiveConstructor Operator">,</a> <a id="4925" href="Haskell.Law.Eq.Instances.html#4925" class="Bound">y₂</a> <a id="4928" href="Haskell.Prim.Tuple.html#303" class="InductiveConstructor Operator">,</a> <a id="4930" href="Haskell.Law.Eq.Instances.html#4930" class="Bound">y₃</a><a id="4932" class="Symbol">)</a> 
    <a id="4939" class="Keyword">with</a> <a id="4944" class="Symbol">(</a><a id="4945" href="Haskell.Law.Eq.Instances.html#4905" class="Bound">x₁</a> <a id="4948" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="4951" href="Haskell.Law.Eq.Instances.html#4920" class="Bound">y₁</a><a id="4953" class="Symbol">)</a> <a id="4955" class="Keyword">in</a> <a id="4958" class="Argument">h₁</a> 
  <a id="4964" class="Symbol">...</a> <a id="4968" class="Symbol">|</a> <a id="4970" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="4976" class="Symbol">=</a> <a id="4978" href="Haskell.Extra.Dec.html#661" class="Function">mapReflects</a>
    <a id="4994" class="Symbol">(λ</a> <a id="4997" href="Haskell.Law.Eq.Instances.html#4997" class="Bound">h</a> <a id="4999" class="Symbol">→</a> <a id="5001" href="Haskell.Law.Equality.html#307" class="Function">cong₂</a> <a id="5007" class="Symbol">(λ</a> <a id="5010" href="Haskell.Law.Eq.Instances.html#5010" class="Bound">a</a> <a id="5012" class="Symbol">(</a><a id="5013" href="Haskell.Law.Eq.Instances.html#5013" class="Bound">b</a> <a id="5015" href="Haskell.Prim.Tuple.html#211" class="InductiveConstructor Operator">,</a> <a id="5017" href="Haskell.Law.Eq.Instances.html#5017" class="Bound">c</a><a id="5018" class="Symbol">)</a> <a id="5020" class="Symbol">→</a> <a id="5022" href="Haskell.Law.Eq.Instances.html#5010" class="Bound">a</a> <a id="5024" href="Haskell.Prim.Tuple.html#303" class="InductiveConstructor Operator">,</a> <a id="5026" href="Haskell.Law.Eq.Instances.html#5013" class="Bound">b</a> <a id="5028" href="Haskell.Prim.Tuple.html#303" class="InductiveConstructor Operator">,</a> <a id="5030" href="Haskell.Law.Eq.Instances.html#5017" class="Bound">c</a><a id="5031" class="Symbol">)</a> <a id="5033" class="Symbol">(</a><a id="5034" href="Haskell.Law.Eq.Def.html#369" class="Function">equality</a> <a id="5043" class="Bound">x₁</a> <a id="5046" class="Bound">y₁</a> <a id="5049" href="Haskell.Law.Eq.Instances.html#4958" class="Bound">h₁</a><a id="5051" class="Symbol">)</a> <a id="5053" href="Haskell.Law.Eq.Instances.html#4997" class="Bound">h</a><a id="5054" class="Symbol">)</a> 
    <a id="5061" class="Symbol">(</a><a id="5062" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="5067" class="Symbol">λ</a> <a id="5069" href="Haskell.Law.Eq.Instances.html#5069" class="Bound">h</a> <a id="5071" class="Symbol">→</a> <a id="5073" href="Haskell.Prim.Tuple.html#691" class="Function">snd₃</a> <a id="5078" href="Haskell.Law.Eq.Instances.html#5069" class="Bound">h</a> <a id="5080" href="Haskell.Prim.Tuple.html#211" class="InductiveConstructor Operator">,</a> <a id="5082" href="Haskell.Prim.Tuple.html#736" class="Function">thd₃</a> <a id="5087" href="Haskell.Law.Eq.Instances.html#5069" class="Bound">h</a><a id="5088" class="Symbol">)</a> 
    <a id="5095" class="Symbol">(</a><a id="5096" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="5107" class="Symbol">(</a><a id="5108" class="Bound">x₂</a> <a id="5111" href="Haskell.Prim.Tuple.html#211" class="InductiveConstructor Operator">,</a> <a id="5113" class="Bound">x₃</a><a id="5115" class="Symbol">)</a> <a id="5117" class="Symbol">(</a><a id="5118" class="Bound">y₂</a> <a id="5121" href="Haskell.Prim.Tuple.html#211" class="InductiveConstructor Operator">,</a> <a id="5123" class="Bound">y₃</a><a id="5125" class="Symbol">))</a>
  <a id="5130" class="Symbol">...</a> <a id="5134" class="Symbol">|</a> <a id="5136" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="5142" class="Symbol">=</a> <a id="5144" class="Symbol">λ</a> <a id="5146" href="Haskell.Law.Eq.Instances.html#5146" class="Bound">h</a> <a id="5148" class="Symbol">→</a> <a id="5150" href="Haskell.Prim.html#2672" class="Function">exFalso</a> <a id="5158" class="Symbol">(</a><a id="5159" href="Haskell.Law.Eq.Def.html#624" class="Function">equality&#39;</a> <a id="5169" class="Bound">x₁</a> <a id="5172" class="Bound">y₁</a> <a id="5175" class="Symbol">(</a><a id="5176" href="Haskell.Law.Equality.html#226" class="Function">cong</a>  <a id="5182" href="Haskell.Prim.Tuple.html#645" class="Function">fst₃</a> <a id="5187" href="Haskell.Law.Eq.Instances.html#5146" class="Bound">h</a><a id="5188" class="Symbol">))</a> <a id="5191" href="Haskell.Law.Eq.Instances.html#4958" class="Bound">h₁</a> 

  <a id="iLawfulEqUnit"></a><a id="5198" href="Haskell.Law.Eq.Instances.html#5198" class="Function">iLawfulEqUnit</a> <a id="5212" class="Symbol">:</a> <a id="5214" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="5225" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="5229" href="Haskell.Law.Eq.Instances.html#5198" class="Function">iLawfulEqUnit</a> <a id="5243" class="Symbol">.</a><a id="5244" href="Haskell.Law.Eq.Def.html#313" class="Field">isEquality</a> <a id="5255" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="5258" href="Agda.Builtin.Unit.html#212" class="InductiveConstructor">tt</a> <a id="5261" class="Symbol">=</a> <a id="5263" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre></body></html>
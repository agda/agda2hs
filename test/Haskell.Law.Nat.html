<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Haskell.Law.Nat</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="Haskell.Law.Nat.html" class="Module">Haskell.Law.Nat</a> <a id="24" class="Keyword">where</a>

<a id="31" class="Keyword">open</a> <a id="36" class="Keyword">import</a> <a id="43" href="Haskell.Prim.html" class="Module">Haskell.Prim</a>
<a id="56" class="Keyword">open</a> <a id="61" class="Keyword">import</a> <a id="68" href="Haskell.Prim.Num.html" class="Module">Haskell.Prim.Num</a>

<a id="86" class="Keyword">open</a> <a id="91" class="Keyword">import</a> <a id="98" href="Haskell.Law.Def.html" class="Module">Haskell.Law.Def</a>
<a id="114" class="Keyword">open</a> <a id="119" class="Keyword">import</a> <a id="126" href="Haskell.Law.Equality.html" class="Module">Haskell.Law.Equality</a>

<a id="suc-injective"></a><a id="148" href="Haskell.Law.Nat.html#148" class="Function">suc-injective</a> <a id="162" class="Symbol">:</a> <a id="164" href="Haskell.Law.Def.html#57" class="Function">Injective</a> <a id="174" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a>
<a id="178" href="Haskell.Law.Nat.html#148" class="Function">suc-injective</a> <a id="192" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="197" class="Symbol">=</a> <a id="199" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="205" class="Comment">{-|
The canonical formalization of the
less-than-or-equal-to relation for natural numbers.
-}</a>
<a id="299" class="Keyword">data</a> <a id="_≤_"></a><a id="304" href="Haskell.Law.Nat.html#304" class="Datatype Operator">_≤_</a> <a id="308" class="Symbol">:</a> <a id="310" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a> <a id="314" class="Symbol">→</a> <a id="316" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a> <a id="320" class="Symbol">→</a> <a id="322" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="327" class="Keyword">where</a>
  <a id="_≤_.z≤n"></a><a id="335" href="Haskell.Law.Nat.html#335" class="InductiveConstructor">z≤n</a> <a id="339" class="Symbol">:</a> <a id="341" class="Symbol">∀</a> <a id="343" class="Symbol">{</a><a id="344" href="Haskell.Law.Nat.html#344" class="Bound">n</a><a id="345" class="Symbol">}</a>                 <a id="363" class="Symbol">→</a> <a id="365" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="371" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="373" href="Haskell.Law.Nat.html#344" class="Bound">n</a>
  <a id="_≤_.s≤s"></a><a id="377" href="Haskell.Law.Nat.html#377" class="InductiveConstructor">s≤s</a> <a id="381" class="Symbol">:</a> <a id="383" class="Symbol">∀</a> <a id="385" class="Symbol">{</a><a id="386" href="Haskell.Law.Nat.html#386" class="Bound">m</a> <a id="388" href="Haskell.Law.Nat.html#388" class="Bound">n</a><a id="389" class="Symbol">}</a> <a id="391" class="Symbol">(</a><a id="392" href="Haskell.Law.Nat.html#392" class="Bound">m≤n</a> <a id="396" class="Symbol">:</a> <a id="398" href="Haskell.Law.Nat.html#386" class="Bound">m</a> <a id="400" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="402" href="Haskell.Law.Nat.html#388" class="Bound">n</a><a id="403" class="Symbol">)</a> <a id="405" class="Symbol">→</a> <a id="407" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="411" href="Haskell.Law.Nat.html#386" class="Bound">m</a> <a id="413" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="415" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="419" href="Haskell.Law.Nat.html#388" class="Bound">n</a>

<a id="≤-refl"></a><a id="422" href="Haskell.Law.Nat.html#422" class="Function">≤-refl</a> <a id="429" class="Symbol">:</a> <a id="431" class="Symbol">∀</a> <a id="433" class="Symbol">(</a><a id="434" href="Haskell.Law.Nat.html#434" class="Bound">x</a> <a id="436" class="Symbol">:</a> <a id="438" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a><a id="441" class="Symbol">)</a> <a id="443" class="Symbol">→</a> <a id="445" href="Haskell.Law.Nat.html#434" class="Bound">x</a> <a id="447" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="449" href="Haskell.Law.Nat.html#434" class="Bound">x</a>
<a id="451" href="Haskell.Law.Nat.html#422" class="Function">≤-refl</a> <a id="458" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="466" class="Symbol">=</a> <a id="468" href="Haskell.Law.Nat.html#335" class="InductiveConstructor">z≤n</a>
<a id="472" href="Haskell.Law.Nat.html#422" class="Function">≤-refl</a> <a id="479" class="Symbol">(</a><a id="480" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="484" href="Haskell.Law.Nat.html#484" class="Bound">x</a><a id="485" class="Symbol">)</a> <a id="487" class="Symbol">=</a> <a id="489" href="Haskell.Law.Nat.html#377" class="InductiveConstructor">s≤s</a> <a id="493" class="Symbol">(</a><a id="494" href="Haskell.Law.Nat.html#422" class="Function">≤-refl</a> <a id="501" href="Haskell.Law.Nat.html#484" class="Bound">x</a><a id="502" class="Symbol">)</a>

<a id="≤-antisym"></a><a id="505" href="Haskell.Law.Nat.html#505" class="Function">≤-antisym</a> <a id="515" class="Symbol">:</a> <a id="517" class="Symbol">∀</a> <a id="519" class="Symbol">{</a><a id="520" href="Haskell.Law.Nat.html#520" class="Bound">x</a> <a id="522" href="Haskell.Law.Nat.html#522" class="Bound">y</a> <a id="524" class="Symbol">:</a> <a id="526" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a><a id="529" class="Symbol">}</a>
  <a id="533" class="Symbol">→</a> <a id="535" href="Haskell.Law.Nat.html#520" class="Bound">x</a> <a id="537" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="539" href="Haskell.Law.Nat.html#522" class="Bound">y</a>
  <a id="543" class="Symbol">→</a> <a id="545" href="Haskell.Law.Nat.html#522" class="Bound">y</a> <a id="547" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="549" href="Haskell.Law.Nat.html#520" class="Bound">x</a>
    <a id="555" class="Comment">-----</a>
  <a id="563" class="Symbol">→</a> <a id="565" href="Haskell.Law.Nat.html#520" class="Bound">x</a> <a id="567" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="569" href="Haskell.Law.Nat.html#522" class="Bound">y</a>
<a id="571" href="Haskell.Law.Nat.html#505" class="Function">≤-antisym</a> <a id="581" href="Haskell.Law.Nat.html#335" class="InductiveConstructor">z≤n</a>       <a id="591" href="Haskell.Law.Nat.html#335" class="InductiveConstructor">z≤n</a>       <a id="601" class="Symbol">=</a> <a id="603" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="608" href="Haskell.Law.Nat.html#505" class="Function">≤-antisym</a> <a id="618" class="Symbol">(</a><a id="619" href="Haskell.Law.Nat.html#377" class="InductiveConstructor">s≤s</a> <a id="623" href="Haskell.Law.Nat.html#623" class="Bound">x≤y</a><a id="626" class="Symbol">)</a> <a id="628" class="Symbol">(</a><a id="629" href="Haskell.Law.Nat.html#377" class="InductiveConstructor">s≤s</a> <a id="633" href="Haskell.Law.Nat.html#633" class="Bound">y≤x</a><a id="636" class="Symbol">)</a> <a id="638" class="Symbol">=</a> <a id="640" href="Haskell.Law.Equality.html#228" class="Function">cong</a> <a id="645" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="649" class="Symbol">(</a><a id="650" href="Haskell.Law.Nat.html#505" class="Function">≤-antisym</a> <a id="660" href="Haskell.Law.Nat.html#623" class="Bound">x≤y</a> <a id="664" href="Haskell.Law.Nat.html#633" class="Bound">y≤x</a><a id="667" class="Symbol">)</a>

<a id="≤-trans"></a><a id="670" href="Haskell.Law.Nat.html#670" class="Function">≤-trans</a> <a id="678" class="Symbol">:</a> <a id="680" class="Symbol">∀</a> <a id="682" class="Symbol">{</a><a id="683" href="Haskell.Law.Nat.html#683" class="Bound">x</a> <a id="685" href="Haskell.Law.Nat.html#685" class="Bound">y</a> <a id="687" href="Haskell.Law.Nat.html#687" class="Bound">z</a> <a id="689" class="Symbol">:</a> <a id="691" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a><a id="694" class="Symbol">}</a>
  <a id="698" class="Symbol">→</a> <a id="700" href="Haskell.Law.Nat.html#683" class="Bound">x</a> <a id="702" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="704" href="Haskell.Law.Nat.html#685" class="Bound">y</a>
  <a id="708" class="Symbol">→</a> <a id="710" href="Haskell.Law.Nat.html#685" class="Bound">y</a> <a id="712" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="714" href="Haskell.Law.Nat.html#687" class="Bound">z</a>
    <a id="720" class="Comment">-----</a>
  <a id="728" class="Symbol">→</a> <a id="730" href="Haskell.Law.Nat.html#683" class="Bound">x</a> <a id="732" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="734" href="Haskell.Law.Nat.html#687" class="Bound">z</a>
<a id="736" href="Haskell.Law.Nat.html#670" class="Function">≤-trans</a> <a id="744" href="Haskell.Law.Nat.html#335" class="InductiveConstructor">z≤n</a> <a id="748" href="Haskell.Law.Nat.html#748" class="Bound">y≤z</a> <a id="752" class="Symbol">=</a> <a id="754" href="Haskell.Law.Nat.html#335" class="InductiveConstructor">z≤n</a>
<a id="758" href="Haskell.Law.Nat.html#670" class="Function">≤-trans</a> <a id="766" class="Symbol">(</a><a id="767" href="Haskell.Law.Nat.html#377" class="InductiveConstructor">s≤s</a> <a id="771" href="Haskell.Law.Nat.html#771" class="Bound">x≤y</a><a id="774" class="Symbol">)</a> <a id="776" class="Symbol">(</a><a id="777" href="Haskell.Law.Nat.html#377" class="InductiveConstructor">s≤s</a> <a id="781" href="Haskell.Law.Nat.html#781" class="Bound">y≤z</a><a id="784" class="Symbol">)</a> <a id="786" class="Symbol">=</a> <a id="788" href="Haskell.Law.Nat.html#377" class="InductiveConstructor">s≤s</a> <a id="792" class="Symbol">(</a><a id="793" href="Haskell.Law.Nat.html#670" class="Function">≤-trans</a> <a id="801" href="Haskell.Law.Nat.html#771" class="Bound">x≤y</a> <a id="805" href="Haskell.Law.Nat.html#781" class="Bound">y≤z</a><a id="808" class="Symbol">)</a>

<a id="x≤x+1"></a><a id="811" href="Haskell.Law.Nat.html#811" class="Function">x≤x+1</a> <a id="817" class="Symbol">:</a> <a id="819" class="Symbol">∀</a> <a id="821" class="Symbol">(</a><a id="822" href="Haskell.Law.Nat.html#822" class="Bound">x</a> <a id="824" class="Symbol">:</a> <a id="826" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a><a id="829" class="Symbol">)</a> <a id="831" class="Symbol">→</a> <a id="833" href="Haskell.Law.Nat.html#822" class="Bound">x</a> <a id="835" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="837" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="841" href="Haskell.Law.Nat.html#822" class="Bound">x</a>
<a id="843" href="Haskell.Law.Nat.html#811" class="Function">x≤x+1</a> <a id="849" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="857" class="Symbol">=</a> <a id="859" href="Haskell.Law.Nat.html#335" class="InductiveConstructor">z≤n</a>
<a id="863" href="Haskell.Law.Nat.html#811" class="Function">x≤x+1</a> <a id="869" class="Symbol">(</a><a id="870" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="874" href="Haskell.Law.Nat.html#874" class="Bound">x</a><a id="875" class="Symbol">)</a> <a id="877" class="Symbol">=</a> <a id="879" href="Haskell.Law.Nat.html#377" class="InductiveConstructor">s≤s</a> <a id="883" class="Symbol">(</a><a id="884" href="Haskell.Law.Nat.html#811" class="Function">x≤x+1</a> <a id="890" href="Haskell.Law.Nat.html#874" class="Bound">x</a><a id="891" class="Symbol">)</a>

<a id="x+[y-x]≡y"></a><a id="894" href="Haskell.Law.Nat.html#894" class="Function">x+[y-x]≡y</a> <a id="904" class="Symbol">:</a> <a id="906" class="Symbol">∀</a> <a id="908" class="Symbol">(</a><a id="909" href="Haskell.Law.Nat.html#909" class="Bound">x</a> <a id="911" href="Haskell.Law.Nat.html#911" class="Bound">y</a> <a id="913" class="Symbol">:</a> <a id="915" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a><a id="918" class="Symbol">)</a> <a id="920" class="Symbol">→</a> <a id="922" href="Haskell.Law.Nat.html#909" class="Bound">x</a> <a id="924" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="926" href="Haskell.Law.Nat.html#911" class="Bound">y</a> <a id="928" class="Symbol">→</a> <a id="930" href="Haskell.Law.Nat.html#909" class="Bound">x</a> <a id="932" href="Haskell.Prim.Num.html#552" class="Field Operator">+</a> <a id="934" href="Agda.Builtin.Nat.html#426" class="Primitive">monusNat</a> <a id="943" href="Haskell.Law.Nat.html#911" class="Bound">y</a> <a id="945" href="Haskell.Law.Nat.html#909" class="Bound">x</a> <a id="947" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="949" href="Haskell.Law.Nat.html#911" class="Bound">y</a>
<a id="951" href="Haskell.Law.Nat.html#894" class="Function">x+[y-x]≡y</a>   <a id="963" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>       <a id="974" href="Haskell.Law.Nat.html#974" class="Bound">y</a>       <a id="982" href="Haskell.Law.Nat.html#982" class="Bound">x≤y</a>  <a id="987" class="Symbol">=</a> <a id="989" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="994" href="Haskell.Law.Nat.html#894" class="Function">x+[y-x]≡y</a> <a id="1004" class="Symbol">(</a><a id="1005" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1009" href="Haskell.Law.Nat.html#1009" class="Bound">x</a><a id="1010" class="Symbol">)</a> <a id="1012" class="Symbol">(</a><a id="1013" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1017" href="Haskell.Law.Nat.html#1017" class="Bound">y</a><a id="1018" class="Symbol">)</a> <a id="1020" class="Symbol">(</a><a id="1021" href="Haskell.Law.Nat.html#377" class="InductiveConstructor">s≤s</a> <a id="1025" href="Haskell.Law.Nat.html#1025" class="Bound">x≤y</a><a id="1028" class="Symbol">)</a> <a id="1030" class="Symbol">=</a> <a id="1032" href="Haskell.Law.Equality.html#228" class="Function">cong</a> <a id="1037" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1041" class="Symbol">(</a><a id="1042" href="Haskell.Law.Nat.html#894" class="Function">x+[y-x]≡y</a> <a id="1052" href="Haskell.Law.Nat.html#1009" class="Bound">x</a> <a id="1054" href="Haskell.Law.Nat.html#1017" class="Bound">y</a> <a id="1056" href="Haskell.Law.Nat.html#1025" class="Bound">x≤y</a><a id="1059" class="Symbol">)</a>

<a id="y-x≤y"></a><a id="1062" href="Haskell.Law.Nat.html#1062" class="Function">y-x≤y</a> <a id="1068" class="Symbol">:</a> <a id="1070" class="Symbol">∀</a> <a id="1072" class="Symbol">(</a><a id="1073" href="Haskell.Law.Nat.html#1073" class="Bound">x</a> <a id="1075" href="Haskell.Law.Nat.html#1075" class="Bound">y</a> <a id="1077" class="Symbol">:</a> <a id="1079" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a><a id="1082" class="Symbol">)</a> <a id="1084" class="Symbol">→</a> <a id="1086" href="Agda.Builtin.Nat.html#426" class="Primitive">monusNat</a> <a id="1095" href="Haskell.Law.Nat.html#1075" class="Bound">y</a> <a id="1097" href="Haskell.Law.Nat.html#1073" class="Bound">x</a> <a id="1099" href="Haskell.Law.Nat.html#304" class="Datatype Operator">≤</a> <a id="1101" href="Haskell.Law.Nat.html#1075" class="Bound">y</a>
<a id="1103" href="Haskell.Law.Nat.html#1062" class="Function">y-x≤y</a> <a id="1109" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>         <a id="1122" href="Haskell.Law.Nat.html#1122" class="Bound">y</a>  <a id="1125" class="Symbol">=</a> <a id="1127" href="Haskell.Law.Nat.html#422" class="Function">≤-refl</a> <a id="1134" href="Haskell.Law.Nat.html#1122" class="Bound">y</a>
<a id="1136" href="Haskell.Law.Nat.html#1062" class="Function">y-x≤y</a> <a id="1142" class="Symbol">(</a><a id="1143" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1147" href="Haskell.Law.Nat.html#1147" class="Bound">x</a><a id="1148" class="Symbol">)</a>   <a id="1152" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="1158" class="Symbol">=</a> <a id="1160" href="Haskell.Law.Nat.html#335" class="InductiveConstructor">z≤n</a>
<a id="1164" href="Haskell.Law.Nat.html#1062" class="Function">y-x≤y</a> <a id="1170" class="Symbol">(</a><a id="1171" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1175" href="Haskell.Law.Nat.html#1175" class="Bound">x</a><a id="1176" class="Symbol">)</a> <a id="1178" class="Symbol">(</a><a id="1179" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1183" href="Haskell.Law.Nat.html#1183" class="Bound">y</a><a id="1184" class="Symbol">)</a> <a id="1186" class="Symbol">=</a> <a id="1188" href="Haskell.Law.Nat.html#670" class="Function">≤-trans</a> <a id="1196" class="Symbol">(</a><a id="1197" href="Haskell.Law.Nat.html#1062" class="Function">y-x≤y</a> <a id="1203" href="Haskell.Law.Nat.html#1175" class="Bound">x</a> <a id="1205" href="Haskell.Law.Nat.html#1183" class="Bound">y</a><a id="1206" class="Symbol">)</a> <a id="1208" class="Symbol">(</a><a id="1209" href="Haskell.Law.Nat.html#811" class="Function">x≤x+1</a> <a id="1215" href="Haskell.Law.Nat.html#1183" class="Bound">y</a><a id="1216" class="Symbol">)</a>
</pre></body></html>
<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Haskell.Law.Eq.Def</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="Haskell.Law.Eq.Def.html" class="Module">Haskell.Law.Eq.Def</a> <a id="27" class="Keyword">where</a>

<a id="34" class="Keyword">open</a> <a id="39" class="Keyword">import</a> <a id="46" href="Haskell.Prim.html" class="Module">Haskell.Prim</a>
<a id="59" class="Keyword">open</a> <a id="64" class="Keyword">import</a> <a id="71" href="Haskell.Prim.Bool.html" class="Module">Haskell.Prim.Bool</a>
<a id="89" class="Keyword">open</a> <a id="94" class="Keyword">import</a> <a id="101" href="Haskell.Prim.Double.html" class="Module">Haskell.Prim.Double</a>

<a id="122" class="Keyword">open</a> <a id="127" class="Keyword">import</a> <a id="134" href="Haskell.Prim.Eq.html" class="Module">Haskell.Prim.Eq</a>

<a id="151" class="Keyword">open</a> <a id="156" class="Keyword">import</a> <a id="163" href="Haskell.Extra.Dec.html" class="Module">Haskell.Extra.Dec</a>
<a id="181" class="Keyword">open</a> <a id="186" class="Keyword">import</a> <a id="193" href="Haskell.Extra.Refinement.html" class="Module">Haskell.Extra.Refinement</a>

<a id="219" class="Keyword">open</a> <a id="224" class="Keyword">import</a> <a id="231" href="Haskell.Law.Bool.html" class="Module">Haskell.Law.Bool</a>
<a id="248" class="Keyword">open</a> <a id="253" class="Keyword">import</a> <a id="260" href="Haskell.Law.Equality.html" class="Module">Haskell.Law.Equality</a>

<a id="282" class="Keyword">record</a> <a id="IsLawfulEq"></a><a id="289" href="Haskell.Law.Eq.Def.html#289" class="Record">IsLawfulEq</a> <a id="300" class="Symbol">(</a><a id="301" href="Haskell.Law.Eq.Def.html#301" class="Bound">e</a> <a id="303" class="Symbol">:</a> <a id="305" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="309" class="Symbol">)</a> <a id="311" class="Symbol">⦃</a> <a id="313" href="Haskell.Law.Eq.Def.html#313" class="Bound">iEq</a> <a id="317" class="Symbol">:</a> <a id="319" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="322" href="Haskell.Law.Eq.Def.html#301" class="Bound">e</a> <a id="324" class="Symbol">⦄</a> <a id="326" class="Symbol">:</a> <a id="328" href="Agda.Primitive.html#388" class="Primitive">Type₁</a> <a id="334" class="Keyword">where</a>
  <a id="342" class="Keyword">field</a>
    <a id="IsLawfulEq.isEquality"></a><a id="352" href="Haskell.Law.Eq.Def.html#352" class="Field">isEquality</a> <a id="363" class="Symbol">:</a> <a id="365" class="Symbol">∀</a> <a id="367" class="Symbol">(</a><a id="368" href="Haskell.Law.Eq.Def.html#368" class="Bound">x</a> <a id="370" href="Haskell.Law.Eq.Def.html#370" class="Bound">y</a> <a id="372" class="Symbol">:</a> <a id="374" href="Haskell.Law.Eq.Def.html#301" class="Bound">e</a><a id="375" class="Symbol">)</a> <a id="377" class="Symbol">→</a> <a id="379" href="Haskell.Extra.Dec.html#170" class="Function">Reflects</a> <a id="388" class="Symbol">(</a><a id="389" href="Haskell.Law.Eq.Def.html#368" class="Bound">x</a> <a id="391" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="393" href="Haskell.Law.Eq.Def.html#370" class="Bound">y</a><a id="394" class="Symbol">)</a> <a id="396" class="Symbol">(</a><a id="397" href="Haskell.Law.Eq.Def.html#368" class="Bound">x</a> <a id="399" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="402" href="Haskell.Law.Eq.Def.html#370" class="Bound">y</a><a id="403" class="Symbol">)</a>

  <a id="IsLawfulEq.equality"></a><a id="408" href="Haskell.Law.Eq.Def.html#408" class="Function">equality</a> <a id="417" class="Symbol">:</a> <a id="419" class="Symbol">∀</a> <a id="421" class="Symbol">(</a><a id="422" href="Haskell.Law.Eq.Def.html#422" class="Bound">x</a> <a id="424" href="Haskell.Law.Eq.Def.html#424" class="Bound">y</a> <a id="426" class="Symbol">:</a> <a id="428" href="Haskell.Law.Eq.Def.html#301" class="Bound">e</a><a id="429" class="Symbol">)</a> <a id="431" class="Symbol">→</a> <a id="433" class="Symbol">(</a><a id="434" href="Haskell.Law.Eq.Def.html#422" class="Bound">x</a> <a id="436" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="439" href="Haskell.Law.Eq.Def.html#424" class="Bound">y</a><a id="440" class="Symbol">)</a> <a id="442" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="444" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="449" class="Symbol">→</a> <a id="451" href="Haskell.Law.Eq.Def.html#422" class="Bound">x</a> <a id="453" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="455" href="Haskell.Law.Eq.Def.html#424" class="Bound">y</a>
  <a id="459" href="Haskell.Law.Eq.Def.html#408" class="Function">equality</a> <a id="468" href="Haskell.Law.Eq.Def.html#468" class="Bound">x</a> <a id="470" href="Haskell.Law.Eq.Def.html#470" class="Bound">y</a> <a id="472" href="Haskell.Law.Eq.Def.html#472" class="Bound">h</a> <a id="474" class="Symbol">=</a> <a id="476" href="Haskell.Extra.Dec.html#466" class="Function">extractTrue</a> <a id="488" class="Symbol">⦃</a> <a id="490" href="Haskell.Law.Eq.Def.html#472" class="Bound">h</a> <a id="492" class="Symbol">⦄</a> <a id="494" class="Symbol">(</a><a id="495" href="Haskell.Law.Eq.Def.html#352" class="Field">isEquality</a> <a id="506" href="Haskell.Law.Eq.Def.html#468" class="Bound">x</a> <a id="508" href="Haskell.Law.Eq.Def.html#470" class="Bound">y</a><a id="509" class="Symbol">)</a>

  <a id="IsLawfulEq.nequality"></a><a id="514" href="Haskell.Law.Eq.Def.html#514" class="Function">nequality</a> <a id="524" class="Symbol">:</a> <a id="526" class="Symbol">∀</a> <a id="528" class="Symbol">(</a><a id="529" href="Haskell.Law.Eq.Def.html#529" class="Bound">x</a> <a id="531" href="Haskell.Law.Eq.Def.html#531" class="Bound">y</a> <a id="533" class="Symbol">:</a> <a id="535" href="Haskell.Law.Eq.Def.html#301" class="Bound">e</a><a id="536" class="Symbol">)</a> <a id="538" class="Symbol">→</a> <a id="540" class="Symbol">(</a><a id="541" href="Haskell.Law.Eq.Def.html#529" class="Bound">x</a> <a id="543" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="546" href="Haskell.Law.Eq.Def.html#531" class="Bound">y</a><a id="547" class="Symbol">)</a> <a id="549" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="551" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="557" class="Symbol">→</a> <a id="559" class="Symbol">(</a><a id="560" href="Haskell.Law.Eq.Def.html#529" class="Bound">x</a> <a id="562" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="564" href="Haskell.Law.Eq.Def.html#531" class="Bound">y</a> <a id="566" class="Symbol">→</a> <a id="568" href="Haskell.Prim.html#2624" class="Datatype">⊥</a><a id="569" class="Symbol">)</a>
  <a id="573" href="Haskell.Law.Eq.Def.html#514" class="Function">nequality</a> <a id="583" href="Haskell.Law.Eq.Def.html#583" class="Bound">x</a> <a id="585" href="Haskell.Law.Eq.Def.html#585" class="Bound">y</a> <a id="587" href="Haskell.Law.Eq.Def.html#587" class="Bound">h</a> <a id="589" class="Symbol">=</a> <a id="591" href="Haskell.Extra.Dec.html#559" class="Function">extractFalse</a> <a id="604" class="Symbol">⦃</a> <a id="606" href="Haskell.Law.Eq.Def.html#587" class="Bound">h</a> <a id="608" class="Symbol">⦄</a> <a id="610" class="Symbol">(</a><a id="611" href="Haskell.Law.Eq.Def.html#352" class="Field">isEquality</a> <a id="622" href="Haskell.Law.Eq.Def.html#583" class="Bound">x</a> <a id="624" href="Haskell.Law.Eq.Def.html#585" class="Bound">y</a><a id="625" class="Symbol">)</a>

  <a id="630" class="Comment">-- contrapositive of nequality</a>
  <a id="IsLawfulEq.equality&#39;"></a><a id="663" href="Haskell.Law.Eq.Def.html#663" class="Function">equality&#39;</a> <a id="673" class="Symbol">:</a> <a id="675" class="Symbol">∀</a> <a id="677" class="Symbol">(</a><a id="678" href="Haskell.Law.Eq.Def.html#678" class="Bound">x</a> <a id="680" href="Haskell.Law.Eq.Def.html#680" class="Bound">y</a> <a id="682" class="Symbol">:</a> <a id="684" href="Haskell.Law.Eq.Def.html#301" class="Bound">e</a><a id="685" class="Symbol">)</a> <a id="687" class="Symbol">→</a> <a id="689" href="Haskell.Law.Eq.Def.html#678" class="Bound">x</a> <a id="691" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="693" href="Haskell.Law.Eq.Def.html#680" class="Bound">y</a> <a id="695" class="Symbol">→</a> <a id="697" class="Symbol">(</a><a id="698" href="Haskell.Law.Eq.Def.html#678" class="Bound">x</a> <a id="700" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="703" href="Haskell.Law.Eq.Def.html#680" class="Bound">y</a><a id="704" class="Symbol">)</a> <a id="706" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="708" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
  <a id="715" href="Haskell.Law.Eq.Def.html#663" class="Function">equality&#39;</a> <a id="725" href="Haskell.Law.Eq.Def.html#725" class="Bound">x</a> <a id="727" href="Haskell.Law.Eq.Def.html#727" class="Bound">y</a> <a id="729" href="Haskell.Law.Eq.Def.html#729" class="Bound">h</a> <a id="731" class="Keyword">with</a> <a id="736" href="Haskell.Law.Eq.Def.html#725" class="Bound">x</a> <a id="738" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="741" href="Haskell.Law.Eq.Def.html#727" class="Bound">y</a> <a id="743" class="Keyword">in</a> <a id="746" class="Argument">eq</a>
  <a id="751" class="Symbol">...</a> <a id="755" class="Symbol">|</a> <a id="757" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="763" class="Symbol">=</a> <a id="765" href="Haskell.Prim.html#2640" class="Function">magic</a> <a id="771" class="Symbol">(</a><a id="772" href="Haskell.Law.Eq.Def.html#514" class="Function">nequality</a> <a id="782" class="Bound">x</a> <a id="784" class="Bound">y</a> <a id="786" href="Haskell.Law.Eq.Def.html#746" class="Bound">eq</a> <a id="789" class="Bound">h</a><a id="790" class="Symbol">)</a>
  <a id="794" class="Symbol">...</a> <a id="798" class="Symbol">|</a> <a id="800" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="805" class="Symbol">=</a> <a id="807" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="815" class="Comment">-- contrapositive of equality</a>
  <a id="IsLawfulEq.nequality&#39;"></a><a id="847" href="Haskell.Law.Eq.Def.html#847" class="Function">nequality&#39;</a> <a id="858" class="Symbol">:</a> <a id="860" class="Symbol">∀</a> <a id="862" class="Symbol">(</a><a id="863" href="Haskell.Law.Eq.Def.html#863" class="Bound">x</a> <a id="865" href="Haskell.Law.Eq.Def.html#865" class="Bound">y</a> <a id="867" class="Symbol">:</a> <a id="869" href="Haskell.Law.Eq.Def.html#301" class="Bound">e</a><a id="870" class="Symbol">)</a> <a id="872" class="Symbol">→</a> <a id="874" class="Symbol">(</a><a id="875" href="Haskell.Law.Eq.Def.html#863" class="Bound">x</a> <a id="877" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="879" href="Haskell.Law.Eq.Def.html#865" class="Bound">y</a> <a id="881" class="Symbol">→</a> <a id="883" href="Haskell.Prim.html#2624" class="Datatype">⊥</a><a id="884" class="Symbol">)</a> <a id="886" class="Symbol">→</a> <a id="888" class="Symbol">(</a><a id="889" href="Haskell.Law.Eq.Def.html#863" class="Bound">x</a> <a id="891" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="894" href="Haskell.Law.Eq.Def.html#865" class="Bound">y</a><a id="895" class="Symbol">)</a> <a id="897" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="899" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a>
  <a id="907" href="Haskell.Law.Eq.Def.html#847" class="Function">nequality&#39;</a> <a id="918" href="Haskell.Law.Eq.Def.html#918" class="Bound">x</a> <a id="920" href="Haskell.Law.Eq.Def.html#920" class="Bound">y</a> <a id="922" href="Haskell.Law.Eq.Def.html#922" class="Bound">h</a> <a id="924" class="Keyword">with</a> <a id="929" href="Haskell.Law.Eq.Def.html#918" class="Bound">x</a> <a id="931" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="934" href="Haskell.Law.Eq.Def.html#920" class="Bound">y</a> <a id="936" class="Keyword">in</a> <a id="939" class="Argument">eq</a>
  <a id="944" class="Symbol">...</a> <a id="948" class="Symbol">|</a> <a id="950" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="955" class="Symbol">=</a> <a id="957" href="Haskell.Prim.html#2640" class="Function">magic</a> <a id="963" class="Symbol">(</a><a id="964" class="Bound">h</a> <a id="966" class="Symbol">(</a><a id="967" href="Haskell.Law.Eq.Def.html#408" class="Function">equality</a> <a id="976" class="Bound">x</a> <a id="978" class="Bound">y</a> <a id="980" href="Haskell.Law.Eq.Def.html#939" class="Bound">eq</a><a id="982" class="Symbol">))</a>
  <a id="987" class="Symbol">...</a> <a id="991" class="Symbol">|</a> <a id="993" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="999" class="Symbol">=</a> <a id="1001" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="1007" class="Keyword">open</a> <a id="1012" href="Haskell.Law.Eq.Def.html#289" class="Module">IsLawfulEq</a> <a id="1023" class="Symbol">⦃</a> <a id="1025" class="Symbol">...</a> <a id="1029" class="Symbol">⦄</a> <a id="1031" class="Keyword">public</a>

<a id="1039" class="Comment">-- Types with a lawful Eq instance have decidable equality</a>
<a id="_≟_"></a><a id="1098" href="Haskell.Law.Eq.Def.html#1098" class="Function Operator">_≟_</a> <a id="1102" class="Symbol">:</a> <a id="1104" class="Symbol">{{</a><a id="1106" href="Haskell.Law.Eq.Def.html#1106" class="Bound">_</a> <a id="1108" class="Symbol">:</a> <a id="1110" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="1113" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="1114" class="Symbol">}}</a> <a id="1117" class="Symbol">{{</a><a id="1119" href="Haskell.Law.Eq.Def.html#1119" class="Bound">_</a> <a id="1121" class="Symbol">:</a> <a id="1123" href="Haskell.Law.Eq.Def.html#289" class="Record">IsLawfulEq</a> <a id="1134" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="1135" class="Symbol">}}</a> <a id="1138" class="Symbol">→</a> <a id="1140" class="Symbol">(</a><a id="1141" href="Haskell.Law.Eq.Def.html#1141" class="Bound">x</a> <a id="1143" href="Haskell.Law.Eq.Def.html#1143" class="Bound">y</a> <a id="1145" class="Symbol">:</a> <a id="1147" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="1148" class="Symbol">)</a> <a id="1150" class="Symbol">→</a> <a id="1152" href="Haskell.Extra.Dec.html#836" class="Function">Dec</a> <a id="1156" class="Symbol">(</a><a id="1157" href="Haskell.Law.Eq.Def.html#1141" class="Bound">x</a> <a id="1159" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1161" href="Haskell.Law.Eq.Def.html#1143" class="Bound">y</a><a id="1162" class="Symbol">)</a>
<a id="1164" href="Haskell.Law.Eq.Def.html#1164" class="Bound">x</a> <a id="1166" href="Haskell.Law.Eq.Def.html#1098" class="Function Operator">≟</a> <a id="1168" href="Haskell.Law.Eq.Def.html#1168" class="Bound">y</a> <a id="1170" class="Symbol">=</a> <a id="1172" class="Symbol">(</a><a id="1173" href="Haskell.Law.Eq.Def.html#1164" class="Bound">x</a> <a id="1175" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1178" href="Haskell.Law.Eq.Def.html#1168" class="Bound">y</a><a id="1179" class="Symbol">)</a> <a id="1181" href="Haskell.Extra.Refinement.html#208" class="InductiveConstructor Operator">⟨</a> <a id="1183" href="Haskell.Law.Eq.Def.html#352" class="Field">isEquality</a> <a id="1194" href="Haskell.Law.Eq.Def.html#1164" class="Bound">x</a> <a id="1196" href="Haskell.Law.Eq.Def.html#1168" class="Bound">y</a> <a id="1198" href="Haskell.Extra.Refinement.html#208" class="InductiveConstructor Operator">⟩</a>

<a id="1201" class="Symbol">{-#</a> <a id="1205" class="Keyword">COMPILE</a> <a id="1213" class="Keyword">AGDA2HS</a> <a id="1221" href="Haskell.Law.Eq.Def.html#1098" class="Function Operator">_≟_</a> <a id="1225" class="Pragma">inline</a> <a id="1232" class="Symbol">#-}</a>

<a id="1237" class="Comment">-- Reflexivity: x == x = True</a>
<a id="eqReflexivity"></a><a id="1267" href="Haskell.Law.Eq.Def.html#1267" class="Function">eqReflexivity</a> <a id="1281" class="Symbol">:</a> <a id="1283" class="Symbol">⦃</a> <a id="1285" href="Haskell.Law.Eq.Def.html#1285" class="Bound">iEq</a> <a id="1289" class="Symbol">:</a> <a id="1291" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="1294" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="1296" class="Symbol">⦄</a> <a id="1298" class="Symbol">→</a> <a id="1300" class="Symbol">⦃</a> <a id="1302" href="Haskell.Law.Eq.Def.html#289" class="Record">IsLawfulEq</a> <a id="1313" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="1315" class="Symbol">⦄</a>
              <a id="1331" class="Symbol">→</a> <a id="1333" class="Symbol">∀</a> <a id="1335" class="Symbol">(</a><a id="1336" href="Haskell.Law.Eq.Def.html#1336" class="Bound">x</a> <a id="1338" class="Symbol">:</a> <a id="1340" href="Haskell.Prim.html#1222" class="Generalizable">e</a><a id="1341" class="Symbol">)</a> <a id="1343" class="Symbol">→</a> <a id="1345" class="Symbol">(</a><a id="1346" href="Haskell.Law.Eq.Def.html#1336" class="Bound">x</a> <a id="1348" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1351" href="Haskell.Law.Eq.Def.html#1336" class="Bound">x</a><a id="1352" class="Symbol">)</a> <a id="1354" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1356" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="1361" href="Haskell.Law.Eq.Def.html#1267" class="Function">eqReflexivity</a> <a id="1375" href="Haskell.Law.Eq.Def.html#1375" class="Bound">x</a> <a id="1377" class="Symbol">=</a> <a id="1379" href="Haskell.Law.Eq.Def.html#663" class="Function">equality&#39;</a> <a id="1389" href="Haskell.Law.Eq.Def.html#1375" class="Bound">x</a> <a id="1391" href="Haskell.Law.Eq.Def.html#1375" class="Bound">x</a> <a id="1393" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="1399" class="Comment">-- Symmetry: x == y = y == x</a>
<a id="eqSymmetry"></a><a id="1428" href="Haskell.Law.Eq.Def.html#1428" class="Function">eqSymmetry</a> <a id="1439" class="Symbol">:</a> <a id="1441" class="Symbol">⦃</a> <a id="1443" href="Haskell.Law.Eq.Def.html#1443" class="Bound">iEq</a> <a id="1447" class="Symbol">:</a> <a id="1449" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="1452" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="1454" class="Symbol">⦄</a> <a id="1456" class="Symbol">→</a> <a id="1458" class="Symbol">⦃</a> <a id="1460" href="Haskell.Law.Eq.Def.html#289" class="Record">IsLawfulEq</a> <a id="1471" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="1473" class="Symbol">⦄</a>
           <a id="1486" class="Symbol">→</a> <a id="1488" class="Symbol">∀</a> <a id="1490" class="Symbol">(</a><a id="1491" href="Haskell.Law.Eq.Def.html#1491" class="Bound">x</a> <a id="1493" href="Haskell.Law.Eq.Def.html#1493" class="Bound">y</a> <a id="1495" class="Symbol">:</a> <a id="1497" href="Haskell.Prim.html#1222" class="Generalizable">e</a><a id="1498" class="Symbol">)</a> <a id="1500" class="Symbol">→</a> <a id="1502" class="Symbol">(</a><a id="1503" href="Haskell.Law.Eq.Def.html#1491" class="Bound">x</a> <a id="1505" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1508" href="Haskell.Law.Eq.Def.html#1493" class="Bound">y</a><a id="1509" class="Symbol">)</a> <a id="1511" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1513" class="Symbol">(</a><a id="1514" href="Haskell.Law.Eq.Def.html#1493" class="Bound">y</a> <a id="1516" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1519" href="Haskell.Law.Eq.Def.html#1491" class="Bound">x</a><a id="1520" class="Symbol">)</a>
<a id="1522" href="Haskell.Law.Eq.Def.html#1428" class="Function">eqSymmetry</a> <a id="1533" href="Haskell.Law.Eq.Def.html#1533" class="Bound">x</a> <a id="1535" href="Haskell.Law.Eq.Def.html#1535" class="Bound">y</a> <a id="1537" class="Keyword">with</a> <a id="1542" href="Haskell.Law.Eq.Def.html#1533" class="Bound">x</a> <a id="1544" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1547" href="Haskell.Law.Eq.Def.html#1535" class="Bound">y</a> <a id="1549" class="Keyword">in</a> <a id="1552" class="Argument">eq</a>
<a id="1555" class="Symbol">...</a> <a id="1559" class="Symbol">|</a> <a id="1561" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="1567" class="Symbol">=</a> <a id="1569" href="Haskell.Law.Equality.html#404" class="Function">sym</a> <a id="1573" class="Symbol">(</a><a id="1574" href="Haskell.Law.Eq.Def.html#663" class="Function">equality&#39;</a> <a id="1584" class="Bound">y</a> <a id="1586" class="Bound">x</a> <a id="1588" class="Symbol">(</a><a id="1589" href="Haskell.Law.Equality.html#404" class="Function">sym</a> <a id="1593" class="Symbol">(</a><a id="1594" href="Haskell.Law.Eq.Def.html#408" class="Function">equality</a> <a id="1603" class="Bound">x</a> <a id="1605" class="Bound">y</a> <a id="1607" href="Haskell.Law.Eq.Def.html#1552" class="Bound">eq</a><a id="1609" class="Symbol">)))</a>
<a id="1613" class="Symbol">...</a> <a id="1617" class="Symbol">|</a> <a id="1619" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="1625" class="Symbol">=</a> <a id="1627" href="Haskell.Law.Equality.html#404" class="Function">sym</a> <a id="1631" class="Symbol">(</a><a id="1632" href="Haskell.Law.Eq.Def.html#847" class="Function">nequality&#39;</a> <a id="1643" class="Bound">y</a> <a id="1645" class="Bound">x</a> <a id="1647" class="Symbol">(λ</a> <a id="1650" href="Haskell.Law.Eq.Def.html#1650" class="Bound">qe</a> <a id="1653" class="Symbol">→</a> <a id="1655" class="Symbol">(</a><a id="1656" href="Haskell.Law.Eq.Def.html#514" class="Function">nequality</a> <a id="1666" class="Bound">x</a> <a id="1668" class="Bound">y</a> <a id="1670" href="Haskell.Law.Eq.Def.html#1552" class="Bound">eq</a><a id="1672" class="Symbol">)</a> <a id="1674" class="Symbol">(</a><a id="1675" href="Haskell.Law.Equality.html#404" class="Function">sym</a> <a id="1679" href="Haskell.Law.Eq.Def.html#1650" class="Bound">qe</a><a id="1681" class="Symbol">)))</a>

<a id="1686" class="Comment">-- Transitivity: if x == y &amp;&amp; y == z = True, then x == z = True</a>
<a id="eqTransitivity"></a><a id="1750" href="Haskell.Law.Eq.Def.html#1750" class="Function">eqTransitivity</a> <a id="1765" class="Symbol">:</a> <a id="1767" class="Symbol">⦃</a> <a id="1769" href="Haskell.Law.Eq.Def.html#1769" class="Bound">iEq</a> <a id="1773" class="Symbol">:</a> <a id="1775" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="1778" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="1780" class="Symbol">⦄</a> <a id="1782" class="Symbol">→</a> <a id="1784" class="Symbol">⦃</a> <a id="1786" href="Haskell.Law.Eq.Def.html#289" class="Record">IsLawfulEq</a> <a id="1797" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="1799" class="Symbol">⦄</a>
               <a id="1816" class="Symbol">→</a> <a id="1818" class="Symbol">∀</a> <a id="1820" class="Symbol">(</a><a id="1821" href="Haskell.Law.Eq.Def.html#1821" class="Bound">x</a> <a id="1823" href="Haskell.Law.Eq.Def.html#1823" class="Bound">y</a> <a id="1825" href="Haskell.Law.Eq.Def.html#1825" class="Bound">z</a> <a id="1827" class="Symbol">:</a> <a id="1829" href="Haskell.Prim.html#1222" class="Generalizable">e</a><a id="1830" class="Symbol">)</a> <a id="1832" class="Symbol">→</a> <a id="1834" class="Symbol">((</a><a id="1836" href="Haskell.Law.Eq.Def.html#1821" class="Bound">x</a> <a id="1838" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1841" href="Haskell.Law.Eq.Def.html#1823" class="Bound">y</a><a id="1842" class="Symbol">)</a> <a id="1844" href="Haskell.Prim.Bool.html#138" class="Function Operator">&amp;&amp;</a> <a id="1847" class="Symbol">(</a><a id="1848" href="Haskell.Law.Eq.Def.html#1823" class="Bound">y</a> <a id="1850" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1853" href="Haskell.Law.Eq.Def.html#1825" class="Bound">z</a><a id="1854" class="Symbol">))</a> <a id="1857" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1859" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="1864" class="Symbol">→</a> <a id="1866" class="Symbol">(</a><a id="1867" href="Haskell.Law.Eq.Def.html#1821" class="Bound">x</a> <a id="1869" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1872" href="Haskell.Law.Eq.Def.html#1825" class="Bound">z</a><a id="1873" class="Symbol">)</a> <a id="1875" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1877" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="1882" href="Haskell.Law.Eq.Def.html#1750" class="Function">eqTransitivity</a> <a id="1897" href="Haskell.Law.Eq.Def.html#1897" class="Bound">x</a> <a id="1899" href="Haskell.Law.Eq.Def.html#1899" class="Bound">y</a> <a id="1901" href="Haskell.Law.Eq.Def.html#1901" class="Bound">z</a> <a id="1903" href="Haskell.Law.Eq.Def.html#1903" class="Bound">h</a>
  <a id="1907" class="Symbol">=</a> <a id="1909" href="Haskell.Law.Eq.Def.html#663" class="Function">equality&#39;</a> <a id="1919" href="Haskell.Law.Eq.Def.html#1897" class="Bound">x</a> <a id="1921" href="Haskell.Law.Eq.Def.html#1901" class="Bound">z</a> <a id="1923" class="Symbol">(</a><a id="1924" href="Haskell.Law.Equality.html#466" class="Function">trans</a>
    <a id="1934" class="Symbol">(</a><a id="1935" href="Haskell.Law.Eq.Def.html#408" class="Function">equality</a> <a id="1944" href="Haskell.Law.Eq.Def.html#1897" class="Bound">x</a> <a id="1946" href="Haskell.Law.Eq.Def.html#1899" class="Bound">y</a> <a id="1948" class="Symbol">(</a><a id="1949" href="Haskell.Law.Bool.html#4060" class="Function">&amp;&amp;-leftTrue</a> <a id="1961" class="Symbol">(</a><a id="1962" href="Haskell.Law.Eq.Def.html#1897" class="Bound">x</a> <a id="1964" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1967" href="Haskell.Law.Eq.Def.html#1899" class="Bound">y</a><a id="1968" class="Symbol">)</a> <a id="1970" class="Symbol">(</a><a id="1971" href="Haskell.Law.Eq.Def.html#1899" class="Bound">y</a> <a id="1973" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1976" href="Haskell.Law.Eq.Def.html#1901" class="Bound">z</a><a id="1977" class="Symbol">)</a> <a id="1979" href="Haskell.Law.Eq.Def.html#1903" class="Bound">h</a><a id="1980" class="Symbol">))</a>
    <a id="1987" class="Symbol">(</a><a id="1988" href="Haskell.Law.Eq.Def.html#408" class="Function">equality</a> <a id="1997" href="Haskell.Law.Eq.Def.html#1899" class="Bound">y</a> <a id="1999" href="Haskell.Law.Eq.Def.html#1901" class="Bound">z</a> <a id="2001" class="Symbol">(</a><a id="2002" href="Haskell.Law.Bool.html#4263" class="Function">&amp;&amp;-rightTrue</a> <a id="2015" class="Symbol">(</a><a id="2016" href="Haskell.Law.Eq.Def.html#1897" class="Bound">x</a> <a id="2018" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="2021" href="Haskell.Law.Eq.Def.html#1899" class="Bound">y</a><a id="2022" class="Symbol">)</a> <a id="2024" class="Symbol">(</a><a id="2025" href="Haskell.Law.Eq.Def.html#1899" class="Bound">y</a> <a id="2027" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="2030" href="Haskell.Law.Eq.Def.html#1901" class="Bound">z</a><a id="2031" class="Symbol">)</a> <a id="2033" href="Haskell.Law.Eq.Def.html#1903" class="Bound">h</a><a id="2034" class="Symbol">)))</a>

<a id="2039" class="Comment">-- Extensionality: if x == y = True and f is a function whose return type is an instance of Eq, then f x == f y = True</a>
<a id="eqExtensionality"></a><a id="2158" href="Haskell.Law.Eq.Def.html#2158" class="Function">eqExtensionality</a> <a id="2175" class="Symbol">:</a> <a id="2177" class="Symbol">⦃</a> <a id="2179" href="Haskell.Law.Eq.Def.html#2179" class="Bound">iEq</a> <a id="2183" class="Symbol">:</a> <a id="2185" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="2188" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="2190" class="Symbol">⦄</a> <a id="2192" class="Symbol">→</a> <a id="2194" class="Symbol">⦃</a> <a id="2196" href="Haskell.Law.Eq.Def.html#289" class="Record">IsLawfulEq</a> <a id="2207" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="2209" class="Symbol">⦄</a>
                 <a id="2228" class="Symbol">→</a> <a id="2230" class="Symbol">⦃</a> <a id="2232" href="Haskell.Law.Eq.Def.html#2232" class="Bound">iEq</a> <a id="2236" class="Symbol">:</a> <a id="2238" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="2241" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="2243" class="Symbol">⦄</a> <a id="2245" class="Symbol">→</a> <a id="2247" class="Symbol">⦃</a> <a id="2249" href="Haskell.Law.Eq.Def.html#2249" class="Bound">iLawfulEq</a> <a id="2259" class="Symbol">:</a> <a id="2261" href="Haskell.Law.Eq.Def.html#289" class="Record">IsLawfulEq</a> <a id="2272" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="2274" class="Symbol">⦄</a>
                 <a id="2293" class="Symbol">→</a> <a id="2295" class="Symbol">∀</a> <a id="2297" class="Symbol">(</a> <a id="2299" href="Haskell.Law.Eq.Def.html#2299" class="Bound">x</a> <a id="2301" href="Haskell.Law.Eq.Def.html#2301" class="Bound">y</a> <a id="2303" class="Symbol">:</a> <a id="2305" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="2307" class="Symbol">)</a> <a id="2309" class="Symbol">(</a> <a id="2311" href="Haskell.Law.Eq.Def.html#2311" class="Bound">f</a> <a id="2313" class="Symbol">:</a> <a id="2315" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="2317" class="Symbol">→</a> <a id="2319" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="2321" class="Symbol">)</a> <a id="2323" class="Symbol">→</a> <a id="2325" class="Symbol">(</a><a id="2326" href="Haskell.Law.Eq.Def.html#2299" class="Bound">x</a> <a id="2328" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="2331" href="Haskell.Law.Eq.Def.html#2301" class="Bound">y</a><a id="2332" class="Symbol">)</a> <a id="2334" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2336" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="2341" class="Symbol">→</a> <a id="2343" class="Symbol">(</a><a id="2344" href="Haskell.Law.Eq.Def.html#2311" class="Bound">f</a> <a id="2346" href="Haskell.Law.Eq.Def.html#2299" class="Bound">x</a> <a id="2348" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="2351" href="Haskell.Law.Eq.Def.html#2311" class="Bound">f</a> <a id="2353" href="Haskell.Law.Eq.Def.html#2301" class="Bound">y</a><a id="2354" class="Symbol">)</a> <a id="2356" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2358" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="2363" href="Haskell.Law.Eq.Def.html#2158" class="Function">eqExtensionality</a> <a id="2380" href="Haskell.Law.Eq.Def.html#2380" class="Bound">x</a> <a id="2382" href="Haskell.Law.Eq.Def.html#2382" class="Bound">y</a> <a id="2384" href="Haskell.Law.Eq.Def.html#2384" class="Bound">f</a> <a id="2386" href="Haskell.Law.Eq.Def.html#2386" class="Bound">h</a> <a id="2388" class="Symbol">=</a> <a id="2390" href="Haskell.Law.Eq.Def.html#663" class="Function">equality&#39;</a> <a id="2400" class="Symbol">(</a><a id="2401" href="Haskell.Law.Eq.Def.html#2384" class="Bound">f</a> <a id="2403" href="Haskell.Law.Eq.Def.html#2380" class="Bound">x</a><a id="2404" class="Symbol">)</a> <a id="2406" class="Symbol">(</a><a id="2407" href="Haskell.Law.Eq.Def.html#2384" class="Bound">f</a> <a id="2409" href="Haskell.Law.Eq.Def.html#2382" class="Bound">y</a><a id="2410" class="Symbol">)</a> <a id="2412" class="Symbol">(</a><a id="2413" href="Haskell.Law.Equality.html#228" class="Function">cong</a> <a id="2418" href="Haskell.Law.Eq.Def.html#2384" class="Bound">f</a> <a id="2420" class="Symbol">(</a><a id="2421" href="Haskell.Law.Eq.Def.html#408" class="Function">equality</a> <a id="2430" href="Haskell.Law.Eq.Def.html#2380" class="Bound">x</a> <a id="2432" href="Haskell.Law.Eq.Def.html#2382" class="Bound">y</a> <a id="2434" href="Haskell.Law.Eq.Def.html#2386" class="Bound">h</a><a id="2435" class="Symbol">))</a>

<a id="2439" class="Comment">-- Negation: x /= y = not (x == y)</a>
<a id="eqNegation"></a><a id="2474" href="Haskell.Law.Eq.Def.html#2474" class="Function">eqNegation</a> <a id="2485" class="Symbol">:</a> <a id="2487" class="Symbol">⦃</a> <a id="2489" href="Haskell.Law.Eq.Def.html#2489" class="Bound">iEq</a> <a id="2493" class="Symbol">:</a> <a id="2495" href="Haskell.Prim.Eq.html#401" class="Record">Eq</a> <a id="2498" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="2500" class="Symbol">⦄</a> <a id="2502" class="Symbol">→</a> <a id="2504" class="Symbol">⦃</a> <a id="2506" href="Haskell.Law.Eq.Def.html#289" class="Record">IsLawfulEq</a> <a id="2517" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="2519" class="Symbol">⦄</a>
           <a id="2532" class="Symbol">→</a> <a id="2534" class="Symbol">∀</a> <a id="2536" class="Symbol">{</a> <a id="2538" href="Haskell.Law.Eq.Def.html#2538" class="Bound">x</a> <a id="2540" href="Haskell.Law.Eq.Def.html#2540" class="Bound">y</a> <a id="2542" class="Symbol">:</a> <a id="2544" href="Haskell.Prim.html#1222" class="Generalizable">e</a> <a id="2546" class="Symbol">}</a> <a id="2548" class="Symbol">→</a> <a id="2550" class="Symbol">(</a><a id="2551" href="Haskell.Law.Eq.Def.html#2538" class="Bound">x</a> <a id="2553" href="Haskell.Prim.Eq.html#541" class="Function Operator">/=</a> <a id="2556" href="Haskell.Law.Eq.Def.html#2540" class="Bound">y</a><a id="2557" class="Symbol">)</a> <a id="2559" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2561" href="Haskell.Prim.Bool.html#273" class="Function">not</a> <a id="2565" class="Symbol">(</a><a id="2566" href="Haskell.Law.Eq.Def.html#2538" class="Bound">x</a> <a id="2568" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="2571" href="Haskell.Law.Eq.Def.html#2540" class="Bound">y</a><a id="2572" class="Symbol">)</a>
<a id="2574" href="Haskell.Law.Eq.Def.html#2474" class="Function">eqNegation</a> <a id="2585" class="Symbol">=</a> <a id="2587" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

</pre></body></html>
<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Haskell.Law.Ord.Def</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="Haskell.Law.Ord.Def.html" class="Module">Haskell.Law.Ord.Def</a> <a id="28" class="Keyword">where</a>

<a id="35" class="Keyword">open</a> <a id="40" class="Keyword">import</a> <a id="47" href="Haskell.Prim.html" class="Module">Haskell.Prim</a>
<a id="60" class="Keyword">open</a> <a id="65" class="Keyword">import</a> <a id="72" href="Haskell.Prim.Ord.html" class="Module">Haskell.Prim.Ord</a>
<a id="89" class="Keyword">open</a> <a id="94" class="Keyword">import</a> <a id="101" href="Haskell.Prim.Bool.html" class="Module">Haskell.Prim.Bool</a>
<a id="119" class="Keyword">open</a> <a id="124" class="Keyword">import</a> <a id="131" href="Haskell.Prim.Int.html" class="Module">Haskell.Prim.Int</a>
<a id="148" class="Keyword">open</a> <a id="153" class="Keyword">import</a> <a id="160" href="Haskell.Prim.Word.html" class="Module">Haskell.Prim.Word</a>
<a id="178" class="Keyword">open</a> <a id="183" class="Keyword">import</a> <a id="190" href="Haskell.Prim.Integer.html" class="Module">Haskell.Prim.Integer</a>
<a id="211" class="Keyword">open</a> <a id="216" class="Keyword">import</a> <a id="223" href="Haskell.Prim.Double.html" class="Module">Haskell.Prim.Double</a>
<a id="243" class="Keyword">open</a> <a id="248" class="Keyword">import</a> <a id="255" href="Haskell.Prim.Tuple.html" class="Module">Haskell.Prim.Tuple</a>
<a id="274" class="Keyword">open</a> <a id="279" class="Keyword">import</a> <a id="286" href="Haskell.Prim.Monoid.html" class="Module">Haskell.Prim.Monoid</a>
<a id="306" class="Keyword">open</a> <a id="311" class="Keyword">import</a> <a id="318" href="Haskell.Prim.List.html" class="Module">Haskell.Prim.List</a>
<a id="336" class="Keyword">open</a> <a id="341" class="Keyword">import</a> <a id="348" href="Haskell.Prim.Maybe.html" class="Module">Haskell.Prim.Maybe</a>
<a id="367" class="Keyword">open</a> <a id="372" class="Keyword">import</a> <a id="379" href="Haskell.Prim.Either.html" class="Module">Haskell.Prim.Either</a>

<a id="400" class="Keyword">open</a> <a id="405" class="Keyword">import</a> <a id="412" href="Haskell.Prim.Eq.html" class="Module">Haskell.Prim.Eq</a>
<a id="428" class="Keyword">open</a> <a id="433" class="Keyword">import</a> <a id="440" href="Haskell.Law.Eq.html" class="Module">Haskell.Law.Eq</a>

<a id="456" class="Keyword">open</a> <a id="461" class="Keyword">import</a> <a id="468" href="Haskell.Law.Bool.html" class="Module">Haskell.Law.Bool</a>
<a id="485" class="Keyword">open</a> <a id="490" class="Keyword">import</a> <a id="497" href="Haskell.Law.Equality.html" class="Module">Haskell.Law.Equality</a>

<a id="519" class="Keyword">record</a> <a id="IsLawfulOrd"></a><a id="526" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="538" class="Symbol">(</a><a id="539" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a> <a id="541" class="Symbol">:</a> <a id="543" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="547" class="Symbol">)</a> <a id="549" class="Symbol">⦃</a> <a id="551" href="Haskell.Law.Ord.Def.html#551" class="Bound">iOrd</a> <a id="556" class="Symbol">:</a> <a id="558" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="562" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a> <a id="564" class="Symbol">⦄</a> <a id="566" class="Symbol">:</a> <a id="568" href="Agda.Primitive.html#388" class="Primitive">Type₁</a> <a id="574" class="Keyword">where</a>
  <a id="582" class="Keyword">field</a>
    <a id="592" class="Keyword">overlap</a> <a id="600" class="Symbol">⦃</a> <a id="IsLawfulOrd.super"></a><a id="602" href="Haskell.Law.Ord.Def.html#602" class="Field">super</a> <a id="608" class="Symbol">⦄</a> <a id="610" class="Symbol">:</a> <a id="612" href="Haskell.Law.Eq.Def.html#289" class="Record">IsLawfulEq</a> <a id="623" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a>

    <a id="630" class="Comment">-- Comparability: x &lt;= y || y &lt;= x = True</a>
    <a id="IsLawfulOrd.comparability"></a><a id="676" href="Haskell.Law.Ord.Def.html#676" class="Field">comparability</a> <a id="690" class="Symbol">:</a> <a id="692" class="Symbol">∀</a> <a id="694" class="Symbol">(</a><a id="695" href="Haskell.Law.Ord.Def.html#695" class="Bound">x</a> <a id="697" href="Haskell.Law.Ord.Def.html#697" class="Bound">y</a> <a id="699" class="Symbol">:</a> <a id="701" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="702" class="Symbol">)</a> <a id="704" class="Symbol">→</a> <a id="706" class="Symbol">(</a><a id="707" href="Haskell.Law.Ord.Def.html#695" class="Bound">x</a> <a id="709" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="712" href="Haskell.Law.Ord.Def.html#697" class="Bound">y</a> <a id="714" href="Haskell.Prim.Bool.html#213" class="Function Operator">||</a> <a id="717" href="Haskell.Law.Ord.Def.html#697" class="Bound">y</a> <a id="719" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="722" href="Haskell.Law.Ord.Def.html#695" class="Bound">x</a><a id="723" class="Symbol">)</a> <a id="725" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="727" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

    <a id="737" class="Comment">-- Transitivity: if x &lt;= y &amp;&amp; y &lt;= z = True, then x &lt;= z = True</a>
    <a id="IsLawfulOrd.transitivity"></a><a id="805" href="Haskell.Law.Ord.Def.html#805" class="Field">transitivity</a> <a id="818" class="Symbol">:</a>  <a id="821" class="Symbol">∀</a> <a id="823" class="Symbol">(</a> <a id="825" href="Haskell.Law.Ord.Def.html#825" class="Bound">x</a> <a id="827" href="Haskell.Law.Ord.Def.html#827" class="Bound">y</a> <a id="829" href="Haskell.Law.Ord.Def.html#829" class="Bound">z</a> <a id="831" class="Symbol">:</a> <a id="833" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a> <a id="835" class="Symbol">)</a> <a id="837" class="Symbol">→</a> <a id="839" class="Symbol">((</a><a id="841" href="Haskell.Law.Ord.Def.html#825" class="Bound">x</a> <a id="843" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="846" href="Haskell.Law.Ord.Def.html#827" class="Bound">y</a><a id="847" class="Symbol">)</a> <a id="849" href="Haskell.Prim.Bool.html#138" class="Function Operator">&amp;&amp;</a> <a id="852" class="Symbol">(</a><a id="853" href="Haskell.Law.Ord.Def.html#827" class="Bound">y</a> <a id="855" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="858" href="Haskell.Law.Ord.Def.html#829" class="Bound">z</a><a id="859" class="Symbol">))</a> <a id="862" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="864" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="869" class="Symbol">→</a> <a id="871" class="Symbol">(</a><a id="872" href="Haskell.Law.Ord.Def.html#825" class="Bound">x</a> <a id="874" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="877" href="Haskell.Law.Ord.Def.html#829" class="Bound">z</a><a id="878" class="Symbol">)</a> <a id="880" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="882" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

    <a id="892" class="Comment">-- Reflexivity: x &lt;= x = True</a>
    <a id="IsLawfulOrd.reflexivity"></a><a id="926" href="Haskell.Law.Ord.Def.html#926" class="Field">reflexivity</a> <a id="938" class="Symbol">:</a> <a id="940" class="Symbol">∀</a> <a id="942" class="Symbol">(</a><a id="943" href="Haskell.Law.Ord.Def.html#943" class="Bound">x</a> <a id="945" class="Symbol">:</a> <a id="947" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="948" class="Symbol">)</a> <a id="950" class="Symbol">→</a> <a id="952" class="Symbol">(</a><a id="953" href="Haskell.Law.Ord.Def.html#943" class="Bound">x</a> <a id="955" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="958" href="Haskell.Law.Ord.Def.html#943" class="Bound">x</a><a id="959" class="Symbol">)</a> <a id="961" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="963" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

    <a id="973" class="Comment">-- Antisymmetry: if x &lt;= y &amp;&amp; y &lt;= x = True, then x == y = True</a>
    <a id="IsLawfulOrd.antisymmetry"></a><a id="1041" href="Haskell.Law.Ord.Def.html#1041" class="Field">antisymmetry</a> <a id="1054" class="Symbol">:</a> <a id="1056" class="Symbol">∀</a> <a id="1058" class="Symbol">(</a><a id="1059" href="Haskell.Law.Ord.Def.html#1059" class="Bound">x</a> <a id="1061" href="Haskell.Law.Ord.Def.html#1061" class="Bound">y</a> <a id="1063" class="Symbol">:</a> <a id="1065" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1066" class="Symbol">)</a> <a id="1068" class="Symbol">→</a> <a id="1070" class="Symbol">((</a><a id="1072" href="Haskell.Law.Ord.Def.html#1059" class="Bound">x</a> <a id="1074" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="1077" href="Haskell.Law.Ord.Def.html#1061" class="Bound">y</a><a id="1078" class="Symbol">)</a> <a id="1080" href="Haskell.Prim.Bool.html#138" class="Function Operator">&amp;&amp;</a> <a id="1083" class="Symbol">(</a><a id="1084" href="Haskell.Law.Ord.Def.html#1061" class="Bound">y</a> <a id="1086" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="1089" href="Haskell.Law.Ord.Def.html#1059" class="Bound">x</a><a id="1090" class="Symbol">))</a> <a id="1093" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1095" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="1100" class="Symbol">→</a> <a id="1102" class="Symbol">(</a><a id="1103" href="Haskell.Law.Ord.Def.html#1059" class="Bound">x</a> <a id="1105" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1108" href="Haskell.Law.Ord.Def.html#1061" class="Bound">y</a><a id="1109" class="Symbol">)</a> <a id="1111" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1113" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

    <a id="1123" class="Comment">-- x &gt;= y = y &lt;= x</a>
    <a id="IsLawfulOrd.lte2gte"></a><a id="1146" href="Haskell.Law.Ord.Def.html#1146" class="Field">lte2gte</a> <a id="1154" class="Symbol">:</a> <a id="1156" class="Symbol">∀</a> <a id="1158" class="Symbol">(</a><a id="1159" href="Haskell.Law.Ord.Def.html#1159" class="Bound">x</a> <a id="1161" href="Haskell.Law.Ord.Def.html#1161" class="Bound">y</a> <a id="1163" class="Symbol">:</a> <a id="1165" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1166" class="Symbol">)</a> <a id="1168" class="Symbol">→</a> <a id="1170" class="Symbol">(</a><a id="1171" href="Haskell.Law.Ord.Def.html#1159" class="Bound">x</a> <a id="1173" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="1176" href="Haskell.Law.Ord.Def.html#1161" class="Bound">y</a><a id="1177" class="Symbol">)</a> <a id="1179" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1181" class="Symbol">(</a><a id="1182" href="Haskell.Law.Ord.Def.html#1161" class="Bound">y</a> <a id="1184" href="Haskell.Prim.Ord.html#1123" class="Field Operator">&gt;=</a> <a id="1187" href="Haskell.Law.Ord.Def.html#1159" class="Bound">x</a><a id="1188" class="Symbol">)</a>

    <a id="1195" class="Comment">-- x &lt; y = x &lt;= y &amp;&amp; x /= y</a>
    <a id="IsLawfulOrd.lt2LteNeq"></a><a id="1227" href="Haskell.Law.Ord.Def.html#1227" class="Field">lt2LteNeq</a> <a id="1237" class="Symbol">:</a> <a id="1239" class="Symbol">∀</a> <a id="1241" class="Symbol">(</a><a id="1242" href="Haskell.Law.Ord.Def.html#1242" class="Bound">x</a> <a id="1244" href="Haskell.Law.Ord.Def.html#1244" class="Bound">y</a> <a id="1246" class="Symbol">:</a> <a id="1248" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1249" class="Symbol">)</a> <a id="1251" class="Symbol">→</a> <a id="1253" class="Symbol">(</a><a id="1254" href="Haskell.Law.Ord.Def.html#1242" class="Bound">x</a> <a id="1256" href="Haskell.Prim.Ord.html#1075" class="Field Operator">&lt;</a> <a id="1258" href="Haskell.Law.Ord.Def.html#1244" class="Bound">y</a><a id="1259" class="Symbol">)</a> <a id="1261" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1263" class="Symbol">(</a><a id="1264" href="Haskell.Law.Ord.Def.html#1242" class="Bound">x</a> <a id="1266" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="1269" href="Haskell.Law.Ord.Def.html#1244" class="Bound">y</a> <a id="1271" href="Haskell.Prim.Bool.html#138" class="Function Operator">&amp;&amp;</a> <a id="1274" href="Haskell.Law.Ord.Def.html#1242" class="Bound">x</a> <a id="1276" href="Haskell.Prim.Eq.html#541" class="Function Operator">/=</a> <a id="1279" href="Haskell.Law.Ord.Def.html#1244" class="Bound">y</a><a id="1280" class="Symbol">)</a>

    <a id="1287" class="Comment">-- x &gt; y = y &lt; x</a>
    <a id="IsLawfulOrd.lt2gt"></a><a id="1308" href="Haskell.Law.Ord.Def.html#1308" class="Field">lt2gt</a> <a id="1314" class="Symbol">:</a> <a id="1316" class="Symbol">∀</a> <a id="1318" class="Symbol">(</a><a id="1319" href="Haskell.Law.Ord.Def.html#1319" class="Bound">x</a> <a id="1321" href="Haskell.Law.Ord.Def.html#1321" class="Bound">y</a> <a id="1323" class="Symbol">:</a> <a id="1325" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1326" class="Symbol">)</a> <a id="1328" class="Symbol">→</a> <a id="1330" class="Symbol">(</a><a id="1331" href="Haskell.Law.Ord.Def.html#1319" class="Bound">x</a> <a id="1333" href="Haskell.Prim.Ord.html#1075" class="Field Operator">&lt;</a> <a id="1335" href="Haskell.Law.Ord.Def.html#1321" class="Bound">y</a><a id="1336" class="Symbol">)</a> <a id="1338" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1340" class="Symbol">(</a><a id="1341" href="Haskell.Law.Ord.Def.html#1321" class="Bound">y</a> <a id="1343" href="Haskell.Prim.Ord.html#1099" class="Field Operator">&gt;</a> <a id="1345" href="Haskell.Law.Ord.Def.html#1319" class="Bound">x</a><a id="1346" class="Symbol">)</a>

    <a id="1353" class="Comment">-- x &lt; y = compare x y == LT</a>
    <a id="IsLawfulOrd.compareLt"></a><a id="1386" href="Haskell.Law.Ord.Def.html#1386" class="Field">compareLt</a> <a id="1396" class="Symbol">:</a> <a id="1398" class="Symbol">∀</a> <a id="1400" class="Symbol">(</a><a id="1401" href="Haskell.Law.Ord.Def.html#1401" class="Bound">x</a> <a id="1403" href="Haskell.Law.Ord.Def.html#1403" class="Bound">y</a> <a id="1405" class="Symbol">:</a> <a id="1407" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1408" class="Symbol">)</a> <a id="1410" class="Symbol">→</a> <a id="1412" class="Symbol">(</a><a id="1413" href="Haskell.Law.Ord.Def.html#1401" class="Bound">x</a> <a id="1415" href="Haskell.Prim.Ord.html#1075" class="Field Operator">&lt;</a> <a id="1417" href="Haskell.Law.Ord.Def.html#1403" class="Bound">y</a><a id="1418" class="Symbol">)</a> <a id="1420" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1422" class="Symbol">(</a><a id="1423" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="1431" href="Haskell.Law.Ord.Def.html#1401" class="Bound">x</a> <a id="1433" href="Haskell.Law.Ord.Def.html#1403" class="Bound">y</a> <a id="1435" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1438" href="Haskell.Prim.Ord.html#490" class="InductiveConstructor">LT</a><a id="1440" class="Symbol">)</a>

    <a id="1447" class="Comment">-- x &gt; y = compare x y == GT</a>
    <a id="IsLawfulOrd.compareGt"></a><a id="1480" href="Haskell.Law.Ord.Def.html#1480" class="Field">compareGt</a> <a id="1490" class="Symbol">:</a> <a id="1492" class="Symbol">∀</a> <a id="1494" class="Symbol">(</a><a id="1495" href="Haskell.Law.Ord.Def.html#1495" class="Bound">x</a> <a id="1497" href="Haskell.Law.Ord.Def.html#1497" class="Bound">y</a> <a id="1499" class="Symbol">:</a> <a id="1501" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1502" class="Symbol">)</a> <a id="1504" class="Symbol">→</a> <a id="1506" class="Symbol">(</a><a id="1507" href="Haskell.Law.Ord.Def.html#1495" class="Bound">x</a> <a id="1509" href="Haskell.Prim.Ord.html#1099" class="Field Operator">&gt;</a> <a id="1511" href="Haskell.Law.Ord.Def.html#1497" class="Bound">y</a><a id="1512" class="Symbol">)</a> <a id="1514" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1516" class="Symbol">(</a><a id="1517" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="1525" href="Haskell.Law.Ord.Def.html#1495" class="Bound">x</a> <a id="1527" href="Haskell.Law.Ord.Def.html#1497" class="Bound">y</a> <a id="1529" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1532" href="Haskell.Prim.Ord.html#496" class="InductiveConstructor">GT</a><a id="1534" class="Symbol">)</a>

    <a id="1541" class="Comment">-- x == y = compare x y == EQ</a>
    <a id="IsLawfulOrd.compareEq"></a><a id="1575" href="Haskell.Law.Ord.Def.html#1575" class="Field">compareEq</a> <a id="1585" class="Symbol">:</a> <a id="1587" class="Symbol">∀</a> <a id="1589" class="Symbol">(</a><a id="1590" href="Haskell.Law.Ord.Def.html#1590" class="Bound">x</a> <a id="1592" href="Haskell.Law.Ord.Def.html#1592" class="Bound">y</a> <a id="1594" class="Symbol">:</a> <a id="1596" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1597" class="Symbol">)</a> <a id="1599" class="Symbol">→</a> <a id="1601" class="Symbol">(</a><a id="1602" href="Haskell.Law.Ord.Def.html#1590" class="Bound">x</a> <a id="1604" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1607" href="Haskell.Law.Ord.Def.html#1592" class="Bound">y</a><a id="1608" class="Symbol">)</a> <a id="1610" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1612" class="Symbol">(</a><a id="1613" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="1621" href="Haskell.Law.Ord.Def.html#1590" class="Bound">x</a> <a id="1623" href="Haskell.Law.Ord.Def.html#1592" class="Bound">y</a> <a id="1625" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1628" href="Haskell.Prim.Ord.html#493" class="InductiveConstructor">EQ</a><a id="1630" class="Symbol">)</a>

    <a id="1637" class="Comment">-- min x y == if x &lt;= y then x else y = True</a>
    <a id="IsLawfulOrd.min2if"></a><a id="1686" href="Haskell.Law.Ord.Def.html#1686" class="Field">min2if</a> <a id="1693" class="Symbol">:</a> <a id="1695" class="Symbol">∀</a> <a id="1697" class="Symbol">(</a><a id="1698" href="Haskell.Law.Ord.Def.html#1698" class="Bound">x</a> <a id="1700" href="Haskell.Law.Ord.Def.html#1700" class="Bound">y</a> <a id="1702" class="Symbol">:</a> <a id="1704" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1705" class="Symbol">)</a> <a id="1707" class="Symbol">→</a> <a id="1709" class="Symbol">((</a><a id="1711" href="Haskell.Prim.Ord.html#1192" class="Field">min</a> <a id="1715" href="Haskell.Law.Ord.Def.html#1698" class="Bound">x</a> <a id="1717" href="Haskell.Law.Ord.Def.html#1700" class="Bound">y</a><a id="1718" class="Symbol">)</a> <a id="1720" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1723" class="Symbol">(</a><a id="1724" href="Haskell.Prim.html#1739" class="Function Operator">if</a> <a id="1727" class="Symbol">(</a><a id="1728" href="Haskell.Law.Ord.Def.html#1698" class="Bound">x</a> <a id="1730" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="1733" href="Haskell.Law.Ord.Def.html#1700" class="Bound">y</a><a id="1734" class="Symbol">)</a> <a id="1736" href="Haskell.Prim.html#1739" class="Function Operator">then</a> <a id="1741" href="Haskell.Law.Ord.Def.html#1698" class="Bound">x</a> <a id="1743" href="Haskell.Prim.html#1739" class="Function Operator">else</a> <a id="1748" href="Haskell.Law.Ord.Def.html#1700" class="Bound">y</a><a id="1749" class="Symbol">))</a> <a id="1752" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1754" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

    <a id="1764" class="Comment">-- max x y == if x &gt;= y then x else y = True</a>
    <a id="IsLawfulOrd.max2if"></a><a id="1813" href="Haskell.Law.Ord.Def.html#1813" class="Field">max2if</a> <a id="1820" class="Symbol">:</a> <a id="1822" class="Symbol">∀</a> <a id="1824" class="Symbol">(</a><a id="1825" href="Haskell.Law.Ord.Def.html#1825" class="Bound">x</a> <a id="1827" href="Haskell.Law.Ord.Def.html#1827" class="Bound">y</a> <a id="1829" class="Symbol">:</a> <a id="1831" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1832" class="Symbol">)</a> <a id="1834" class="Symbol">→</a> <a id="1836" class="Symbol">((</a><a id="1838" href="Haskell.Prim.Ord.html#1171" class="Field">max</a> <a id="1842" href="Haskell.Law.Ord.Def.html#1825" class="Bound">x</a> <a id="1844" href="Haskell.Law.Ord.Def.html#1827" class="Bound">y</a><a id="1845" class="Symbol">)</a> <a id="1847" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="1850" class="Symbol">(</a><a id="1851" href="Haskell.Prim.html#1739" class="Function Operator">if</a> <a id="1854" class="Symbol">(</a><a id="1855" href="Haskell.Law.Ord.Def.html#1825" class="Bound">x</a> <a id="1857" href="Haskell.Prim.Ord.html#1123" class="Field Operator">&gt;=</a> <a id="1860" href="Haskell.Law.Ord.Def.html#1827" class="Bound">y</a><a id="1861" class="Symbol">)</a> <a id="1863" href="Haskell.Prim.html#1739" class="Function Operator">then</a> <a id="1868" href="Haskell.Law.Ord.Def.html#1825" class="Bound">x</a> <a id="1870" href="Haskell.Prim.html#1739" class="Function Operator">else</a> <a id="1875" href="Haskell.Law.Ord.Def.html#1827" class="Bound">y</a><a id="1876" class="Symbol">))</a> <a id="1879" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1881" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

<a id="1887" class="Keyword">open</a> <a id="1892" href="Haskell.Law.Ord.Def.html#526" class="Module">IsLawfulOrd</a> <a id="1904" class="Symbol">⦃</a> <a id="1906" class="Symbol">...</a> <a id="1910" class="Symbol">⦄</a> <a id="1912" class="Keyword">public</a>

<a id="1920" class="Comment">--------------------------------------------------</a>
<a id="1971" class="Comment">-- Some more helper laws</a>

<a id="eq2nlt"></a><a id="1997" href="Haskell.Law.Ord.Def.html#1997" class="Function">eq2nlt</a> <a id="2004" class="Symbol">:</a> <a id="2006" class="Symbol">⦃</a> <a id="2008" href="Haskell.Law.Ord.Def.html#2008" class="Bound">iOrdA</a> <a id="2014" class="Symbol">:</a> <a id="2016" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="2020" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="2022" class="Symbol">⦄</a> <a id="2024" class="Symbol">→</a> <a id="2026" class="Symbol">⦃</a> <a id="2028" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="2040" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="2042" class="Symbol">⦄</a>
  <a id="2046" class="Symbol">→</a> <a id="2048" class="Symbol">∀</a> <a id="2050" class="Symbol">(</a><a id="2051" href="Haskell.Law.Ord.Def.html#2051" class="Bound">x</a> <a id="2053" href="Haskell.Law.Ord.Def.html#2053" class="Bound">y</a> <a id="2055" class="Symbol">:</a> <a id="2057" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="2058" class="Symbol">)</a> <a id="2060" class="Symbol">→</a> <a id="2062" class="Symbol">(</a><a id="2063" href="Haskell.Law.Ord.Def.html#2051" class="Bound">x</a> <a id="2065" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="2068" href="Haskell.Law.Ord.Def.html#2053" class="Bound">y</a><a id="2069" class="Symbol">)</a> <a id="2071" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2073" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="2078" class="Symbol">→</a> <a id="2080" class="Symbol">(</a><a id="2081" href="Haskell.Law.Ord.Def.html#2051" class="Bound">x</a> <a id="2083" href="Haskell.Prim.Ord.html#1075" class="Field Operator">&lt;</a> <a id="2085" href="Haskell.Law.Ord.Def.html#2053" class="Bound">y</a><a id="2086" class="Symbol">)</a> <a id="2088" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2090" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a>
<a id="2096" href="Haskell.Law.Ord.Def.html#1997" class="Function">eq2nlt</a> <a id="2103" href="Haskell.Law.Ord.Def.html#2103" class="Bound">x</a> <a id="2105" href="Haskell.Law.Ord.Def.html#2105" class="Bound">y</a> <a id="2107" href="Haskell.Law.Ord.Def.html#2107" class="Bound">h</a>
  <a id="2111" class="Keyword">rewrite</a> <a id="2119" href="Haskell.Law.Ord.Def.html#1575" class="Field">compareEq</a> <a id="2129" href="Haskell.Law.Ord.Def.html#2103" class="Bound">x</a> <a id="2131" href="Haskell.Law.Ord.Def.html#2105" class="Bound">y</a>
    <a id="2137" class="Symbol">|</a> <a id="2139" href="Haskell.Law.Ord.Def.html#1386" class="Field">compareLt</a> <a id="2149" href="Haskell.Law.Ord.Def.html#2103" class="Bound">x</a> <a id="2151" href="Haskell.Law.Ord.Def.html#2105" class="Bound">y</a>
    <a id="2157" class="Symbol">|</a> <a id="2159" href="Haskell.Law.Eq.Def.html#408" class="Function">equality</a> <a id="2168" class="Symbol">(</a><a id="2169" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="2177" href="Haskell.Law.Ord.Def.html#2103" class="Bound">x</a> <a id="2179" href="Haskell.Law.Ord.Def.html#2105" class="Bound">y</a><a id="2180" class="Symbol">)</a> <a id="2182" href="Haskell.Prim.Ord.html#493" class="InductiveConstructor">EQ</a> <a id="2185" href="Haskell.Law.Ord.Def.html#2107" class="Bound">h</a>
  <a id="2189" class="Symbol">=</a> <a id="2191" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="eq2ngt"></a><a id="2197" href="Haskell.Law.Ord.Def.html#2197" class="Function">eq2ngt</a> <a id="2204" class="Symbol">:</a> <a id="2206" class="Symbol">⦃</a> <a id="2208" href="Haskell.Law.Ord.Def.html#2208" class="Bound">iOrdA</a> <a id="2214" class="Symbol">:</a> <a id="2216" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="2220" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="2222" class="Symbol">⦄</a> <a id="2224" class="Symbol">→</a> <a id="2226" class="Symbol">⦃</a> <a id="2228" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="2240" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="2242" class="Symbol">⦄</a>
  <a id="2246" class="Symbol">→</a> <a id="2248" class="Symbol">∀</a> <a id="2250" class="Symbol">(</a><a id="2251" href="Haskell.Law.Ord.Def.html#2251" class="Bound">x</a> <a id="2253" href="Haskell.Law.Ord.Def.html#2253" class="Bound">y</a> <a id="2255" class="Symbol">:</a> <a id="2257" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="2258" class="Symbol">)</a> <a id="2260" class="Symbol">→</a> <a id="2262" class="Symbol">(</a><a id="2263" href="Haskell.Law.Ord.Def.html#2251" class="Bound">x</a> <a id="2265" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="2268" href="Haskell.Law.Ord.Def.html#2253" class="Bound">y</a><a id="2269" class="Symbol">)</a> <a id="2271" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2273" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="2278" class="Symbol">→</a> <a id="2280" class="Symbol">(</a><a id="2281" href="Haskell.Law.Ord.Def.html#2251" class="Bound">x</a> <a id="2283" href="Haskell.Prim.Ord.html#1099" class="Field Operator">&gt;</a> <a id="2285" href="Haskell.Law.Ord.Def.html#2253" class="Bound">y</a><a id="2286" class="Symbol">)</a> <a id="2288" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2290" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a>
<a id="2296" href="Haskell.Law.Ord.Def.html#2197" class="Function">eq2ngt</a> <a id="2303" href="Haskell.Law.Ord.Def.html#2303" class="Bound">x</a> <a id="2305" href="Haskell.Law.Ord.Def.html#2305" class="Bound">y</a> <a id="2307" href="Haskell.Law.Ord.Def.html#2307" class="Bound">h</a>
  <a id="2311" class="Keyword">rewrite</a> <a id="2319" href="Haskell.Law.Ord.Def.html#1575" class="Field">compareEq</a> <a id="2329" href="Haskell.Law.Ord.Def.html#2303" class="Bound">x</a> <a id="2331" href="Haskell.Law.Ord.Def.html#2305" class="Bound">y</a>
    <a id="2337" class="Symbol">|</a> <a id="2339" href="Haskell.Law.Ord.Def.html#1480" class="Field">compareGt</a> <a id="2349" href="Haskell.Law.Ord.Def.html#2303" class="Bound">x</a> <a id="2351" href="Haskell.Law.Ord.Def.html#2305" class="Bound">y</a>
    <a id="2357" class="Symbol">|</a> <a id="2359" href="Haskell.Law.Eq.Def.html#408" class="Function">equality</a> <a id="2368" class="Symbol">(</a><a id="2369" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="2377" href="Haskell.Law.Ord.Def.html#2303" class="Bound">x</a> <a id="2379" href="Haskell.Law.Ord.Def.html#2305" class="Bound">y</a><a id="2380" class="Symbol">)</a> <a id="2382" href="Haskell.Prim.Ord.html#493" class="InductiveConstructor">EQ</a> <a id="2385" href="Haskell.Law.Ord.Def.html#2307" class="Bound">h</a>
  <a id="2389" class="Symbol">=</a> <a id="2391" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lte2LtEq"></a><a id="2397" href="Haskell.Law.Ord.Def.html#2397" class="Function">lte2LtEq</a> <a id="2406" class="Symbol">:</a> <a id="2408" class="Symbol">⦃</a> <a id="2410" href="Haskell.Law.Ord.Def.html#2410" class="Bound">iOrdA</a> <a id="2416" class="Symbol">:</a> <a id="2418" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="2422" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="2424" class="Symbol">⦄</a> <a id="2426" class="Symbol">→</a> <a id="2428" class="Symbol">⦃</a> <a id="2430" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="2442" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="2444" class="Symbol">⦄</a>
  <a id="2448" class="Symbol">→</a> <a id="2450" class="Symbol">∀</a> <a id="2452" class="Symbol">(</a><a id="2453" href="Haskell.Law.Ord.Def.html#2453" class="Bound">x</a> <a id="2455" href="Haskell.Law.Ord.Def.html#2455" class="Bound">y</a> <a id="2457" class="Symbol">:</a> <a id="2459" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="2460" class="Symbol">)</a> <a id="2462" class="Symbol">→</a> <a id="2464" class="Symbol">(</a><a id="2465" href="Haskell.Law.Ord.Def.html#2453" class="Bound">x</a> <a id="2467" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="2470" href="Haskell.Law.Ord.Def.html#2455" class="Bound">y</a><a id="2471" class="Symbol">)</a> <a id="2473" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2475" class="Symbol">(</a><a id="2476" href="Haskell.Law.Ord.Def.html#2453" class="Bound">x</a> <a id="2478" href="Haskell.Prim.Ord.html#1075" class="Field Operator">&lt;</a> <a id="2480" href="Haskell.Law.Ord.Def.html#2455" class="Bound">y</a> <a id="2482" href="Haskell.Prim.Bool.html#213" class="Function Operator">||</a> <a id="2485" href="Haskell.Law.Ord.Def.html#2453" class="Bound">x</a> <a id="2487" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="2490" href="Haskell.Law.Ord.Def.html#2455" class="Bound">y</a><a id="2491" class="Symbol">)</a>
<a id="2493" href="Haskell.Law.Ord.Def.html#2397" class="Function">lte2LtEq</a> <a id="2502" href="Haskell.Law.Ord.Def.html#2502" class="Bound">x</a> <a id="2504" href="Haskell.Law.Ord.Def.html#2504" class="Bound">y</a> 
  <a id="2509" class="Keyword">rewrite</a> <a id="2517" href="Haskell.Law.Ord.Def.html#1227" class="Field">lt2LteNeq</a> <a id="2527" href="Haskell.Law.Ord.Def.html#2502" class="Bound">x</a> <a id="2529" href="Haskell.Law.Ord.Def.html#2504" class="Bound">y</a>
    <a id="2535" class="Symbol">|</a> <a id="2537" href="Haskell.Law.Ord.Def.html#1575" class="Field">compareEq</a> <a id="2547" href="Haskell.Law.Ord.Def.html#2502" class="Bound">x</a> <a id="2549" href="Haskell.Law.Ord.Def.html#2504" class="Bound">y</a>
  <a id="2553" class="Keyword">with</a> <a id="2558" class="Symbol">(</a><a id="2559" href="Haskell.Law.Ord.Def.html#2502" class="Bound">x</a> <a id="2561" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="2564" href="Haskell.Law.Ord.Def.html#2504" class="Bound">y</a><a id="2565" class="Symbol">)</a> <a id="2567" class="Keyword">in</a> <a id="2570" class="Argument">h₁</a> <a id="2573" class="Symbol">|</a> <a id="2575" class="Symbol">(</a><a id="2576" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="2584" href="Haskell.Law.Ord.Def.html#2502" class="Bound">x</a> <a id="2586" href="Haskell.Law.Ord.Def.html#2504" class="Bound">y</a><a id="2587" class="Symbol">)</a> <a id="2589" class="Keyword">in</a> <a id="2592" class="Argument">h₂</a>
<a id="2595" class="Symbol">...</a> <a id="2599" class="Symbol">|</a> <a id="2601" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="2607" class="Symbol">|</a> <a id="2609" href="Haskell.Prim.Ord.html#490" class="InductiveConstructor">LT</a> <a id="2612" class="Symbol">=</a> <a id="2614" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="2619" class="Symbol">...</a> <a id="2623" class="Symbol">|</a> <a id="2625" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="2631" class="Symbol">|</a> <a id="2633" href="Haskell.Prim.Ord.html#493" class="InductiveConstructor">EQ</a> <a id="2636" class="Symbol">=</a> <a id="2638" href="Haskell.Prim.html#2640" class="Function">magic</a> <a id="2644" href="Haskell.Prim.html#1506" class="Function Operator">$</a> <a id="2646" href="Haskell.Prim.html#2702" class="Function">exFalso</a> <a id="2654" class="Symbol">(</a><a id="2655" href="Haskell.Law.Ord.Def.html#926" class="Field">reflexivity</a> <a id="2667" class="Bound">x</a><a id="2668" class="Symbol">)</a> <a id="2670" href="Haskell.Prim.html#1506" class="Function Operator">$</a> <a id="2672" href="Haskell.Law.Equality.html#897" class="Function Operator">begin</a> 
    <a id="2683" class="Symbol">(</a><a id="2684" class="Bound">x</a> <a id="2686" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="2689" class="Bound">x</a><a id="2690" class="Symbol">)</a>  <a id="2693" href="Haskell.Law.Equality.html#1006" class="Function">≡⟨</a> <a id="2696" class="Symbol">(</a><a id="2697" href="Haskell.Law.Equality.html#228" class="Function">cong</a> <a id="2702" class="Symbol">(</a><a id="2703" class="Bound">x</a> <a id="2705" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=_</a><a id="2708" class="Symbol">)</a> <a id="2710" class="Symbol">(</a><a id="2711" href="Haskell.Law.Eq.Def.html#408" class="Function">equality</a> <a id="2720" class="Bound">x</a> <a id="2722" class="Bound">y</a> <a id="2724" class="Symbol">(</a><a id="2725" href="Haskell.Law.Equality.html#897" class="Function Operator">begin</a> 
      <a id="2738" class="Symbol">(</a><a id="2739" class="Bound">x</a> <a id="2741" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="2744" class="Bound">y</a><a id="2745" class="Symbol">)</a>            <a id="2758" href="Haskell.Law.Equality.html#1006" class="Function">≡⟨</a> <a id="2761" href="Haskell.Law.Ord.Def.html#1575" class="Field">compareEq</a> <a id="2771" class="Bound">x</a> <a id="2773" class="Bound">y</a> <a id="2775" href="Haskell.Law.Equality.html#1006" class="Function">⟩</a> 
      <a id="2784" class="Symbol">(</a><a id="2785" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="2793" class="Bound">x</a> <a id="2795" class="Bound">y</a> <a id="2797" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="2800" href="Haskell.Prim.Ord.html#493" class="InductiveConstructor">EQ</a><a id="2802" class="Symbol">)</a> <a id="2804" href="Haskell.Law.Equality.html#1006" class="Function">≡⟨</a> <a id="2807" href="Haskell.Law.Eq.Def.html#663" class="Function">equality&#39;</a> <a id="2817" class="Symbol">(</a><a id="2818" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="2826" class="Bound">x</a> <a id="2828" class="Bound">y</a><a id="2829" class="Symbol">)</a> <a id="2831" href="Haskell.Prim.Ord.html#493" class="InductiveConstructor">EQ</a> <a id="2834" href="Haskell.Law.Ord.Def.html#2592" class="Bound">h₂</a> <a id="2837" href="Haskell.Law.Equality.html#1006" class="Function">⟩</a> 
      <a id="2846" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>                <a id="2866" href="Haskell.Law.Equality.html#1180" class="Function Operator">∎</a> <a id="2868" class="Symbol">)</a> <a id="2870" class="Symbol">)</a> <a id="2872" class="Symbol">)</a> <a id="2874" href="Haskell.Law.Equality.html#1006" class="Function">⟩</a>
    <a id="2880" class="Symbol">(</a><a id="2881" class="Bound">x</a> <a id="2883" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="2886" class="Bound">y</a><a id="2887" class="Symbol">)</a>  <a id="2890" href="Haskell.Law.Equality.html#1006" class="Function">≡⟨</a> <a id="2893" href="Haskell.Law.Ord.Def.html#2570" class="Bound">h₁</a> <a id="2896" href="Haskell.Law.Equality.html#1006" class="Function">⟩</a> 
    <a id="2903" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="2909" href="Haskell.Law.Equality.html#1180" class="Function Operator">∎</a>
<a id="2911" class="Symbol">...</a> <a id="2915" class="Symbol">|</a> <a id="2917" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="2923" class="Symbol">|</a> <a id="2925" href="Haskell.Prim.Ord.html#496" class="InductiveConstructor">GT</a> <a id="2928" class="Symbol">=</a> <a id="2930" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="2935" class="Symbol">...</a> <a id="2939" class="Symbol">|</a> <a id="2941" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="2947" class="Symbol">|</a> <a id="2949" href="Haskell.Prim.Ord.html#490" class="InductiveConstructor">LT</a> <a id="2952" class="Symbol">=</a> <a id="2954" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="2959" class="Symbol">...</a> <a id="2963" class="Symbol">|</a> <a id="2965" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="2971" class="Symbol">|</a> <a id="2973" href="Haskell.Prim.Ord.html#493" class="InductiveConstructor">EQ</a> <a id="2976" class="Symbol">=</a> <a id="2978" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="2983" class="Symbol">...</a> <a id="2987" class="Symbol">|</a> <a id="2989" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="2995" class="Symbol">|</a> <a id="2997" href="Haskell.Prim.Ord.html#496" class="InductiveConstructor">GT</a> <a id="3000" class="Symbol">=</a> <a id="3002" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="gte2GtEq"></a><a id="3008" href="Haskell.Law.Ord.Def.html#3008" class="Function">gte2GtEq</a> <a id="3017" class="Symbol">:</a> <a id="3019" class="Symbol">⦃</a> <a id="3021" href="Haskell.Law.Ord.Def.html#3021" class="Bound">iOrdA</a> <a id="3027" class="Symbol">:</a> <a id="3029" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="3033" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="3035" class="Symbol">⦄</a> <a id="3037" class="Symbol">→</a> <a id="3039" class="Symbol">⦃</a> <a id="3041" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="3053" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="3055" class="Symbol">⦄</a>
  <a id="3059" class="Symbol">→</a> <a id="3061" class="Symbol">∀</a> <a id="3063" class="Symbol">(</a><a id="3064" href="Haskell.Law.Ord.Def.html#3064" class="Bound">x</a> <a id="3066" href="Haskell.Law.Ord.Def.html#3066" class="Bound">y</a> <a id="3068" class="Symbol">:</a> <a id="3070" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="3071" class="Symbol">)</a> <a id="3073" class="Symbol">→</a> <a id="3075" class="Symbol">(</a><a id="3076" href="Haskell.Law.Ord.Def.html#3064" class="Bound">x</a> <a id="3078" href="Haskell.Prim.Ord.html#1123" class="Field Operator">&gt;=</a> <a id="3081" href="Haskell.Law.Ord.Def.html#3066" class="Bound">y</a><a id="3082" class="Symbol">)</a> <a id="3084" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3086" class="Symbol">(</a><a id="3087" href="Haskell.Law.Ord.Def.html#3064" class="Bound">x</a> <a id="3089" href="Haskell.Prim.Ord.html#1099" class="Field Operator">&gt;</a> <a id="3091" href="Haskell.Law.Ord.Def.html#3066" class="Bound">y</a> <a id="3093" href="Haskell.Prim.Bool.html#213" class="Function Operator">||</a> <a id="3096" href="Haskell.Law.Ord.Def.html#3064" class="Bound">x</a> <a id="3098" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="3101" href="Haskell.Law.Ord.Def.html#3066" class="Bound">y</a><a id="3102" class="Symbol">)</a>
<a id="3104" href="Haskell.Law.Ord.Def.html#3008" class="Function">gte2GtEq</a> <a id="3113" href="Haskell.Law.Ord.Def.html#3113" class="Bound">x</a> <a id="3115" href="Haskell.Law.Ord.Def.html#3115" class="Bound">y</a>
  <a id="3119" class="Keyword">rewrite</a> <a id="3127" href="Haskell.Law.Equality.html#404" class="Function">sym</a> <a id="3131" href="Haskell.Prim.html#1506" class="Function Operator">$</a> <a id="3133" href="Haskell.Law.Ord.Def.html#1146" class="Field">lte2gte</a> <a id="3141" href="Haskell.Law.Ord.Def.html#3115" class="Bound">y</a> <a id="3143" href="Haskell.Law.Ord.Def.html#3113" class="Bound">x</a>
    <a id="3149" class="Symbol">|</a> <a id="3151" href="Haskell.Law.Ord.Def.html#2397" class="Function">lte2LtEq</a> <a id="3160" href="Haskell.Law.Ord.Def.html#3115" class="Bound">y</a> <a id="3162" href="Haskell.Law.Ord.Def.html#3113" class="Bound">x</a>
    <a id="3168" class="Symbol">|</a> <a id="3170" href="Haskell.Law.Eq.Def.html#1428" class="Function">eqSymmetry</a> <a id="3181" href="Haskell.Law.Ord.Def.html#3115" class="Bound">y</a> <a id="3183" href="Haskell.Law.Ord.Def.html#3113" class="Bound">x</a>
    <a id="3189" class="Symbol">|</a> <a id="3191" href="Haskell.Law.Ord.Def.html#1308" class="Field">lt2gt</a> <a id="3197" href="Haskell.Law.Ord.Def.html#3115" class="Bound">y</a> <a id="3199" href="Haskell.Law.Ord.Def.html#3113" class="Bound">x</a>
  <a id="3203" class="Symbol">=</a> <a id="3205" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="gte2nlt"></a><a id="3211" href="Haskell.Law.Ord.Def.html#3211" class="Function">gte2nlt</a> <a id="3219" class="Symbol">:</a> <a id="3221" class="Symbol">⦃</a> <a id="3223" href="Haskell.Law.Ord.Def.html#3223" class="Bound">iOrdA</a> <a id="3229" class="Symbol">:</a> <a id="3231" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="3235" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="3237" class="Symbol">⦄</a> <a id="3239" class="Symbol">→</a> <a id="3241" class="Symbol">⦃</a> <a id="3243" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="3255" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="3257" class="Symbol">⦄</a>
  <a id="3261" class="Symbol">→</a> <a id="3263" class="Symbol">∀</a> <a id="3265" class="Symbol">(</a><a id="3266" href="Haskell.Law.Ord.Def.html#3266" class="Bound">x</a> <a id="3268" href="Haskell.Law.Ord.Def.html#3268" class="Bound">y</a> <a id="3270" class="Symbol">:</a> <a id="3272" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="3273" class="Symbol">)</a> <a id="3275" class="Symbol">→</a> <a id="3277" class="Symbol">(</a><a id="3278" href="Haskell.Law.Ord.Def.html#3266" class="Bound">x</a> <a id="3280" href="Haskell.Prim.Ord.html#1123" class="Field Operator">&gt;=</a> <a id="3283" href="Haskell.Law.Ord.Def.html#3268" class="Bound">y</a><a id="3284" class="Symbol">)</a> <a id="3286" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3288" href="Haskell.Prim.Bool.html#273" class="Function">not</a> <a id="3292" class="Symbol">(</a><a id="3293" href="Haskell.Law.Ord.Def.html#3266" class="Bound">x</a> <a id="3295" href="Haskell.Prim.Ord.html#1075" class="Field Operator">&lt;</a> <a id="3297" href="Haskell.Law.Ord.Def.html#3268" class="Bound">y</a><a id="3298" class="Symbol">)</a>
<a id="3300" href="Haskell.Law.Ord.Def.html#3211" class="Function">gte2nlt</a> <a id="3308" href="Haskell.Law.Ord.Def.html#3308" class="Bound">x</a> <a id="3310" href="Haskell.Law.Ord.Def.html#3310" class="Bound">y</a>
  <a id="3314" class="Keyword">rewrite</a> <a id="3322" href="Haskell.Law.Ord.Def.html#3008" class="Function">gte2GtEq</a> <a id="3331" href="Haskell.Law.Ord.Def.html#3308" class="Bound">x</a> <a id="3333" href="Haskell.Law.Ord.Def.html#3310" class="Bound">y</a>
    <a id="3339" class="Symbol">|</a> <a id="3341" href="Haskell.Law.Ord.Def.html#1480" class="Field">compareGt</a> <a id="3351" href="Haskell.Law.Ord.Def.html#3308" class="Bound">x</a> <a id="3353" href="Haskell.Law.Ord.Def.html#3310" class="Bound">y</a>
    <a id="3359" class="Symbol">|</a> <a id="3361" href="Haskell.Law.Ord.Def.html#1575" class="Field">compareEq</a> <a id="3371" href="Haskell.Law.Ord.Def.html#3308" class="Bound">x</a> <a id="3373" href="Haskell.Law.Ord.Def.html#3310" class="Bound">y</a>
    <a id="3379" class="Symbol">|</a> <a id="3381" href="Haskell.Law.Ord.Def.html#1386" class="Field">compareLt</a> <a id="3391" href="Haskell.Law.Ord.Def.html#3308" class="Bound">x</a> <a id="3393" href="Haskell.Law.Ord.Def.html#3310" class="Bound">y</a>
  <a id="3397" class="Keyword">with</a> <a id="3402" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="3410" href="Haskell.Law.Ord.Def.html#3308" class="Bound">x</a> <a id="3412" href="Haskell.Law.Ord.Def.html#3310" class="Bound">y</a>
<a id="3414" class="Symbol">...</a> <a id="3418" class="Symbol">|</a> <a id="3420" href="Haskell.Prim.Ord.html#496" class="InductiveConstructor">GT</a> <a id="3423" class="Symbol">=</a> <a id="3425" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 
<a id="3431" class="Symbol">...</a> <a id="3435" class="Symbol">|</a> <a id="3437" href="Haskell.Prim.Ord.html#493" class="InductiveConstructor">EQ</a> <a id="3440" class="Symbol">=</a> <a id="3442" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 
<a id="3448" class="Symbol">...</a> <a id="3452" class="Symbol">|</a> <a id="3454" href="Haskell.Prim.Ord.html#490" class="InductiveConstructor">LT</a> <a id="3457" class="Symbol">=</a> <a id="3459" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 

<a id="gte2nLT"></a><a id="3466" href="Haskell.Law.Ord.Def.html#3466" class="Function">gte2nLT</a> <a id="3474" class="Symbol">:</a> <a id="3476" class="Symbol">⦃</a> <a id="3478" href="Haskell.Law.Ord.Def.html#3478" class="Bound">iOrdA</a> <a id="3484" class="Symbol">:</a> <a id="3486" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="3490" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="3492" class="Symbol">⦄</a> <a id="3494" class="Symbol">→</a> <a id="3496" class="Symbol">⦃</a> <a id="3498" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="3510" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="3512" class="Symbol">⦄</a>
  <a id="3516" class="Symbol">→</a> <a id="3518" class="Symbol">∀</a> <a id="3520" class="Symbol">(</a><a id="3521" href="Haskell.Law.Ord.Def.html#3521" class="Bound">x</a> <a id="3523" href="Haskell.Law.Ord.Def.html#3523" class="Bound">y</a> <a id="3525" class="Symbol">:</a> <a id="3527" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="3528" class="Symbol">)</a> <a id="3530" class="Symbol">→</a> <a id="3532" class="Symbol">(</a><a id="3533" href="Haskell.Law.Ord.Def.html#3521" class="Bound">x</a> <a id="3535" href="Haskell.Prim.Ord.html#1123" class="Field Operator">&gt;=</a> <a id="3538" href="Haskell.Law.Ord.Def.html#3523" class="Bound">y</a><a id="3539" class="Symbol">)</a> <a id="3541" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3543" class="Symbol">(</a><a id="3544" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="3552" href="Haskell.Law.Ord.Def.html#3521" class="Bound">x</a> <a id="3554" href="Haskell.Law.Ord.Def.html#3523" class="Bound">y</a> <a id="3556" href="Haskell.Prim.Eq.html#541" class="Function Operator">/=</a> <a id="3559" href="Haskell.Prim.Ord.html#490" class="InductiveConstructor">LT</a><a id="3561" class="Symbol">)</a>
<a id="3563" href="Haskell.Law.Ord.Def.html#3466" class="Function">gte2nLT</a> <a id="3571" href="Haskell.Law.Ord.Def.html#3571" class="Bound">x</a> <a id="3573" href="Haskell.Law.Ord.Def.html#3573" class="Bound">y</a>
  <a id="3577" class="Keyword">rewrite</a> <a id="3585" href="Haskell.Law.Ord.Def.html#3211" class="Function">gte2nlt</a> <a id="3593" href="Haskell.Law.Ord.Def.html#3571" class="Bound">x</a> <a id="3595" href="Haskell.Law.Ord.Def.html#3573" class="Bound">y</a>
    <a id="3601" class="Symbol">|</a> <a id="3603" href="Haskell.Law.Ord.Def.html#1386" class="Field">compareLt</a> <a id="3613" href="Haskell.Law.Ord.Def.html#3571" class="Bound">x</a> <a id="3615" href="Haskell.Law.Ord.Def.html#3573" class="Bound">y</a>
  <a id="3619" class="Symbol">=</a> <a id="3621" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lte2ngt"></a><a id="3627" href="Haskell.Law.Ord.Def.html#3627" class="Function">lte2ngt</a> <a id="3635" class="Symbol">:</a> <a id="3637" class="Symbol">⦃</a> <a id="3639" href="Haskell.Law.Ord.Def.html#3639" class="Bound">iOrdA</a> <a id="3645" class="Symbol">:</a> <a id="3647" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="3651" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="3653" class="Symbol">⦄</a> <a id="3655" class="Symbol">→</a> <a id="3657" class="Symbol">⦃</a> <a id="3659" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="3671" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="3673" class="Symbol">⦄</a>
  <a id="3677" class="Symbol">→</a> <a id="3679" class="Symbol">∀</a> <a id="3681" class="Symbol">(</a><a id="3682" href="Haskell.Law.Ord.Def.html#3682" class="Bound">x</a> <a id="3684" href="Haskell.Law.Ord.Def.html#3684" class="Bound">y</a> <a id="3686" class="Symbol">:</a> <a id="3688" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="3689" class="Symbol">)</a> <a id="3691" class="Symbol">→</a> <a id="3693" class="Symbol">(</a><a id="3694" href="Haskell.Law.Ord.Def.html#3682" class="Bound">x</a> <a id="3696" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="3699" href="Haskell.Law.Ord.Def.html#3684" class="Bound">y</a><a id="3700" class="Symbol">)</a> <a id="3702" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3704" href="Haskell.Prim.Bool.html#273" class="Function">not</a> <a id="3708" class="Symbol">(</a><a id="3709" href="Haskell.Law.Ord.Def.html#3682" class="Bound">x</a> <a id="3711" href="Haskell.Prim.Ord.html#1099" class="Field Operator">&gt;</a> <a id="3713" href="Haskell.Law.Ord.Def.html#3684" class="Bound">y</a><a id="3714" class="Symbol">)</a>
<a id="3716" href="Haskell.Law.Ord.Def.html#3627" class="Function">lte2ngt</a> <a id="3724" href="Haskell.Law.Ord.Def.html#3724" class="Bound">x</a> <a id="3726" href="Haskell.Law.Ord.Def.html#3726" class="Bound">y</a>
  <a id="3730" class="Keyword">rewrite</a> <a id="3738" href="Haskell.Law.Ord.Def.html#2397" class="Function">lte2LtEq</a> <a id="3747" href="Haskell.Law.Ord.Def.html#3724" class="Bound">x</a> <a id="3749" href="Haskell.Law.Ord.Def.html#3726" class="Bound">y</a>
    <a id="3755" class="Symbol">|</a> <a id="3757" href="Haskell.Law.Ord.Def.html#1386" class="Field">compareLt</a> <a id="3767" href="Haskell.Law.Ord.Def.html#3724" class="Bound">x</a> <a id="3769" href="Haskell.Law.Ord.Def.html#3726" class="Bound">y</a>
    <a id="3775" class="Symbol">|</a> <a id="3777" href="Haskell.Law.Ord.Def.html#1575" class="Field">compareEq</a> <a id="3787" href="Haskell.Law.Ord.Def.html#3724" class="Bound">x</a> <a id="3789" href="Haskell.Law.Ord.Def.html#3726" class="Bound">y</a>
    <a id="3795" class="Symbol">|</a> <a id="3797" href="Haskell.Law.Ord.Def.html#1480" class="Field">compareGt</a> <a id="3807" href="Haskell.Law.Ord.Def.html#3724" class="Bound">x</a> <a id="3809" href="Haskell.Law.Ord.Def.html#3726" class="Bound">y</a>
  <a id="3813" class="Keyword">with</a> <a id="3818" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="3826" href="Haskell.Law.Ord.Def.html#3724" class="Bound">x</a> <a id="3828" href="Haskell.Law.Ord.Def.html#3726" class="Bound">y</a>
<a id="3830" class="Symbol">...</a> <a id="3834" class="Symbol">|</a> <a id="3836" href="Haskell.Prim.Ord.html#496" class="InductiveConstructor">GT</a> <a id="3839" class="Symbol">=</a> <a id="3841" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 
<a id="3847" class="Symbol">...</a> <a id="3851" class="Symbol">|</a> <a id="3853" href="Haskell.Prim.Ord.html#493" class="InductiveConstructor">EQ</a> <a id="3856" class="Symbol">=</a> <a id="3858" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 
<a id="3864" class="Symbol">...</a> <a id="3868" class="Symbol">|</a> <a id="3870" href="Haskell.Prim.Ord.html#490" class="InductiveConstructor">LT</a> <a id="3873" class="Symbol">=</a> <a id="3875" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 

<a id="lte2nGT"></a><a id="3882" href="Haskell.Law.Ord.Def.html#3882" class="Function">lte2nGT</a> <a id="3890" class="Symbol">:</a> <a id="3892" class="Symbol">⦃</a> <a id="3894" href="Haskell.Law.Ord.Def.html#3894" class="Bound">iOrdA</a> <a id="3900" class="Symbol">:</a> <a id="3902" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="3906" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="3908" class="Symbol">⦄</a> <a id="3910" class="Symbol">→</a> <a id="3912" class="Symbol">⦃</a> <a id="3914" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="3926" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="3928" class="Symbol">⦄</a>
  <a id="3932" class="Symbol">→</a> <a id="3934" class="Symbol">∀</a> <a id="3936" class="Symbol">(</a><a id="3937" href="Haskell.Law.Ord.Def.html#3937" class="Bound">x</a> <a id="3939" href="Haskell.Law.Ord.Def.html#3939" class="Bound">y</a> <a id="3941" class="Symbol">:</a> <a id="3943" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="3944" class="Symbol">)</a> <a id="3946" class="Symbol">→</a> <a id="3948" class="Symbol">(</a><a id="3949" href="Haskell.Law.Ord.Def.html#3937" class="Bound">x</a> <a id="3951" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="3954" href="Haskell.Law.Ord.Def.html#3939" class="Bound">y</a><a id="3955" class="Symbol">)</a> <a id="3957" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3959" class="Symbol">(</a><a id="3960" href="Haskell.Prim.Ord.html#1044" class="Field">compare</a> <a id="3968" href="Haskell.Law.Ord.Def.html#3937" class="Bound">x</a> <a id="3970" href="Haskell.Law.Ord.Def.html#3939" class="Bound">y</a> <a id="3972" href="Haskell.Prim.Eq.html#541" class="Function Operator">/=</a> <a id="3975" href="Haskell.Prim.Ord.html#496" class="InductiveConstructor">GT</a><a id="3977" class="Symbol">)</a>
<a id="3979" href="Haskell.Law.Ord.Def.html#3882" class="Function">lte2nGT</a> <a id="3987" href="Haskell.Law.Ord.Def.html#3987" class="Bound">x</a> <a id="3989" href="Haskell.Law.Ord.Def.html#3989" class="Bound">y</a>
  <a id="3993" class="Keyword">rewrite</a> <a id="4001" href="Haskell.Law.Ord.Def.html#3627" class="Function">lte2ngt</a> <a id="4009" href="Haskell.Law.Ord.Def.html#3987" class="Bound">x</a> <a id="4011" href="Haskell.Law.Ord.Def.html#3989" class="Bound">y</a>
    <a id="4017" class="Symbol">|</a> <a id="4019" href="Haskell.Law.Ord.Def.html#1480" class="Field">compareGt</a> <a id="4029" href="Haskell.Law.Ord.Def.html#3987" class="Bound">x</a> <a id="4031" href="Haskell.Law.Ord.Def.html#3989" class="Bound">y</a>
  <a id="4035" class="Symbol">=</a> <a id="4037" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="eq2lte"></a><a id="4043" href="Haskell.Law.Ord.Def.html#4043" class="Function">eq2lte</a> <a id="4050" class="Symbol">:</a> <a id="4052" class="Symbol">⦃</a> <a id="4054" href="Haskell.Law.Ord.Def.html#4054" class="Bound">iOrdA</a> <a id="4060" class="Symbol">:</a> <a id="4062" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="4066" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="4068" class="Symbol">⦄</a> <a id="4070" class="Symbol">→</a> <a id="4072" class="Symbol">⦃</a> <a id="4074" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4086" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="4088" class="Symbol">⦄</a>
  <a id="4092" class="Symbol">→</a> <a id="4094" class="Symbol">∀</a> <a id="4096" class="Symbol">(</a><a id="4097" href="Haskell.Law.Ord.Def.html#4097" class="Bound">x</a> <a id="4099" href="Haskell.Law.Ord.Def.html#4099" class="Bound">y</a> <a id="4101" class="Symbol">:</a> <a id="4103" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="4104" class="Symbol">)</a> <a id="4106" class="Symbol">→</a> <a id="4108" class="Symbol">(</a><a id="4109" href="Haskell.Law.Ord.Def.html#4097" class="Bound">x</a> <a id="4111" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="4114" href="Haskell.Law.Ord.Def.html#4099" class="Bound">y</a><a id="4115" class="Symbol">)</a> <a id="4117" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4119" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="4124" class="Symbol">→</a> <a id="4126" class="Symbol">(</a><a id="4127" href="Haskell.Law.Ord.Def.html#4097" class="Bound">x</a> <a id="4129" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="4132" href="Haskell.Law.Ord.Def.html#4099" class="Bound">y</a><a id="4133" class="Symbol">)</a> <a id="4135" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4137" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="4142" href="Haskell.Law.Ord.Def.html#4043" class="Function">eq2lte</a> <a id="4149" href="Haskell.Law.Ord.Def.html#4149" class="Bound">x</a> <a id="4151" href="Haskell.Law.Ord.Def.html#4151" class="Bound">y</a> <a id="4153" href="Haskell.Law.Ord.Def.html#4153" class="Bound">h</a>
  <a id="4157" class="Keyword">rewrite</a> <a id="4165" href="Haskell.Law.Ord.Def.html#3627" class="Function">lte2ngt</a> <a id="4173" href="Haskell.Law.Ord.Def.html#4149" class="Bound">x</a> <a id="4175" href="Haskell.Law.Ord.Def.html#4151" class="Bound">y</a>
    <a id="4181" class="Symbol">|</a> <a id="4183" href="Haskell.Law.Ord.Def.html#2197" class="Function">eq2ngt</a> <a id="4190" href="Haskell.Law.Ord.Def.html#4149" class="Bound">x</a> <a id="4192" href="Haskell.Law.Ord.Def.html#4151" class="Bound">y</a> <a id="4194" href="Haskell.Law.Ord.Def.html#4153" class="Bound">h</a>
  <a id="4198" class="Symbol">=</a> <a id="4200" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lt2lte"></a><a id="4206" href="Haskell.Law.Ord.Def.html#4206" class="Function">lt2lte</a> <a id="4213" class="Symbol">:</a> <a id="4215" class="Symbol">⦃</a> <a id="4217" href="Haskell.Law.Ord.Def.html#4217" class="Bound">iOrdA</a> <a id="4223" class="Symbol">:</a> <a id="4225" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="4229" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="4231" class="Symbol">⦄</a> <a id="4233" class="Symbol">→</a> <a id="4235" class="Symbol">⦃</a> <a id="4237" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4249" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="4251" class="Symbol">⦄</a>
  <a id="4255" class="Symbol">→</a> <a id="4257" class="Symbol">∀</a> <a id="4259" class="Symbol">(</a><a id="4260" href="Haskell.Law.Ord.Def.html#4260" class="Bound">x</a> <a id="4262" href="Haskell.Law.Ord.Def.html#4262" class="Bound">y</a> <a id="4264" class="Symbol">:</a> <a id="4266" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="4267" class="Symbol">)</a> <a id="4269" class="Symbol">→</a> <a id="4271" class="Symbol">(</a><a id="4272" href="Haskell.Law.Ord.Def.html#4260" class="Bound">x</a> <a id="4274" href="Haskell.Prim.Ord.html#1075" class="Field Operator">&lt;</a> <a id="4276" href="Haskell.Law.Ord.Def.html#4262" class="Bound">y</a><a id="4277" class="Symbol">)</a> <a id="4279" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4281" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="4286" class="Symbol">→</a> <a id="4288" class="Symbol">(</a><a id="4289" href="Haskell.Law.Ord.Def.html#4260" class="Bound">x</a> <a id="4291" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="4294" href="Haskell.Law.Ord.Def.html#4262" class="Bound">y</a><a id="4295" class="Symbol">)</a> <a id="4297" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4299" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="4304" href="Haskell.Law.Ord.Def.html#4206" class="Function">lt2lte</a> <a id="4311" href="Haskell.Law.Ord.Def.html#4311" class="Bound">x</a> <a id="4313" href="Haskell.Law.Ord.Def.html#4313" class="Bound">y</a> <a id="4315" href="Haskell.Law.Ord.Def.html#4315" class="Bound">h</a> <a id="4317" class="Symbol">=</a> <a id="4319" href="Haskell.Law.Bool.html#4355" class="Function">&amp;&amp;-rightTrue&#39;</a> <a id="4333" class="Symbol">(</a><a id="4334" href="Haskell.Law.Ord.Def.html#4311" class="Bound">x</a> <a id="4336" href="Haskell.Prim.Ord.html#1075" class="Field Operator">&lt;</a> <a id="4338" href="Haskell.Law.Ord.Def.html#4313" class="Bound">y</a><a id="4339" class="Symbol">)</a> <a id="4341" class="Symbol">(</a><a id="4342" href="Haskell.Law.Ord.Def.html#4311" class="Bound">x</a> <a id="4344" href="Haskell.Prim.Ord.html#1147" class="Field Operator">&lt;=</a> <a id="4347" href="Haskell.Law.Ord.Def.html#4313" class="Bound">y</a><a id="4348" class="Symbol">)</a> <a id="4350" class="Symbol">(</a><a id="4351" href="Haskell.Law.Ord.Def.html#4311" class="Bound">x</a> <a id="4353" href="Haskell.Prim.Eq.html#541" class="Function Operator">/=</a> <a id="4356" href="Haskell.Law.Ord.Def.html#4313" class="Bound">y</a><a id="4357" class="Symbol">)</a> <a id="4359" class="Symbol">(</a><a id="4360" href="Haskell.Law.Ord.Def.html#1227" class="Field">lt2LteNeq</a> <a id="4370" href="Haskell.Law.Ord.Def.html#4311" class="Bound">x</a> <a id="4372" href="Haskell.Law.Ord.Def.html#4313" class="Bound">y</a><a id="4373" class="Symbol">)</a> <a id="4375" href="Haskell.Law.Ord.Def.html#4315" class="Bound">h</a>

<a id="eq2gte"></a><a id="4378" href="Haskell.Law.Ord.Def.html#4378" class="Function">eq2gte</a> <a id="4385" class="Symbol">:</a> <a id="4387" class="Symbol">⦃</a> <a id="4389" href="Haskell.Law.Ord.Def.html#4389" class="Bound">iOrdA</a> <a id="4395" class="Symbol">:</a> <a id="4397" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="4401" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="4403" class="Symbol">⦄</a> <a id="4405" class="Symbol">→</a> <a id="4407" class="Symbol">⦃</a> <a id="4409" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4421" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="4423" class="Symbol">⦄</a>
  <a id="4427" class="Symbol">→</a> <a id="4429" class="Symbol">∀</a> <a id="4431" class="Symbol">(</a><a id="4432" href="Haskell.Law.Ord.Def.html#4432" class="Bound">x</a> <a id="4434" href="Haskell.Law.Ord.Def.html#4434" class="Bound">y</a> <a id="4436" class="Symbol">:</a> <a id="4438" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="4439" class="Symbol">)</a> <a id="4441" class="Symbol">→</a> <a id="4443" class="Symbol">(</a><a id="4444" href="Haskell.Law.Ord.Def.html#4432" class="Bound">x</a> <a id="4446" href="Haskell.Prim.Eq.html#455" class="Field Operator">==</a> <a id="4449" href="Haskell.Law.Ord.Def.html#4434" class="Bound">y</a><a id="4450" class="Symbol">)</a> <a id="4452" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4454" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="4459" class="Symbol">→</a> <a id="4461" class="Symbol">(</a><a id="4462" href="Haskell.Law.Ord.Def.html#4432" class="Bound">x</a> <a id="4464" href="Haskell.Prim.Ord.html#1123" class="Field Operator">&gt;=</a> <a id="4467" href="Haskell.Law.Ord.Def.html#4434" class="Bound">y</a><a id="4468" class="Symbol">)</a> <a id="4470" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4472" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="4477" href="Haskell.Law.Ord.Def.html#4378" class="Function">eq2gte</a> <a id="4484" href="Haskell.Law.Ord.Def.html#4484" class="Bound">x</a> <a id="4486" href="Haskell.Law.Ord.Def.html#4486" class="Bound">y</a> <a id="4488" href="Haskell.Law.Ord.Def.html#4488" class="Bound">h</a>
  <a id="4492" class="Keyword">rewrite</a> <a id="4500" href="Haskell.Law.Ord.Def.html#3211" class="Function">gte2nlt</a> <a id="4508" href="Haskell.Law.Ord.Def.html#4484" class="Bound">x</a> <a id="4510" href="Haskell.Law.Ord.Def.html#4486" class="Bound">y</a>
    <a id="4516" class="Symbol">|</a> <a id="4518" href="Haskell.Law.Ord.Def.html#1997" class="Function">eq2nlt</a> <a id="4525" href="Haskell.Law.Ord.Def.html#4484" class="Bound">x</a> <a id="4527" href="Haskell.Law.Ord.Def.html#4486" class="Bound">y</a> <a id="4529" href="Haskell.Law.Ord.Def.html#4488" class="Bound">h</a>
  <a id="4533" class="Symbol">=</a> <a id="4535" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="gt2gte"></a><a id="4541" href="Haskell.Law.Ord.Def.html#4541" class="Function">gt2gte</a> <a id="4548" class="Symbol">:</a> <a id="4550" class="Symbol">⦃</a> <a id="4552" href="Haskell.Law.Ord.Def.html#4552" class="Bound">iOrdA</a> <a id="4558" class="Symbol">:</a> <a id="4560" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="4564" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="4566" class="Symbol">⦄</a> <a id="4568" class="Symbol">→</a> <a id="4570" class="Symbol">⦃</a> <a id="4572" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4584" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="4586" class="Symbol">⦄</a>
  <a id="4590" class="Symbol">→</a> <a id="4592" class="Symbol">∀</a> <a id="4594" class="Symbol">(</a><a id="4595" href="Haskell.Law.Ord.Def.html#4595" class="Bound">x</a> <a id="4597" href="Haskell.Law.Ord.Def.html#4597" class="Bound">y</a> <a id="4599" class="Symbol">:</a> <a id="4601" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="4602" class="Symbol">)</a> <a id="4604" class="Symbol">→</a> <a id="4606" class="Symbol">(</a><a id="4607" href="Haskell.Law.Ord.Def.html#4595" class="Bound">x</a> <a id="4609" href="Haskell.Prim.Ord.html#1099" class="Field Operator">&gt;</a> <a id="4611" href="Haskell.Law.Ord.Def.html#4597" class="Bound">y</a><a id="4612" class="Symbol">)</a> <a id="4614" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4616" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="4621" class="Symbol">→</a> <a id="4623" class="Symbol">(</a><a id="4624" href="Haskell.Law.Ord.Def.html#4595" class="Bound">x</a> <a id="4626" href="Haskell.Prim.Ord.html#1123" class="Field Operator">&gt;=</a> <a id="4629" href="Haskell.Law.Ord.Def.html#4597" class="Bound">y</a><a id="4630" class="Symbol">)</a> <a id="4632" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4634" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="4639" href="Haskell.Law.Ord.Def.html#4541" class="Function">gt2gte</a> <a id="4646" href="Haskell.Law.Ord.Def.html#4646" class="Bound">x</a> <a id="4648" href="Haskell.Law.Ord.Def.html#4648" class="Bound">y</a> <a id="4650" href="Haskell.Law.Ord.Def.html#4650" class="Bound">h</a>
  <a id="4654" class="Keyword">rewrite</a> <a id="4662" href="Haskell.Law.Equality.html#404" class="Function">sym</a> <a id="4666" class="Symbol">(</a><a id="4667" href="Haskell.Law.Ord.Def.html#1308" class="Field">lt2gt</a> <a id="4673" href="Haskell.Law.Ord.Def.html#4648" class="Bound">y</a> <a id="4675" href="Haskell.Law.Ord.Def.html#4646" class="Bound">x</a><a id="4676" class="Symbol">)</a>
    <a id="4682" class="Symbol">|</a> <a id="4684" href="Haskell.Law.Equality.html#404" class="Function">sym</a> <a id="4688" class="Symbol">(</a><a id="4689" href="Haskell.Law.Ord.Def.html#4206" class="Function">lt2lte</a> <a id="4696" href="Haskell.Law.Ord.Def.html#4648" class="Bound">y</a> <a id="4698" href="Haskell.Law.Ord.Def.html#4646" class="Bound">x</a> <a id="4700" href="Haskell.Law.Ord.Def.html#4650" class="Bound">h</a><a id="4701" class="Symbol">)</a>
    <a id="4707" class="Symbol">|</a> <a id="4709" href="Haskell.Law.Ord.Def.html#1146" class="Field">lte2gte</a> <a id="4717" href="Haskell.Law.Ord.Def.html#4648" class="Bound">y</a> <a id="4719" href="Haskell.Law.Ord.Def.html#4646" class="Bound">x</a>
  <a id="4723" class="Symbol">=</a> <a id="4725" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="4731" class="Comment">--------------------------------------------------</a>
<a id="4782" class="Comment">-- Postulated instances</a>

<a id="4807" class="Keyword">postulate</a> <a id="4817" class="Keyword">instance</a>
  <a id="iLawfulOrdNat"></a><a id="4828" href="Haskell.Law.Ord.Def.html#4828" class="Postulate">iLawfulOrdNat</a> <a id="4842" class="Symbol">:</a> <a id="4844" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4856" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a>

  <a id="iLawfulOrdInteger"></a><a id="4863" href="Haskell.Law.Ord.Def.html#4863" class="Postulate">iLawfulOrdInteger</a> <a id="4881" class="Symbol">:</a> <a id="4883" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4895" href="Agda.Builtin.Int.html#245" class="Datatype">Integer</a>

  <a id="iLawfulOrdInt"></a><a id="4906" href="Haskell.Law.Ord.Def.html#4906" class="Postulate">iLawfulOrdInt</a> <a id="4920" class="Symbol">:</a> <a id="4922" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4934" href="Haskell.Prim.Int.html#367" class="Datatype">Int</a>

  <a id="iLawfulOrdWord"></a><a id="4941" href="Haskell.Law.Ord.Def.html#4941" class="Postulate">iLawfulOrdWord</a> <a id="4956" class="Symbol">:</a> <a id="4958" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4970" href="Agda.Builtin.Word.html#208" class="Postulate">Word</a>

  <a id="iLawfulOrdDouble"></a><a id="4978" href="Haskell.Law.Ord.Def.html#4978" class="Postulate">iLawfulOrdDouble</a> <a id="4995" class="Symbol">:</a> <a id="4997" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5009" href="Agda.Builtin.Float.html#353" class="Postulate">Double</a>

  <a id="iLawfulOrdChar"></a><a id="5019" href="Haskell.Law.Ord.Def.html#5019" class="Postulate">iLawfulOrdChar</a> <a id="5034" class="Symbol">:</a> <a id="5036" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5048" href="Agda.Builtin.Char.html#238" class="Postulate">Char</a>

  <a id="iLawfulOrdUnit"></a><a id="5056" href="Haskell.Law.Ord.Def.html#5056" class="Postulate">iLawfulOrdUnit</a> <a id="5071" class="Symbol">:</a> <a id="5073" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5085" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

  <a id="iLawfulOrdTuple₂"></a><a id="5090" href="Haskell.Law.Ord.Def.html#5090" class="Postulate">iLawfulOrdTuple₂</a> <a id="5107" class="Symbol">:</a> <a id="5109" class="Symbol">⦃</a> <a id="5111" href="Haskell.Law.Ord.Def.html#5111" class="Bound">iOrdA</a> <a id="5117" class="Symbol">:</a> <a id="5119" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="5123" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5125" class="Symbol">⦄</a> <a id="5127" class="Symbol">⦃</a> <a id="5129" href="Haskell.Law.Ord.Def.html#5129" class="Bound">iOrdB</a> <a id="5135" class="Symbol">:</a> <a id="5137" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="5141" href="Haskell.Prim.html#1216" class="Generalizable">b</a> <a id="5143" class="Symbol">⦄</a>
                   <a id="5164" class="Symbol">→</a> <a id="5166" class="Symbol">⦃</a> <a id="5168" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5180" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5182" class="Symbol">⦄</a> <a id="5184" class="Symbol">→</a> <a id="5186" class="Symbol">⦃</a> <a id="5188" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5200" href="Haskell.Prim.html#1216" class="Generalizable">b</a> <a id="5202" class="Symbol">⦄</a>
                   <a id="5223" class="Symbol">→</a> <a id="5225" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5237" class="Symbol">(</a><a id="5238" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5240" href="Haskell.Prim.Tuple.html#169" class="Record Operator">×</a> <a id="5242" href="Haskell.Prim.html#1216" class="Generalizable">b</a><a id="5243" class="Symbol">)</a>

  <a id="iLawfulOrdTuple₃"></a><a id="5248" href="Haskell.Law.Ord.Def.html#5248" class="Postulate">iLawfulOrdTuple₃</a> <a id="5265" class="Symbol">:</a> <a id="5267" class="Symbol">⦃</a> <a id="5269" href="Haskell.Law.Ord.Def.html#5269" class="Bound">iOrdA</a> <a id="5275" class="Symbol">:</a> <a id="5277" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="5281" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5283" class="Symbol">⦄</a> <a id="5285" class="Symbol">⦃</a> <a id="5287" href="Haskell.Law.Ord.Def.html#5287" class="Bound">iOrdB</a> <a id="5293" class="Symbol">:</a> <a id="5295" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="5299" href="Haskell.Prim.html#1216" class="Generalizable">b</a> <a id="5301" class="Symbol">⦄</a> <a id="5303" class="Symbol">⦃</a> <a id="5305" href="Haskell.Law.Ord.Def.html#5305" class="Bound">iOrdC</a> <a id="5311" class="Symbol">:</a> <a id="5313" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="5317" href="Haskell.Prim.html#1218" class="Generalizable">c</a> <a id="5319" class="Symbol">⦄</a>
                   <a id="5340" class="Symbol">→</a> <a id="5342" class="Symbol">⦃</a> <a id="5344" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5356" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5358" class="Symbol">⦄</a> <a id="5360" class="Symbol">→</a> <a id="5362" class="Symbol">⦃</a> <a id="5364" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5376" href="Haskell.Prim.html#1216" class="Generalizable">b</a> <a id="5378" class="Symbol">⦄</a> <a id="5380" class="Symbol">→</a> <a id="5382" class="Symbol">⦃</a> <a id="5384" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5396" href="Haskell.Prim.html#1218" class="Generalizable">c</a> <a id="5398" class="Symbol">⦄</a>
                   <a id="5419" class="Symbol">→</a> <a id="5421" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5433" class="Symbol">(</a><a id="5434" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5436" href="Haskell.Prim.Tuple.html#308" class="Record Operator">×</a> <a id="5438" href="Haskell.Prim.html#1216" class="Generalizable">b</a> <a id="5440" href="Haskell.Prim.Tuple.html#308" class="Record Operator">×</a> <a id="5442" href="Haskell.Prim.html#1218" class="Generalizable">c</a><a id="5443" class="Symbol">)</a>

  <a id="iLawfulOrdList"></a><a id="5448" href="Haskell.Law.Ord.Def.html#5448" class="Postulate">iLawfulOrdList</a> <a id="5463" class="Symbol">:</a> <a id="5465" class="Symbol">⦃</a> <a id="5467" href="Haskell.Law.Ord.Def.html#5467" class="Bound">iOrdA</a> <a id="5473" class="Symbol">:</a> <a id="5475" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="5479" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5481" class="Symbol">⦄</a> <a id="5483" class="Symbol">→</a> <a id="5485" class="Symbol">⦃</a> <a id="5487" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5499" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5501" class="Symbol">⦄</a> <a id="5503" class="Symbol">→</a> <a id="5505" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5517" class="Symbol">(</a><a id="5518" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5523" href="Haskell.Prim.html#1214" class="Generalizable">a</a><a id="5524" class="Symbol">)</a>

  <a id="iLawfulOrdEither"></a><a id="5529" href="Haskell.Law.Ord.Def.html#5529" class="Postulate">iLawfulOrdEither</a> <a id="5546" class="Symbol">:</a> <a id="5548" class="Symbol">⦃</a> <a id="5550" href="Haskell.Law.Ord.Def.html#5550" class="Bound">iOrdA</a> <a id="5556" class="Symbol">:</a> <a id="5558" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="5562" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5564" class="Symbol">⦄</a> <a id="5566" class="Symbol">→</a> <a id="5568" class="Symbol">⦃</a> <a id="5570" href="Haskell.Law.Ord.Def.html#5570" class="Bound">iOrdB</a> <a id="5576" class="Symbol">:</a> <a id="5578" href="Haskell.Prim.Ord.html#1004" class="Record">Ord</a> <a id="5582" href="Haskell.Prim.html#1216" class="Generalizable">b</a> <a id="5584" class="Symbol">⦄</a> <a id="5586" class="Symbol">→</a>  <a id="5589" class="Symbol">⦃</a> <a id="5591" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5603" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5605" class="Symbol">⦄</a> <a id="5607" class="Symbol">→</a> <a id="5609" class="Symbol">⦃</a> <a id="5611" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5623" href="Haskell.Prim.html#1216" class="Generalizable">b</a> <a id="5625" class="Symbol">⦄</a> <a id="5627" class="Symbol">→</a> <a id="5629" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5641" class="Symbol">(</a><a id="5642" href="Haskell.Prim.Either.html#159" class="Datatype">Either</a> <a id="5649" href="Haskell.Prim.html#1214" class="Generalizable">a</a> <a id="5651" href="Haskell.Prim.html#1216" class="Generalizable">b</a><a id="5652" class="Symbol">)</a>
</pre></body></html>
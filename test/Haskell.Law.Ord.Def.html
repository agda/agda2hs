<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Haskell.Law.Ord.Def</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="Haskell.Law.Ord.Def.html" class="Module">Haskell.Law.Ord.Def</a> <a id="28" class="Keyword">where</a>

<a id="35" class="Keyword">open</a> <a id="40" class="Keyword">import</a> <a id="47" href="Haskell.Prim.html" class="Module">Haskell.Prim</a>
<a id="60" class="Keyword">open</a> <a id="65" class="Keyword">import</a> <a id="72" href="Haskell.Prim.Ord.html" class="Module">Haskell.Prim.Ord</a>
<a id="89" class="Keyword">open</a> <a id="94" class="Keyword">import</a> <a id="101" href="Haskell.Prim.Bool.html" class="Module">Haskell.Prim.Bool</a>
<a id="119" class="Keyword">open</a> <a id="124" class="Keyword">import</a> <a id="131" href="Haskell.Prim.Int.html" class="Module">Haskell.Prim.Int</a>
<a id="148" class="Keyword">open</a> <a id="153" class="Keyword">import</a> <a id="160" href="Haskell.Prim.Word.html" class="Module">Haskell.Prim.Word</a>
<a id="178" class="Keyword">open</a> <a id="183" class="Keyword">import</a> <a id="190" href="Haskell.Prim.Integer.html" class="Module">Haskell.Prim.Integer</a>
<a id="211" class="Keyword">open</a> <a id="216" class="Keyword">import</a> <a id="223" href="Haskell.Prim.Double.html" class="Module">Haskell.Prim.Double</a>
<a id="243" class="Keyword">open</a> <a id="248" class="Keyword">import</a> <a id="255" href="Haskell.Prim.Tuple.html" class="Module">Haskell.Prim.Tuple</a>
<a id="274" class="Keyword">open</a> <a id="279" class="Keyword">import</a> <a id="286" href="Haskell.Prim.Monoid.html" class="Module">Haskell.Prim.Monoid</a>
<a id="306" class="Keyword">open</a> <a id="311" class="Keyword">import</a> <a id="318" href="Haskell.Prim.List.html" class="Module">Haskell.Prim.List</a>
<a id="336" class="Keyword">open</a> <a id="341" class="Keyword">import</a> <a id="348" href="Haskell.Prim.Maybe.html" class="Module">Haskell.Prim.Maybe</a>
<a id="367" class="Keyword">open</a> <a id="372" class="Keyword">import</a> <a id="379" href="Haskell.Prim.Either.html" class="Module">Haskell.Prim.Either</a>

<a id="400" class="Keyword">open</a> <a id="405" class="Keyword">import</a> <a id="412" href="Haskell.Prim.Eq.html" class="Module">Haskell.Prim.Eq</a>
<a id="428" class="Keyword">open</a> <a id="433" class="Keyword">import</a> <a id="440" href="Haskell.Law.Eq.html" class="Module">Haskell.Law.Eq</a>

<a id="456" class="Keyword">open</a> <a id="461" class="Keyword">import</a> <a id="468" href="Haskell.Law.Bool.html" class="Module">Haskell.Law.Bool</a>
<a id="485" class="Keyword">open</a> <a id="490" class="Keyword">import</a> <a id="497" href="Haskell.Law.Equality.html" class="Module">Haskell.Law.Equality</a>

<a id="519" class="Keyword">record</a> <a id="IsLawfulOrd"></a><a id="526" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="538" class="Symbol">(</a><a id="539" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a> <a id="541" class="Symbol">:</a> <a id="543" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="546" class="Symbol">)</a> <a id="548" class="Symbol">⦃</a> <a id="550" href="Haskell.Law.Ord.Def.html#550" class="Bound">iOrd</a> <a id="555" class="Symbol">:</a> <a id="557" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="561" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a> <a id="563" class="Symbol">⦄</a> <a id="565" class="Symbol">:</a> <a id="567" href="Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="572" class="Keyword">where</a>
  <a id="580" class="Keyword">field</a>
    <a id="590" class="Keyword">overlap</a> <a id="598" class="Symbol">⦃</a> <a id="IsLawfulOrd.super"></a><a id="600" href="Haskell.Law.Ord.Def.html#600" class="Field">super</a> <a id="606" class="Symbol">⦄</a> <a id="608" class="Symbol">:</a> <a id="610" href="Haskell.Law.Eq.Def.html#252" class="Record">IsLawfulEq</a> <a id="621" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a>

    <a id="628" class="Comment">-- Comparability: x &lt;= y || y &lt;= x = True</a>
    <a id="IsLawfulOrd.comparability"></a><a id="674" href="Haskell.Law.Ord.Def.html#674" class="Field">comparability</a> <a id="688" class="Symbol">:</a> <a id="690" class="Symbol">∀</a> <a id="692" class="Symbol">(</a><a id="693" href="Haskell.Law.Ord.Def.html#693" class="Bound">x</a> <a id="695" href="Haskell.Law.Ord.Def.html#695" class="Bound">y</a> <a id="697" class="Symbol">:</a> <a id="699" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="700" class="Symbol">)</a> <a id="702" class="Symbol">→</a> <a id="704" class="Symbol">(</a><a id="705" href="Haskell.Law.Ord.Def.html#693" class="Bound">x</a> <a id="707" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="710" href="Haskell.Law.Ord.Def.html#695" class="Bound">y</a> <a id="712" href="Haskell.Prim.Bool.html#213" class="Function Operator">||</a> <a id="715" href="Haskell.Law.Ord.Def.html#695" class="Bound">y</a> <a id="717" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="720" href="Haskell.Law.Ord.Def.html#693" class="Bound">x</a><a id="721" class="Symbol">)</a> <a id="723" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="725" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

    <a id="735" class="Comment">-- Transitivity: if x &lt;= y &amp;&amp; y &lt;= z = True, then x &lt;= z = True</a>
    <a id="IsLawfulOrd.transitivity"></a><a id="803" href="Haskell.Law.Ord.Def.html#803" class="Field">transitivity</a> <a id="816" class="Symbol">:</a>  <a id="819" class="Symbol">∀</a> <a id="821" class="Symbol">(</a> <a id="823" href="Haskell.Law.Ord.Def.html#823" class="Bound">x</a> <a id="825" href="Haskell.Law.Ord.Def.html#825" class="Bound">y</a> <a id="827" href="Haskell.Law.Ord.Def.html#827" class="Bound">z</a> <a id="829" class="Symbol">:</a> <a id="831" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a> <a id="833" class="Symbol">)</a> <a id="835" class="Symbol">→</a> <a id="837" class="Symbol">((</a><a id="839" href="Haskell.Law.Ord.Def.html#823" class="Bound">x</a> <a id="841" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="844" href="Haskell.Law.Ord.Def.html#825" class="Bound">y</a><a id="845" class="Symbol">)</a> <a id="847" href="Haskell.Prim.Bool.html#138" class="Function Operator">&amp;&amp;</a> <a id="850" class="Symbol">(</a><a id="851" href="Haskell.Law.Ord.Def.html#825" class="Bound">y</a> <a id="853" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="856" href="Haskell.Law.Ord.Def.html#827" class="Bound">z</a><a id="857" class="Symbol">))</a> <a id="860" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="862" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="867" class="Symbol">→</a> <a id="869" class="Symbol">(</a><a id="870" href="Haskell.Law.Ord.Def.html#823" class="Bound">x</a> <a id="872" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="875" href="Haskell.Law.Ord.Def.html#827" class="Bound">z</a><a id="876" class="Symbol">)</a> <a id="878" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="880" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

    <a id="890" class="Comment">-- Reflexivity: x &lt;= x = True</a>
    <a id="IsLawfulOrd.reflexivity"></a><a id="924" href="Haskell.Law.Ord.Def.html#924" class="Field">reflexivity</a> <a id="936" class="Symbol">:</a> <a id="938" class="Symbol">∀</a> <a id="940" class="Symbol">(</a><a id="941" href="Haskell.Law.Ord.Def.html#941" class="Bound">x</a> <a id="943" class="Symbol">:</a> <a id="945" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="946" class="Symbol">)</a> <a id="948" class="Symbol">→</a> <a id="950" class="Symbol">(</a><a id="951" href="Haskell.Law.Ord.Def.html#941" class="Bound">x</a> <a id="953" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="956" href="Haskell.Law.Ord.Def.html#941" class="Bound">x</a><a id="957" class="Symbol">)</a> <a id="959" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="961" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

    <a id="971" class="Comment">-- Antisymmetry: if x &lt;= y &amp;&amp; y &lt;= x = True, then x == y = True</a>
    <a id="IsLawfulOrd.antisymmetry"></a><a id="1039" href="Haskell.Law.Ord.Def.html#1039" class="Field">antisymmetry</a> <a id="1052" class="Symbol">:</a> <a id="1054" class="Symbol">∀</a> <a id="1056" class="Symbol">(</a><a id="1057" href="Haskell.Law.Ord.Def.html#1057" class="Bound">x</a> <a id="1059" href="Haskell.Law.Ord.Def.html#1059" class="Bound">y</a> <a id="1061" class="Symbol">:</a> <a id="1063" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1064" class="Symbol">)</a> <a id="1066" class="Symbol">→</a> <a id="1068" class="Symbol">((</a><a id="1070" href="Haskell.Law.Ord.Def.html#1057" class="Bound">x</a> <a id="1072" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="1075" href="Haskell.Law.Ord.Def.html#1059" class="Bound">y</a><a id="1076" class="Symbol">)</a> <a id="1078" href="Haskell.Prim.Bool.html#138" class="Function Operator">&amp;&amp;</a> <a id="1081" class="Symbol">(</a><a id="1082" href="Haskell.Law.Ord.Def.html#1059" class="Bound">y</a> <a id="1084" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="1087" href="Haskell.Law.Ord.Def.html#1057" class="Bound">x</a><a id="1088" class="Symbol">))</a> <a id="1091" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1093" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="1098" class="Symbol">→</a> <a id="1100" class="Symbol">(</a><a id="1101" href="Haskell.Law.Ord.Def.html#1057" class="Bound">x</a> <a id="1103" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="1106" href="Haskell.Law.Ord.Def.html#1059" class="Bound">y</a><a id="1107" class="Symbol">)</a> <a id="1109" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1111" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

    <a id="1121" class="Comment">-- x &gt;= y = y &lt;= x</a>
    <a id="IsLawfulOrd.lte2gte"></a><a id="1144" href="Haskell.Law.Ord.Def.html#1144" class="Field">lte2gte</a> <a id="1152" class="Symbol">:</a> <a id="1154" class="Symbol">∀</a> <a id="1156" class="Symbol">(</a><a id="1157" href="Haskell.Law.Ord.Def.html#1157" class="Bound">x</a> <a id="1159" href="Haskell.Law.Ord.Def.html#1159" class="Bound">y</a> <a id="1161" class="Symbol">:</a> <a id="1163" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1164" class="Symbol">)</a> <a id="1166" class="Symbol">→</a> <a id="1168" class="Symbol">(</a><a id="1169" href="Haskell.Law.Ord.Def.html#1157" class="Bound">x</a> <a id="1171" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="1174" href="Haskell.Law.Ord.Def.html#1159" class="Bound">y</a><a id="1175" class="Symbol">)</a> <a id="1177" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1179" class="Symbol">(</a><a id="1180" href="Haskell.Law.Ord.Def.html#1159" class="Bound">y</a> <a id="1182" href="Haskell.Prim.Ord.html#1120" class="Field Operator">&gt;=</a> <a id="1185" href="Haskell.Law.Ord.Def.html#1157" class="Bound">x</a><a id="1186" class="Symbol">)</a>

    <a id="1193" class="Comment">-- x &lt; y = x &lt;= y &amp;&amp; x /= y</a>
    <a id="IsLawfulOrd.lt2LteNeq"></a><a id="1225" href="Haskell.Law.Ord.Def.html#1225" class="Field">lt2LteNeq</a> <a id="1235" class="Symbol">:</a> <a id="1237" class="Symbol">∀</a> <a id="1239" class="Symbol">(</a><a id="1240" href="Haskell.Law.Ord.Def.html#1240" class="Bound">x</a> <a id="1242" href="Haskell.Law.Ord.Def.html#1242" class="Bound">y</a> <a id="1244" class="Symbol">:</a> <a id="1246" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1247" class="Symbol">)</a> <a id="1249" class="Symbol">→</a> <a id="1251" class="Symbol">(</a><a id="1252" href="Haskell.Law.Ord.Def.html#1240" class="Bound">x</a> <a id="1254" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="1256" href="Haskell.Law.Ord.Def.html#1242" class="Bound">y</a><a id="1257" class="Symbol">)</a> <a id="1259" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1261" class="Symbol">(</a><a id="1262" href="Haskell.Law.Ord.Def.html#1240" class="Bound">x</a> <a id="1264" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="1267" href="Haskell.Law.Ord.Def.html#1242" class="Bound">y</a> <a id="1269" href="Haskell.Prim.Bool.html#138" class="Function Operator">&amp;&amp;</a> <a id="1272" href="Haskell.Law.Ord.Def.html#1240" class="Bound">x</a> <a id="1274" href="Haskell.Prim.Eq.html#481" class="Function Operator">/=</a> <a id="1277" href="Haskell.Law.Ord.Def.html#1242" class="Bound">y</a><a id="1278" class="Symbol">)</a>

    <a id="1285" class="Comment">-- x &gt; y = y &lt; x</a>
    <a id="IsLawfulOrd.lt2gt"></a><a id="1306" href="Haskell.Law.Ord.Def.html#1306" class="Field">lt2gt</a> <a id="1312" class="Symbol">:</a> <a id="1314" class="Symbol">∀</a> <a id="1316" class="Symbol">(</a><a id="1317" href="Haskell.Law.Ord.Def.html#1317" class="Bound">x</a> <a id="1319" href="Haskell.Law.Ord.Def.html#1319" class="Bound">y</a> <a id="1321" class="Symbol">:</a> <a id="1323" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1324" class="Symbol">)</a> <a id="1326" class="Symbol">→</a> <a id="1328" class="Symbol">(</a><a id="1329" href="Haskell.Law.Ord.Def.html#1317" class="Bound">x</a> <a id="1331" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="1333" href="Haskell.Law.Ord.Def.html#1319" class="Bound">y</a><a id="1334" class="Symbol">)</a> <a id="1336" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1338" class="Symbol">(</a><a id="1339" href="Haskell.Law.Ord.Def.html#1319" class="Bound">y</a> <a id="1341" href="Haskell.Prim.Ord.html#1096" class="Field Operator">&gt;</a> <a id="1343" href="Haskell.Law.Ord.Def.html#1317" class="Bound">x</a><a id="1344" class="Symbol">)</a>

    <a id="1351" class="Comment">-- x &lt; y = compare x y == LT</a>
    <a id="IsLawfulOrd.compareLt"></a><a id="1384" href="Haskell.Law.Ord.Def.html#1384" class="Field">compareLt</a> <a id="1394" class="Symbol">:</a> <a id="1396" class="Symbol">∀</a> <a id="1398" class="Symbol">(</a><a id="1399" href="Haskell.Law.Ord.Def.html#1399" class="Bound">x</a> <a id="1401" href="Haskell.Law.Ord.Def.html#1401" class="Bound">y</a> <a id="1403" class="Symbol">:</a> <a id="1405" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1406" class="Symbol">)</a> <a id="1408" class="Symbol">→</a> <a id="1410" class="Symbol">(</a><a id="1411" href="Haskell.Law.Ord.Def.html#1399" class="Bound">x</a> <a id="1413" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="1415" href="Haskell.Law.Ord.Def.html#1401" class="Bound">y</a><a id="1416" class="Symbol">)</a> <a id="1418" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1420" class="Symbol">(</a><a id="1421" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="1429" href="Haskell.Law.Ord.Def.html#1399" class="Bound">x</a> <a id="1431" href="Haskell.Law.Ord.Def.html#1401" class="Bound">y</a> <a id="1433" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="1436" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a><a id="1438" class="Symbol">)</a>

    <a id="1445" class="Comment">-- x &gt; y = compare x y == GT</a>
    <a id="IsLawfulOrd.compareGt"></a><a id="1478" href="Haskell.Law.Ord.Def.html#1478" class="Field">compareGt</a> <a id="1488" class="Symbol">:</a> <a id="1490" class="Symbol">∀</a> <a id="1492" class="Symbol">(</a><a id="1493" href="Haskell.Law.Ord.Def.html#1493" class="Bound">x</a> <a id="1495" href="Haskell.Law.Ord.Def.html#1495" class="Bound">y</a> <a id="1497" class="Symbol">:</a> <a id="1499" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1500" class="Symbol">)</a> <a id="1502" class="Symbol">→</a> <a id="1504" class="Symbol">(</a><a id="1505" href="Haskell.Law.Ord.Def.html#1493" class="Bound">x</a> <a id="1507" href="Haskell.Prim.Ord.html#1096" class="Field Operator">&gt;</a> <a id="1509" href="Haskell.Law.Ord.Def.html#1495" class="Bound">y</a><a id="1510" class="Symbol">)</a> <a id="1512" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1514" class="Symbol">(</a><a id="1515" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="1523" href="Haskell.Law.Ord.Def.html#1493" class="Bound">x</a> <a id="1525" href="Haskell.Law.Ord.Def.html#1495" class="Bound">y</a> <a id="1527" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="1530" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a><a id="1532" class="Symbol">)</a>

    <a id="1539" class="Comment">-- x == y = compare x y == EQ</a>
    <a id="IsLawfulOrd.compareEq"></a><a id="1573" href="Haskell.Law.Ord.Def.html#1573" class="Field">compareEq</a> <a id="1583" class="Symbol">:</a> <a id="1585" class="Symbol">∀</a> <a id="1587" class="Symbol">(</a><a id="1588" href="Haskell.Law.Ord.Def.html#1588" class="Bound">x</a> <a id="1590" href="Haskell.Law.Ord.Def.html#1590" class="Bound">y</a> <a id="1592" class="Symbol">:</a> <a id="1594" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1595" class="Symbol">)</a> <a id="1597" class="Symbol">→</a> <a id="1599" class="Symbol">(</a><a id="1600" href="Haskell.Law.Ord.Def.html#1588" class="Bound">x</a> <a id="1602" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="1605" href="Haskell.Law.Ord.Def.html#1590" class="Bound">y</a><a id="1606" class="Symbol">)</a> <a id="1608" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1610" class="Symbol">(</a><a id="1611" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="1619" href="Haskell.Law.Ord.Def.html#1588" class="Bound">x</a> <a id="1621" href="Haskell.Law.Ord.Def.html#1590" class="Bound">y</a> <a id="1623" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="1626" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a><a id="1628" class="Symbol">)</a>

    <a id="1635" class="Comment">-- min x y == if x &lt;= y then x else y = True</a>
    <a id="IsLawfulOrd.min2if"></a><a id="1684" href="Haskell.Law.Ord.Def.html#1684" class="Field">min2if</a> <a id="1691" class="Symbol">:</a> <a id="1693" class="Symbol">∀</a> <a id="1695" class="Symbol">(</a><a id="1696" href="Haskell.Law.Ord.Def.html#1696" class="Bound">x</a> <a id="1698" href="Haskell.Law.Ord.Def.html#1698" class="Bound">y</a> <a id="1700" class="Symbol">:</a> <a id="1702" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1703" class="Symbol">)</a> <a id="1705" class="Symbol">→</a> <a id="1707" class="Symbol">((</a><a id="1709" href="Haskell.Prim.Ord.html#1189" class="Field">min</a> <a id="1713" href="Haskell.Law.Ord.Def.html#1696" class="Bound">x</a> <a id="1715" href="Haskell.Law.Ord.Def.html#1698" class="Bound">y</a><a id="1716" class="Symbol">)</a> <a id="1718" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="1721" class="Symbol">(</a><a id="1722" href="Haskell.Prim.html#1713" class="Function Operator">if</a> <a id="1725" class="Symbol">(</a><a id="1726" href="Haskell.Law.Ord.Def.html#1696" class="Bound">x</a> <a id="1728" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="1731" href="Haskell.Law.Ord.Def.html#1698" class="Bound">y</a><a id="1732" class="Symbol">)</a> <a id="1734" href="Haskell.Prim.html#1713" class="Function Operator">then</a> <a id="1739" href="Haskell.Law.Ord.Def.html#1696" class="Bound">x</a> <a id="1741" href="Haskell.Prim.html#1713" class="Function Operator">else</a> <a id="1746" href="Haskell.Law.Ord.Def.html#1698" class="Bound">y</a><a id="1747" class="Symbol">))</a> <a id="1750" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1752" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

    <a id="1762" class="Comment">-- max x y == if x &gt;= y then x else y = True</a>
    <a id="IsLawfulOrd.max2if"></a><a id="1811" href="Haskell.Law.Ord.Def.html#1811" class="Field">max2if</a> <a id="1818" class="Symbol">:</a> <a id="1820" class="Symbol">∀</a> <a id="1822" class="Symbol">(</a><a id="1823" href="Haskell.Law.Ord.Def.html#1823" class="Bound">x</a> <a id="1825" href="Haskell.Law.Ord.Def.html#1825" class="Bound">y</a> <a id="1827" class="Symbol">:</a> <a id="1829" href="Haskell.Law.Ord.Def.html#539" class="Bound">a</a><a id="1830" class="Symbol">)</a> <a id="1832" class="Symbol">→</a> <a id="1834" class="Symbol">((</a><a id="1836" href="Haskell.Prim.Ord.html#1168" class="Field">max</a> <a id="1840" href="Haskell.Law.Ord.Def.html#1823" class="Bound">x</a> <a id="1842" href="Haskell.Law.Ord.Def.html#1825" class="Bound">y</a><a id="1843" class="Symbol">)</a> <a id="1845" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="1848" class="Symbol">(</a><a id="1849" href="Haskell.Prim.html#1713" class="Function Operator">if</a> <a id="1852" class="Symbol">(</a><a id="1853" href="Haskell.Law.Ord.Def.html#1823" class="Bound">x</a> <a id="1855" href="Haskell.Prim.Ord.html#1120" class="Field Operator">&gt;=</a> <a id="1858" href="Haskell.Law.Ord.Def.html#1825" class="Bound">y</a><a id="1859" class="Symbol">)</a> <a id="1861" href="Haskell.Prim.html#1713" class="Function Operator">then</a> <a id="1866" href="Haskell.Law.Ord.Def.html#1823" class="Bound">x</a> <a id="1868" href="Haskell.Prim.html#1713" class="Function Operator">else</a> <a id="1873" href="Haskell.Law.Ord.Def.html#1825" class="Bound">y</a><a id="1874" class="Symbol">))</a> <a id="1877" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1879" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>

<a id="1885" class="Keyword">open</a> <a id="1890" href="Haskell.Law.Ord.Def.html#526" class="Module">IsLawfulOrd</a> <a id="1902" class="Symbol">⦃</a> <a id="1904" class="Symbol">...</a> <a id="1908" class="Symbol">⦄</a> <a id="1910" class="Keyword">public</a>

<a id="1918" class="Comment">--------------------------------------------------</a>
<a id="1969" class="Comment">-- Some more helper laws</a>

<a id="eq2nlt"></a><a id="1995" href="Haskell.Law.Ord.Def.html#1995" class="Function">eq2nlt</a> <a id="2002" class="Symbol">:</a> <a id="2004" class="Symbol">⦃</a> <a id="2006" href="Haskell.Law.Ord.Def.html#2006" class="Bound">iOrdA</a> <a id="2012" class="Symbol">:</a> <a id="2014" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="2018" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="2020" class="Symbol">⦄</a> <a id="2022" class="Symbol">→</a> <a id="2024" class="Symbol">⦃</a> <a id="2026" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="2038" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="2040" class="Symbol">⦄</a>
  <a id="2044" class="Symbol">→</a> <a id="2046" class="Symbol">∀</a> <a id="2048" class="Symbol">(</a><a id="2049" href="Haskell.Law.Ord.Def.html#2049" class="Bound">x</a> <a id="2051" href="Haskell.Law.Ord.Def.html#2051" class="Bound">y</a> <a id="2053" class="Symbol">:</a> <a id="2055" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="2056" class="Symbol">)</a> <a id="2058" class="Symbol">→</a> <a id="2060" class="Symbol">(</a><a id="2061" href="Haskell.Law.Ord.Def.html#2049" class="Bound">x</a> <a id="2063" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="2066" href="Haskell.Law.Ord.Def.html#2051" class="Bound">y</a><a id="2067" class="Symbol">)</a> <a id="2069" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2071" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="2076" class="Symbol">→</a> <a id="2078" class="Symbol">(</a><a id="2079" href="Haskell.Law.Ord.Def.html#2049" class="Bound">x</a> <a id="2081" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="2083" href="Haskell.Law.Ord.Def.html#2051" class="Bound">y</a><a id="2084" class="Symbol">)</a> <a id="2086" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2088" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a>
<a id="2094" href="Haskell.Law.Ord.Def.html#1995" class="Function">eq2nlt</a> <a id="2101" href="Haskell.Law.Ord.Def.html#2101" class="Bound">x</a> <a id="2103" href="Haskell.Law.Ord.Def.html#2103" class="Bound">y</a> <a id="2105" href="Haskell.Law.Ord.Def.html#2105" class="Bound">h</a>
  <a id="2109" class="Keyword">rewrite</a> <a id="2117" href="Haskell.Law.Ord.Def.html#1573" class="Field">compareEq</a> <a id="2127" href="Haskell.Law.Ord.Def.html#2101" class="Bound">x</a> <a id="2129" href="Haskell.Law.Ord.Def.html#2103" class="Bound">y</a>
    <a id="2135" class="Symbol">|</a> <a id="2137" href="Haskell.Law.Ord.Def.html#1384" class="Field">compareLt</a> <a id="2147" href="Haskell.Law.Ord.Def.html#2101" class="Bound">x</a> <a id="2149" href="Haskell.Law.Ord.Def.html#2103" class="Bound">y</a>
    <a id="2155" class="Symbol">|</a> <a id="2157" href="Haskell.Law.Eq.Def.html#369" class="Function">equality</a> <a id="2166" class="Symbol">(</a><a id="2167" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="2175" href="Haskell.Law.Ord.Def.html#2101" class="Bound">x</a> <a id="2177" href="Haskell.Law.Ord.Def.html#2103" class="Bound">y</a><a id="2178" class="Symbol">)</a> <a id="2180" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="2183" href="Haskell.Law.Ord.Def.html#2105" class="Bound">h</a>
  <a id="2187" class="Symbol">=</a> <a id="2189" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="eq2ngt"></a><a id="2195" href="Haskell.Law.Ord.Def.html#2195" class="Function">eq2ngt</a> <a id="2202" class="Symbol">:</a> <a id="2204" class="Symbol">⦃</a> <a id="2206" href="Haskell.Law.Ord.Def.html#2206" class="Bound">iOrdA</a> <a id="2212" class="Symbol">:</a> <a id="2214" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="2218" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="2220" class="Symbol">⦄</a> <a id="2222" class="Symbol">→</a> <a id="2224" class="Symbol">⦃</a> <a id="2226" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="2238" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="2240" class="Symbol">⦄</a>
  <a id="2244" class="Symbol">→</a> <a id="2246" class="Symbol">∀</a> <a id="2248" class="Symbol">(</a><a id="2249" href="Haskell.Law.Ord.Def.html#2249" class="Bound">x</a> <a id="2251" href="Haskell.Law.Ord.Def.html#2251" class="Bound">y</a> <a id="2253" class="Symbol">:</a> <a id="2255" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="2256" class="Symbol">)</a> <a id="2258" class="Symbol">→</a> <a id="2260" class="Symbol">(</a><a id="2261" href="Haskell.Law.Ord.Def.html#2249" class="Bound">x</a> <a id="2263" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="2266" href="Haskell.Law.Ord.Def.html#2251" class="Bound">y</a><a id="2267" class="Symbol">)</a> <a id="2269" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2271" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="2276" class="Symbol">→</a> <a id="2278" class="Symbol">(</a><a id="2279" href="Haskell.Law.Ord.Def.html#2249" class="Bound">x</a> <a id="2281" href="Haskell.Prim.Ord.html#1096" class="Field Operator">&gt;</a> <a id="2283" href="Haskell.Law.Ord.Def.html#2251" class="Bound">y</a><a id="2284" class="Symbol">)</a> <a id="2286" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2288" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a>
<a id="2294" href="Haskell.Law.Ord.Def.html#2195" class="Function">eq2ngt</a> <a id="2301" href="Haskell.Law.Ord.Def.html#2301" class="Bound">x</a> <a id="2303" href="Haskell.Law.Ord.Def.html#2303" class="Bound">y</a> <a id="2305" href="Haskell.Law.Ord.Def.html#2305" class="Bound">h</a>
  <a id="2309" class="Keyword">rewrite</a> <a id="2317" href="Haskell.Law.Ord.Def.html#1573" class="Field">compareEq</a> <a id="2327" href="Haskell.Law.Ord.Def.html#2301" class="Bound">x</a> <a id="2329" href="Haskell.Law.Ord.Def.html#2303" class="Bound">y</a>
    <a id="2335" class="Symbol">|</a> <a id="2337" href="Haskell.Law.Ord.Def.html#1478" class="Field">compareGt</a> <a id="2347" href="Haskell.Law.Ord.Def.html#2301" class="Bound">x</a> <a id="2349" href="Haskell.Law.Ord.Def.html#2303" class="Bound">y</a>
    <a id="2355" class="Symbol">|</a> <a id="2357" href="Haskell.Law.Eq.Def.html#369" class="Function">equality</a> <a id="2366" class="Symbol">(</a><a id="2367" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="2375" href="Haskell.Law.Ord.Def.html#2301" class="Bound">x</a> <a id="2377" href="Haskell.Law.Ord.Def.html#2303" class="Bound">y</a><a id="2378" class="Symbol">)</a> <a id="2380" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="2383" href="Haskell.Law.Ord.Def.html#2305" class="Bound">h</a>
  <a id="2387" class="Symbol">=</a> <a id="2389" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lte2LtEq"></a><a id="2395" href="Haskell.Law.Ord.Def.html#2395" class="Function">lte2LtEq</a> <a id="2404" class="Symbol">:</a> <a id="2406" class="Symbol">⦃</a> <a id="2408" href="Haskell.Law.Ord.Def.html#2408" class="Bound">iOrdA</a> <a id="2414" class="Symbol">:</a> <a id="2416" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="2420" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="2422" class="Symbol">⦄</a> <a id="2424" class="Symbol">→</a> <a id="2426" class="Symbol">⦃</a> <a id="2428" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="2440" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="2442" class="Symbol">⦄</a>
  <a id="2446" class="Symbol">→</a> <a id="2448" class="Symbol">∀</a> <a id="2450" class="Symbol">(</a><a id="2451" href="Haskell.Law.Ord.Def.html#2451" class="Bound">x</a> <a id="2453" href="Haskell.Law.Ord.Def.html#2453" class="Bound">y</a> <a id="2455" class="Symbol">:</a> <a id="2457" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="2458" class="Symbol">)</a> <a id="2460" class="Symbol">→</a> <a id="2462" class="Symbol">(</a><a id="2463" href="Haskell.Law.Ord.Def.html#2451" class="Bound">x</a> <a id="2465" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="2468" href="Haskell.Law.Ord.Def.html#2453" class="Bound">y</a><a id="2469" class="Symbol">)</a> <a id="2471" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2473" class="Symbol">(</a><a id="2474" href="Haskell.Law.Ord.Def.html#2451" class="Bound">x</a> <a id="2476" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="2478" href="Haskell.Law.Ord.Def.html#2453" class="Bound">y</a> <a id="2480" href="Haskell.Prim.Bool.html#213" class="Function Operator">||</a> <a id="2483" href="Haskell.Law.Ord.Def.html#2451" class="Bound">x</a> <a id="2485" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="2488" href="Haskell.Law.Ord.Def.html#2453" class="Bound">y</a><a id="2489" class="Symbol">)</a>
<a id="2491" href="Haskell.Law.Ord.Def.html#2395" class="Function">lte2LtEq</a> <a id="2500" href="Haskell.Law.Ord.Def.html#2500" class="Bound">x</a> <a id="2502" href="Haskell.Law.Ord.Def.html#2502" class="Bound">y</a> 
  <a id="2507" class="Keyword">rewrite</a> <a id="2515" href="Haskell.Law.Ord.Def.html#1225" class="Field">lt2LteNeq</a> <a id="2525" href="Haskell.Law.Ord.Def.html#2500" class="Bound">x</a> <a id="2527" href="Haskell.Law.Ord.Def.html#2502" class="Bound">y</a>
    <a id="2533" class="Symbol">|</a> <a id="2535" href="Haskell.Law.Ord.Def.html#1573" class="Field">compareEq</a> <a id="2545" href="Haskell.Law.Ord.Def.html#2500" class="Bound">x</a> <a id="2547" href="Haskell.Law.Ord.Def.html#2502" class="Bound">y</a>
  <a id="2551" class="Keyword">with</a> <a id="2556" class="Symbol">(</a><a id="2557" href="Haskell.Law.Ord.Def.html#2500" class="Bound">x</a> <a id="2559" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="2562" href="Haskell.Law.Ord.Def.html#2502" class="Bound">y</a><a id="2563" class="Symbol">)</a> <a id="2565" class="Keyword">in</a> <a id="2568" class="Argument">h₁</a> <a id="2571" class="Symbol">|</a> <a id="2573" class="Symbol">(</a><a id="2574" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="2582" href="Haskell.Law.Ord.Def.html#2500" class="Bound">x</a> <a id="2584" href="Haskell.Law.Ord.Def.html#2502" class="Bound">y</a><a id="2585" class="Symbol">)</a> <a id="2587" class="Keyword">in</a> <a id="2590" class="Argument">h₂</a>
<a id="2593" class="Symbol">...</a> <a id="2597" class="Symbol">|</a> <a id="2599" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="2605" class="Symbol">|</a> <a id="2607" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a> <a id="2610" class="Symbol">=</a> <a id="2612" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="2617" class="Symbol">...</a> <a id="2621" class="Symbol">|</a> <a id="2623" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="2629" class="Symbol">|</a> <a id="2631" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="2634" class="Symbol">=</a> <a id="2636" href="Haskell.Prim.html#2611" class="Function">magic</a> <a id="2642" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="2644" href="Haskell.Prim.html#2672" class="Function">exFalso</a> <a id="2652" class="Symbol">(</a><a id="2653" href="Haskell.Law.Ord.Def.html#924" class="Field">reflexivity</a> <a id="2665" class="Bound">x</a><a id="2666" class="Symbol">)</a> <a id="2668" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="2670" href="Haskell.Law.Equality.html#889" class="Function Operator">begin</a> 
    <a id="2681" class="Symbol">(</a><a id="2682" class="Bound">x</a> <a id="2684" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="2687" class="Bound">x</a><a id="2688" class="Symbol">)</a>  <a id="2691" href="Haskell.Law.Equality.html#998" class="Function">≡⟨</a> <a id="2694" class="Symbol">(</a><a id="2695" href="Haskell.Law.Equality.html#226" class="Function">cong</a> <a id="2700" class="Symbol">(</a><a id="2701" class="Bound">x</a> <a id="2703" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=_</a><a id="2706" class="Symbol">)</a> <a id="2708" class="Symbol">(</a><a id="2709" href="Haskell.Law.Eq.Def.html#369" class="Function">equality</a> <a id="2718" class="Bound">x</a> <a id="2720" class="Bound">y</a> <a id="2722" class="Symbol">(</a><a id="2723" href="Haskell.Law.Equality.html#889" class="Function Operator">begin</a> 
      <a id="2736" class="Symbol">(</a><a id="2737" class="Bound">x</a> <a id="2739" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="2742" class="Bound">y</a><a id="2743" class="Symbol">)</a>            <a id="2756" href="Haskell.Law.Equality.html#998" class="Function">≡⟨</a> <a id="2759" href="Haskell.Law.Ord.Def.html#1573" class="Field">compareEq</a> <a id="2769" class="Bound">x</a> <a id="2771" class="Bound">y</a> <a id="2773" href="Haskell.Law.Equality.html#998" class="Function">⟩</a> 
      <a id="2782" class="Symbol">(</a><a id="2783" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="2791" class="Bound">x</a> <a id="2793" class="Bound">y</a> <a id="2795" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="2798" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a><a id="2800" class="Symbol">)</a> <a id="2802" href="Haskell.Law.Equality.html#998" class="Function">≡⟨</a> <a id="2805" href="Haskell.Law.Eq.Def.html#624" class="Function">equality&#39;</a> <a id="2815" class="Symbol">(</a><a id="2816" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="2824" class="Bound">x</a> <a id="2826" class="Bound">y</a><a id="2827" class="Symbol">)</a> <a id="2829" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="2832" href="Haskell.Law.Ord.Def.html#2590" class="Bound">h₂</a> <a id="2835" href="Haskell.Law.Equality.html#998" class="Function">⟩</a> 
      <a id="2844" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>                <a id="2864" href="Haskell.Law.Equality.html#1172" class="Function Operator">∎</a> <a id="2866" class="Symbol">)</a> <a id="2868" class="Symbol">)</a> <a id="2870" class="Symbol">)</a> <a id="2872" href="Haskell.Law.Equality.html#998" class="Function">⟩</a>
    <a id="2878" class="Symbol">(</a><a id="2879" class="Bound">x</a> <a id="2881" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="2884" class="Bound">y</a><a id="2885" class="Symbol">)</a>  <a id="2888" href="Haskell.Law.Equality.html#998" class="Function">≡⟨</a> <a id="2891" href="Haskell.Law.Ord.Def.html#2568" class="Bound">h₁</a> <a id="2894" href="Haskell.Law.Equality.html#998" class="Function">⟩</a> 
    <a id="2901" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="2907" href="Haskell.Law.Equality.html#1172" class="Function Operator">∎</a>
<a id="2909" class="Symbol">...</a> <a id="2913" class="Symbol">|</a> <a id="2915" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">False</a> <a id="2921" class="Symbol">|</a> <a id="2923" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a> <a id="2926" class="Symbol">=</a> <a id="2928" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="2933" class="Symbol">...</a> <a id="2937" class="Symbol">|</a> <a id="2939" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="2945" class="Symbol">|</a> <a id="2947" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a> <a id="2950" class="Symbol">=</a> <a id="2952" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="2957" class="Symbol">...</a> <a id="2961" class="Symbol">|</a> <a id="2963" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="2969" class="Symbol">|</a> <a id="2971" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="2974" class="Symbol">=</a> <a id="2976" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="2981" class="Symbol">...</a> <a id="2985" class="Symbol">|</a> <a id="2987" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>  <a id="2993" class="Symbol">|</a> <a id="2995" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a> <a id="2998" class="Symbol">=</a> <a id="3000" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="gte2GtEq"></a><a id="3006" href="Haskell.Law.Ord.Def.html#3006" class="Function">gte2GtEq</a> <a id="3015" class="Symbol">:</a> <a id="3017" class="Symbol">⦃</a> <a id="3019" href="Haskell.Law.Ord.Def.html#3019" class="Bound">iOrdA</a> <a id="3025" class="Symbol">:</a> <a id="3027" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="3031" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3033" class="Symbol">⦄</a> <a id="3035" class="Symbol">→</a> <a id="3037" class="Symbol">⦃</a> <a id="3039" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="3051" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3053" class="Symbol">⦄</a>
  <a id="3057" class="Symbol">→</a> <a id="3059" class="Symbol">∀</a> <a id="3061" class="Symbol">(</a><a id="3062" href="Haskell.Law.Ord.Def.html#3062" class="Bound">x</a> <a id="3064" href="Haskell.Law.Ord.Def.html#3064" class="Bound">y</a> <a id="3066" class="Symbol">:</a> <a id="3068" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3069" class="Symbol">)</a> <a id="3071" class="Symbol">→</a> <a id="3073" class="Symbol">(</a><a id="3074" href="Haskell.Law.Ord.Def.html#3062" class="Bound">x</a> <a id="3076" href="Haskell.Prim.Ord.html#1120" class="Field Operator">&gt;=</a> <a id="3079" href="Haskell.Law.Ord.Def.html#3064" class="Bound">y</a><a id="3080" class="Symbol">)</a> <a id="3082" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3084" class="Symbol">(</a><a id="3085" href="Haskell.Law.Ord.Def.html#3062" class="Bound">x</a> <a id="3087" href="Haskell.Prim.Ord.html#1096" class="Field Operator">&gt;</a> <a id="3089" href="Haskell.Law.Ord.Def.html#3064" class="Bound">y</a> <a id="3091" href="Haskell.Prim.Bool.html#213" class="Function Operator">||</a> <a id="3094" href="Haskell.Law.Ord.Def.html#3062" class="Bound">x</a> <a id="3096" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="3099" href="Haskell.Law.Ord.Def.html#3064" class="Bound">y</a><a id="3100" class="Symbol">)</a>
<a id="3102" href="Haskell.Law.Ord.Def.html#3006" class="Function">gte2GtEq</a> <a id="3111" href="Haskell.Law.Ord.Def.html#3111" class="Bound">x</a> <a id="3113" href="Haskell.Law.Ord.Def.html#3113" class="Bound">y</a>
  <a id="3117" class="Keyword">rewrite</a> <a id="3125" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="3129" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="3131" href="Haskell.Law.Ord.Def.html#1144" class="Field">lte2gte</a> <a id="3139" href="Haskell.Law.Ord.Def.html#3113" class="Bound">y</a> <a id="3141" href="Haskell.Law.Ord.Def.html#3111" class="Bound">x</a>
    <a id="3147" class="Symbol">|</a> <a id="3149" href="Haskell.Law.Ord.Def.html#2395" class="Function">lte2LtEq</a> <a id="3158" href="Haskell.Law.Ord.Def.html#3113" class="Bound">y</a> <a id="3160" href="Haskell.Law.Ord.Def.html#3111" class="Bound">x</a>
    <a id="3166" class="Symbol">|</a> <a id="3168" href="Haskell.Law.Eq.Def.html#1191" class="Function">eqSymmetry</a> <a id="3179" href="Haskell.Law.Ord.Def.html#3113" class="Bound">y</a> <a id="3181" href="Haskell.Law.Ord.Def.html#3111" class="Bound">x</a>
    <a id="3187" class="Symbol">|</a> <a id="3189" href="Haskell.Law.Ord.Def.html#1306" class="Field">lt2gt</a> <a id="3195" href="Haskell.Law.Ord.Def.html#3113" class="Bound">y</a> <a id="3197" href="Haskell.Law.Ord.Def.html#3111" class="Bound">x</a>
  <a id="3201" class="Symbol">=</a> <a id="3203" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="gte2nlt"></a><a id="3209" href="Haskell.Law.Ord.Def.html#3209" class="Function">gte2nlt</a> <a id="3217" class="Symbol">:</a> <a id="3219" class="Symbol">⦃</a> <a id="3221" href="Haskell.Law.Ord.Def.html#3221" class="Bound">iOrdA</a> <a id="3227" class="Symbol">:</a> <a id="3229" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="3233" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3235" class="Symbol">⦄</a> <a id="3237" class="Symbol">→</a> <a id="3239" class="Symbol">⦃</a> <a id="3241" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="3253" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3255" class="Symbol">⦄</a>
  <a id="3259" class="Symbol">→</a> <a id="3261" class="Symbol">∀</a> <a id="3263" class="Symbol">(</a><a id="3264" href="Haskell.Law.Ord.Def.html#3264" class="Bound">x</a> <a id="3266" href="Haskell.Law.Ord.Def.html#3266" class="Bound">y</a> <a id="3268" class="Symbol">:</a> <a id="3270" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3271" class="Symbol">)</a> <a id="3273" class="Symbol">→</a> <a id="3275" class="Symbol">(</a><a id="3276" href="Haskell.Law.Ord.Def.html#3264" class="Bound">x</a> <a id="3278" href="Haskell.Prim.Ord.html#1120" class="Field Operator">&gt;=</a> <a id="3281" href="Haskell.Law.Ord.Def.html#3266" class="Bound">y</a><a id="3282" class="Symbol">)</a> <a id="3284" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3286" href="Haskell.Prim.Bool.html#273" class="Function">not</a> <a id="3290" class="Symbol">(</a><a id="3291" href="Haskell.Law.Ord.Def.html#3264" class="Bound">x</a> <a id="3293" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="3295" href="Haskell.Law.Ord.Def.html#3266" class="Bound">y</a><a id="3296" class="Symbol">)</a>
<a id="3298" href="Haskell.Law.Ord.Def.html#3209" class="Function">gte2nlt</a> <a id="3306" href="Haskell.Law.Ord.Def.html#3306" class="Bound">x</a> <a id="3308" href="Haskell.Law.Ord.Def.html#3308" class="Bound">y</a>
  <a id="3312" class="Keyword">rewrite</a> <a id="3320" href="Haskell.Law.Ord.Def.html#3006" class="Function">gte2GtEq</a> <a id="3329" href="Haskell.Law.Ord.Def.html#3306" class="Bound">x</a> <a id="3331" href="Haskell.Law.Ord.Def.html#3308" class="Bound">y</a>
    <a id="3337" class="Symbol">|</a> <a id="3339" href="Haskell.Law.Ord.Def.html#1478" class="Field">compareGt</a> <a id="3349" href="Haskell.Law.Ord.Def.html#3306" class="Bound">x</a> <a id="3351" href="Haskell.Law.Ord.Def.html#3308" class="Bound">y</a>
    <a id="3357" class="Symbol">|</a> <a id="3359" href="Haskell.Law.Ord.Def.html#1573" class="Field">compareEq</a> <a id="3369" href="Haskell.Law.Ord.Def.html#3306" class="Bound">x</a> <a id="3371" href="Haskell.Law.Ord.Def.html#3308" class="Bound">y</a>
    <a id="3377" class="Symbol">|</a> <a id="3379" href="Haskell.Law.Ord.Def.html#1384" class="Field">compareLt</a> <a id="3389" href="Haskell.Law.Ord.Def.html#3306" class="Bound">x</a> <a id="3391" href="Haskell.Law.Ord.Def.html#3308" class="Bound">y</a>
  <a id="3395" class="Keyword">with</a> <a id="3400" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="3408" href="Haskell.Law.Ord.Def.html#3306" class="Bound">x</a> <a id="3410" href="Haskell.Law.Ord.Def.html#3308" class="Bound">y</a>
<a id="3412" class="Symbol">...</a> <a id="3416" class="Symbol">|</a> <a id="3418" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a> <a id="3421" class="Symbol">=</a> <a id="3423" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 
<a id="3429" class="Symbol">...</a> <a id="3433" class="Symbol">|</a> <a id="3435" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="3438" class="Symbol">=</a> <a id="3440" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 
<a id="3446" class="Symbol">...</a> <a id="3450" class="Symbol">|</a> <a id="3452" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a> <a id="3455" class="Symbol">=</a> <a id="3457" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 

<a id="gte2nLT"></a><a id="3464" href="Haskell.Law.Ord.Def.html#3464" class="Function">gte2nLT</a> <a id="3472" class="Symbol">:</a> <a id="3474" class="Symbol">⦃</a> <a id="3476" href="Haskell.Law.Ord.Def.html#3476" class="Bound">iOrdA</a> <a id="3482" class="Symbol">:</a> <a id="3484" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="3488" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3490" class="Symbol">⦄</a> <a id="3492" class="Symbol">→</a> <a id="3494" class="Symbol">⦃</a> <a id="3496" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="3508" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3510" class="Symbol">⦄</a>
  <a id="3514" class="Symbol">→</a> <a id="3516" class="Symbol">∀</a> <a id="3518" class="Symbol">(</a><a id="3519" href="Haskell.Law.Ord.Def.html#3519" class="Bound">x</a> <a id="3521" href="Haskell.Law.Ord.Def.html#3521" class="Bound">y</a> <a id="3523" class="Symbol">:</a> <a id="3525" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3526" class="Symbol">)</a> <a id="3528" class="Symbol">→</a> <a id="3530" class="Symbol">(</a><a id="3531" href="Haskell.Law.Ord.Def.html#3519" class="Bound">x</a> <a id="3533" href="Haskell.Prim.Ord.html#1120" class="Field Operator">&gt;=</a> <a id="3536" href="Haskell.Law.Ord.Def.html#3521" class="Bound">y</a><a id="3537" class="Symbol">)</a> <a id="3539" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3541" class="Symbol">(</a><a id="3542" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="3550" href="Haskell.Law.Ord.Def.html#3519" class="Bound">x</a> <a id="3552" href="Haskell.Law.Ord.Def.html#3521" class="Bound">y</a> <a id="3554" href="Haskell.Prim.Eq.html#481" class="Function Operator">/=</a> <a id="3557" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a><a id="3559" class="Symbol">)</a>
<a id="3561" href="Haskell.Law.Ord.Def.html#3464" class="Function">gte2nLT</a> <a id="3569" href="Haskell.Law.Ord.Def.html#3569" class="Bound">x</a> <a id="3571" href="Haskell.Law.Ord.Def.html#3571" class="Bound">y</a>
  <a id="3575" class="Keyword">rewrite</a> <a id="3583" href="Haskell.Law.Ord.Def.html#3209" class="Function">gte2nlt</a> <a id="3591" href="Haskell.Law.Ord.Def.html#3569" class="Bound">x</a> <a id="3593" href="Haskell.Law.Ord.Def.html#3571" class="Bound">y</a>
    <a id="3599" class="Symbol">|</a> <a id="3601" href="Haskell.Law.Ord.Def.html#1384" class="Field">compareLt</a> <a id="3611" href="Haskell.Law.Ord.Def.html#3569" class="Bound">x</a> <a id="3613" href="Haskell.Law.Ord.Def.html#3571" class="Bound">y</a>
  <a id="3617" class="Symbol">=</a> <a id="3619" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lte2ngt"></a><a id="3625" href="Haskell.Law.Ord.Def.html#3625" class="Function">lte2ngt</a> <a id="3633" class="Symbol">:</a> <a id="3635" class="Symbol">⦃</a> <a id="3637" href="Haskell.Law.Ord.Def.html#3637" class="Bound">iOrdA</a> <a id="3643" class="Symbol">:</a> <a id="3645" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="3649" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3651" class="Symbol">⦄</a> <a id="3653" class="Symbol">→</a> <a id="3655" class="Symbol">⦃</a> <a id="3657" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="3669" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3671" class="Symbol">⦄</a>
  <a id="3675" class="Symbol">→</a> <a id="3677" class="Symbol">∀</a> <a id="3679" class="Symbol">(</a><a id="3680" href="Haskell.Law.Ord.Def.html#3680" class="Bound">x</a> <a id="3682" href="Haskell.Law.Ord.Def.html#3682" class="Bound">y</a> <a id="3684" class="Symbol">:</a> <a id="3686" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3687" class="Symbol">)</a> <a id="3689" class="Symbol">→</a> <a id="3691" class="Symbol">(</a><a id="3692" href="Haskell.Law.Ord.Def.html#3680" class="Bound">x</a> <a id="3694" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="3697" href="Haskell.Law.Ord.Def.html#3682" class="Bound">y</a><a id="3698" class="Symbol">)</a> <a id="3700" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3702" href="Haskell.Prim.Bool.html#273" class="Function">not</a> <a id="3706" class="Symbol">(</a><a id="3707" href="Haskell.Law.Ord.Def.html#3680" class="Bound">x</a> <a id="3709" href="Haskell.Prim.Ord.html#1096" class="Field Operator">&gt;</a> <a id="3711" href="Haskell.Law.Ord.Def.html#3682" class="Bound">y</a><a id="3712" class="Symbol">)</a>
<a id="3714" href="Haskell.Law.Ord.Def.html#3625" class="Function">lte2ngt</a> <a id="3722" href="Haskell.Law.Ord.Def.html#3722" class="Bound">x</a> <a id="3724" href="Haskell.Law.Ord.Def.html#3724" class="Bound">y</a>
  <a id="3728" class="Keyword">rewrite</a> <a id="3736" href="Haskell.Law.Ord.Def.html#2395" class="Function">lte2LtEq</a> <a id="3745" href="Haskell.Law.Ord.Def.html#3722" class="Bound">x</a> <a id="3747" href="Haskell.Law.Ord.Def.html#3724" class="Bound">y</a>
    <a id="3753" class="Symbol">|</a> <a id="3755" href="Haskell.Law.Ord.Def.html#1384" class="Field">compareLt</a> <a id="3765" href="Haskell.Law.Ord.Def.html#3722" class="Bound">x</a> <a id="3767" href="Haskell.Law.Ord.Def.html#3724" class="Bound">y</a>
    <a id="3773" class="Symbol">|</a> <a id="3775" href="Haskell.Law.Ord.Def.html#1573" class="Field">compareEq</a> <a id="3785" href="Haskell.Law.Ord.Def.html#3722" class="Bound">x</a> <a id="3787" href="Haskell.Law.Ord.Def.html#3724" class="Bound">y</a>
    <a id="3793" class="Symbol">|</a> <a id="3795" href="Haskell.Law.Ord.Def.html#1478" class="Field">compareGt</a> <a id="3805" href="Haskell.Law.Ord.Def.html#3722" class="Bound">x</a> <a id="3807" href="Haskell.Law.Ord.Def.html#3724" class="Bound">y</a>
  <a id="3811" class="Keyword">with</a> <a id="3816" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="3824" href="Haskell.Law.Ord.Def.html#3722" class="Bound">x</a> <a id="3826" href="Haskell.Law.Ord.Def.html#3724" class="Bound">y</a>
<a id="3828" class="Symbol">...</a> <a id="3832" class="Symbol">|</a> <a id="3834" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a> <a id="3837" class="Symbol">=</a> <a id="3839" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 
<a id="3845" class="Symbol">...</a> <a id="3849" class="Symbol">|</a> <a id="3851" href="Haskell.Prim.Ord.html#492" class="InductiveConstructor">EQ</a> <a id="3854" class="Symbol">=</a> <a id="3856" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 
<a id="3862" class="Symbol">...</a> <a id="3866" class="Symbol">|</a> <a id="3868" href="Haskell.Prim.Ord.html#489" class="InductiveConstructor">LT</a> <a id="3871" class="Symbol">=</a> <a id="3873" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 

<a id="lte2nGT"></a><a id="3880" href="Haskell.Law.Ord.Def.html#3880" class="Function">lte2nGT</a> <a id="3888" class="Symbol">:</a> <a id="3890" class="Symbol">⦃</a> <a id="3892" href="Haskell.Law.Ord.Def.html#3892" class="Bound">iOrdA</a> <a id="3898" class="Symbol">:</a> <a id="3900" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="3904" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3906" class="Symbol">⦄</a> <a id="3908" class="Symbol">→</a> <a id="3910" class="Symbol">⦃</a> <a id="3912" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="3924" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="3926" class="Symbol">⦄</a>
  <a id="3930" class="Symbol">→</a> <a id="3932" class="Symbol">∀</a> <a id="3934" class="Symbol">(</a><a id="3935" href="Haskell.Law.Ord.Def.html#3935" class="Bound">x</a> <a id="3937" href="Haskell.Law.Ord.Def.html#3937" class="Bound">y</a> <a id="3939" class="Symbol">:</a> <a id="3941" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="3942" class="Symbol">)</a> <a id="3944" class="Symbol">→</a> <a id="3946" class="Symbol">(</a><a id="3947" href="Haskell.Law.Ord.Def.html#3935" class="Bound">x</a> <a id="3949" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="3952" href="Haskell.Law.Ord.Def.html#3937" class="Bound">y</a><a id="3953" class="Symbol">)</a> <a id="3955" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3957" class="Symbol">(</a><a id="3958" href="Haskell.Prim.Ord.html#1041" class="Field">compare</a> <a id="3966" href="Haskell.Law.Ord.Def.html#3935" class="Bound">x</a> <a id="3968" href="Haskell.Law.Ord.Def.html#3937" class="Bound">y</a> <a id="3970" href="Haskell.Prim.Eq.html#481" class="Function Operator">/=</a> <a id="3973" href="Haskell.Prim.Ord.html#495" class="InductiveConstructor">GT</a><a id="3975" class="Symbol">)</a>
<a id="3977" href="Haskell.Law.Ord.Def.html#3880" class="Function">lte2nGT</a> <a id="3985" href="Haskell.Law.Ord.Def.html#3985" class="Bound">x</a> <a id="3987" href="Haskell.Law.Ord.Def.html#3987" class="Bound">y</a>
  <a id="3991" class="Keyword">rewrite</a> <a id="3999" href="Haskell.Law.Ord.Def.html#3625" class="Function">lte2ngt</a> <a id="4007" href="Haskell.Law.Ord.Def.html#3985" class="Bound">x</a> <a id="4009" href="Haskell.Law.Ord.Def.html#3987" class="Bound">y</a>
    <a id="4015" class="Symbol">|</a> <a id="4017" href="Haskell.Law.Ord.Def.html#1478" class="Field">compareGt</a> <a id="4027" href="Haskell.Law.Ord.Def.html#3985" class="Bound">x</a> <a id="4029" href="Haskell.Law.Ord.Def.html#3987" class="Bound">y</a>
  <a id="4033" class="Symbol">=</a> <a id="4035" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="eq2lte"></a><a id="4041" href="Haskell.Law.Ord.Def.html#4041" class="Function">eq2lte</a> <a id="4048" class="Symbol">:</a> <a id="4050" class="Symbol">⦃</a> <a id="4052" href="Haskell.Law.Ord.Def.html#4052" class="Bound">iOrdA</a> <a id="4058" class="Symbol">:</a> <a id="4060" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="4064" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4066" class="Symbol">⦄</a> <a id="4068" class="Symbol">→</a> <a id="4070" class="Symbol">⦃</a> <a id="4072" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4084" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4086" class="Symbol">⦄</a>
  <a id="4090" class="Symbol">→</a> <a id="4092" class="Symbol">∀</a> <a id="4094" class="Symbol">(</a><a id="4095" href="Haskell.Law.Ord.Def.html#4095" class="Bound">x</a> <a id="4097" href="Haskell.Law.Ord.Def.html#4097" class="Bound">y</a> <a id="4099" class="Symbol">:</a> <a id="4101" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="4102" class="Symbol">)</a> <a id="4104" class="Symbol">→</a> <a id="4106" class="Symbol">(</a><a id="4107" href="Haskell.Law.Ord.Def.html#4095" class="Bound">x</a> <a id="4109" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="4112" href="Haskell.Law.Ord.Def.html#4097" class="Bound">y</a><a id="4113" class="Symbol">)</a> <a id="4115" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4117" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="4122" class="Symbol">→</a> <a id="4124" class="Symbol">(</a><a id="4125" href="Haskell.Law.Ord.Def.html#4095" class="Bound">x</a> <a id="4127" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="4130" href="Haskell.Law.Ord.Def.html#4097" class="Bound">y</a><a id="4131" class="Symbol">)</a> <a id="4133" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4135" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="4140" href="Haskell.Law.Ord.Def.html#4041" class="Function">eq2lte</a> <a id="4147" href="Haskell.Law.Ord.Def.html#4147" class="Bound">x</a> <a id="4149" href="Haskell.Law.Ord.Def.html#4149" class="Bound">y</a> <a id="4151" href="Haskell.Law.Ord.Def.html#4151" class="Bound">h</a>
  <a id="4155" class="Keyword">rewrite</a> <a id="4163" href="Haskell.Law.Ord.Def.html#3625" class="Function">lte2ngt</a> <a id="4171" href="Haskell.Law.Ord.Def.html#4147" class="Bound">x</a> <a id="4173" href="Haskell.Law.Ord.Def.html#4149" class="Bound">y</a>
    <a id="4179" class="Symbol">|</a> <a id="4181" href="Haskell.Law.Ord.Def.html#2195" class="Function">eq2ngt</a> <a id="4188" href="Haskell.Law.Ord.Def.html#4147" class="Bound">x</a> <a id="4190" href="Haskell.Law.Ord.Def.html#4149" class="Bound">y</a> <a id="4192" href="Haskell.Law.Ord.Def.html#4151" class="Bound">h</a>
  <a id="4196" class="Symbol">=</a> <a id="4198" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="lt2lte"></a><a id="4204" href="Haskell.Law.Ord.Def.html#4204" class="Function">lt2lte</a> <a id="4211" class="Symbol">:</a> <a id="4213" class="Symbol">⦃</a> <a id="4215" href="Haskell.Law.Ord.Def.html#4215" class="Bound">iOrdA</a> <a id="4221" class="Symbol">:</a> <a id="4223" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="4227" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4229" class="Symbol">⦄</a> <a id="4231" class="Symbol">→</a> <a id="4233" class="Symbol">⦃</a> <a id="4235" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4247" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4249" class="Symbol">⦄</a>
  <a id="4253" class="Symbol">→</a> <a id="4255" class="Symbol">∀</a> <a id="4257" class="Symbol">(</a><a id="4258" href="Haskell.Law.Ord.Def.html#4258" class="Bound">x</a> <a id="4260" href="Haskell.Law.Ord.Def.html#4260" class="Bound">y</a> <a id="4262" class="Symbol">:</a> <a id="4264" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="4265" class="Symbol">)</a> <a id="4267" class="Symbol">→</a> <a id="4269" class="Symbol">(</a><a id="4270" href="Haskell.Law.Ord.Def.html#4258" class="Bound">x</a> <a id="4272" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="4274" href="Haskell.Law.Ord.Def.html#4260" class="Bound">y</a><a id="4275" class="Symbol">)</a> <a id="4277" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4279" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="4284" class="Symbol">→</a> <a id="4286" class="Symbol">(</a><a id="4287" href="Haskell.Law.Ord.Def.html#4258" class="Bound">x</a> <a id="4289" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="4292" href="Haskell.Law.Ord.Def.html#4260" class="Bound">y</a><a id="4293" class="Symbol">)</a> <a id="4295" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4297" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="4302" href="Haskell.Law.Ord.Def.html#4204" class="Function">lt2lte</a> <a id="4309" href="Haskell.Law.Ord.Def.html#4309" class="Bound">x</a> <a id="4311" href="Haskell.Law.Ord.Def.html#4311" class="Bound">y</a> <a id="4313" href="Haskell.Law.Ord.Def.html#4313" class="Bound">h</a> <a id="4315" class="Symbol">=</a> <a id="4317" href="Haskell.Law.Bool.html#974" class="Function">&amp;&amp;-rightTrue&#39;</a> <a id="4331" class="Symbol">(</a><a id="4332" href="Haskell.Law.Ord.Def.html#4309" class="Bound">x</a> <a id="4334" href="Haskell.Prim.Ord.html#1072" class="Field Operator">&lt;</a> <a id="4336" href="Haskell.Law.Ord.Def.html#4311" class="Bound">y</a><a id="4337" class="Symbol">)</a> <a id="4339" class="Symbol">(</a><a id="4340" href="Haskell.Law.Ord.Def.html#4309" class="Bound">x</a> <a id="4342" href="Haskell.Prim.Ord.html#1144" class="Field Operator">&lt;=</a> <a id="4345" href="Haskell.Law.Ord.Def.html#4311" class="Bound">y</a><a id="4346" class="Symbol">)</a> <a id="4348" class="Symbol">(</a><a id="4349" href="Haskell.Law.Ord.Def.html#4309" class="Bound">x</a> <a id="4351" href="Haskell.Prim.Eq.html#481" class="Function Operator">/=</a> <a id="4354" href="Haskell.Law.Ord.Def.html#4311" class="Bound">y</a><a id="4355" class="Symbol">)</a> <a id="4357" class="Symbol">(</a><a id="4358" href="Haskell.Law.Ord.Def.html#1225" class="Field">lt2LteNeq</a> <a id="4368" href="Haskell.Law.Ord.Def.html#4309" class="Bound">x</a> <a id="4370" href="Haskell.Law.Ord.Def.html#4311" class="Bound">y</a><a id="4371" class="Symbol">)</a> <a id="4373" href="Haskell.Law.Ord.Def.html#4313" class="Bound">h</a>

<a id="eq2gte"></a><a id="4376" href="Haskell.Law.Ord.Def.html#4376" class="Function">eq2gte</a> <a id="4383" class="Symbol">:</a> <a id="4385" class="Symbol">⦃</a> <a id="4387" href="Haskell.Law.Ord.Def.html#4387" class="Bound">iOrdA</a> <a id="4393" class="Symbol">:</a> <a id="4395" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="4399" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4401" class="Symbol">⦄</a> <a id="4403" class="Symbol">→</a> <a id="4405" class="Symbol">⦃</a> <a id="4407" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4419" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4421" class="Symbol">⦄</a>
  <a id="4425" class="Symbol">→</a> <a id="4427" class="Symbol">∀</a> <a id="4429" class="Symbol">(</a><a id="4430" href="Haskell.Law.Ord.Def.html#4430" class="Bound">x</a> <a id="4432" href="Haskell.Law.Ord.Def.html#4432" class="Bound">y</a> <a id="4434" class="Symbol">:</a> <a id="4436" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="4437" class="Symbol">)</a> <a id="4439" class="Symbol">→</a> <a id="4441" class="Symbol">(</a><a id="4442" href="Haskell.Law.Ord.Def.html#4430" class="Bound">x</a> <a id="4444" href="Haskell.Prim.Eq.html#458" class="Field Operator">==</a> <a id="4447" href="Haskell.Law.Ord.Def.html#4432" class="Bound">y</a><a id="4448" class="Symbol">)</a> <a id="4450" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4452" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="4457" class="Symbol">→</a> <a id="4459" class="Symbol">(</a><a id="4460" href="Haskell.Law.Ord.Def.html#4430" class="Bound">x</a> <a id="4462" href="Haskell.Prim.Ord.html#1120" class="Field Operator">&gt;=</a> <a id="4465" href="Haskell.Law.Ord.Def.html#4432" class="Bound">y</a><a id="4466" class="Symbol">)</a> <a id="4468" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4470" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="4475" href="Haskell.Law.Ord.Def.html#4376" class="Function">eq2gte</a> <a id="4482" href="Haskell.Law.Ord.Def.html#4482" class="Bound">x</a> <a id="4484" href="Haskell.Law.Ord.Def.html#4484" class="Bound">y</a> <a id="4486" href="Haskell.Law.Ord.Def.html#4486" class="Bound">h</a>
  <a id="4490" class="Keyword">rewrite</a> <a id="4498" href="Haskell.Law.Ord.Def.html#3209" class="Function">gte2nlt</a> <a id="4506" href="Haskell.Law.Ord.Def.html#4482" class="Bound">x</a> <a id="4508" href="Haskell.Law.Ord.Def.html#4484" class="Bound">y</a>
    <a id="4514" class="Symbol">|</a> <a id="4516" href="Haskell.Law.Ord.Def.html#1995" class="Function">eq2nlt</a> <a id="4523" href="Haskell.Law.Ord.Def.html#4482" class="Bound">x</a> <a id="4525" href="Haskell.Law.Ord.Def.html#4484" class="Bound">y</a> <a id="4527" href="Haskell.Law.Ord.Def.html#4486" class="Bound">h</a>
  <a id="4531" class="Symbol">=</a> <a id="4533" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="gt2gte"></a><a id="4539" href="Haskell.Law.Ord.Def.html#4539" class="Function">gt2gte</a> <a id="4546" class="Symbol">:</a> <a id="4548" class="Symbol">⦃</a> <a id="4550" href="Haskell.Law.Ord.Def.html#4550" class="Bound">iOrdA</a> <a id="4556" class="Symbol">:</a> <a id="4558" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="4562" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4564" class="Symbol">⦄</a> <a id="4566" class="Symbol">→</a> <a id="4568" class="Symbol">⦃</a> <a id="4570" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4582" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="4584" class="Symbol">⦄</a>
  <a id="4588" class="Symbol">→</a> <a id="4590" class="Symbol">∀</a> <a id="4592" class="Symbol">(</a><a id="4593" href="Haskell.Law.Ord.Def.html#4593" class="Bound">x</a> <a id="4595" href="Haskell.Law.Ord.Def.html#4595" class="Bound">y</a> <a id="4597" class="Symbol">:</a> <a id="4599" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="4600" class="Symbol">)</a> <a id="4602" class="Symbol">→</a> <a id="4604" class="Symbol">(</a><a id="4605" href="Haskell.Law.Ord.Def.html#4593" class="Bound">x</a> <a id="4607" href="Haskell.Prim.Ord.html#1096" class="Field Operator">&gt;</a> <a id="4609" href="Haskell.Law.Ord.Def.html#4595" class="Bound">y</a><a id="4610" class="Symbol">)</a> <a id="4612" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4614" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a> <a id="4619" class="Symbol">→</a> <a id="4621" class="Symbol">(</a><a id="4622" href="Haskell.Law.Ord.Def.html#4593" class="Bound">x</a> <a id="4624" href="Haskell.Prim.Ord.html#1120" class="Field Operator">&gt;=</a> <a id="4627" href="Haskell.Law.Ord.Def.html#4595" class="Bound">y</a><a id="4628" class="Symbol">)</a> <a id="4630" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4632" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">True</a>
<a id="4637" href="Haskell.Law.Ord.Def.html#4539" class="Function">gt2gte</a> <a id="4644" href="Haskell.Law.Ord.Def.html#4644" class="Bound">x</a> <a id="4646" href="Haskell.Law.Ord.Def.html#4646" class="Bound">y</a> <a id="4648" href="Haskell.Law.Ord.Def.html#4648" class="Bound">h</a>
  <a id="4652" class="Keyword">rewrite</a> <a id="4660" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="4664" class="Symbol">(</a><a id="4665" href="Haskell.Law.Ord.Def.html#1306" class="Field">lt2gt</a> <a id="4671" href="Haskell.Law.Ord.Def.html#4646" class="Bound">y</a> <a id="4673" href="Haskell.Law.Ord.Def.html#4644" class="Bound">x</a><a id="4674" class="Symbol">)</a>
    <a id="4680" class="Symbol">|</a> <a id="4682" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="4686" class="Symbol">(</a><a id="4687" href="Haskell.Law.Ord.Def.html#4204" class="Function">lt2lte</a> <a id="4694" href="Haskell.Law.Ord.Def.html#4646" class="Bound">y</a> <a id="4696" href="Haskell.Law.Ord.Def.html#4644" class="Bound">x</a> <a id="4698" href="Haskell.Law.Ord.Def.html#4648" class="Bound">h</a><a id="4699" class="Symbol">)</a>
    <a id="4705" class="Symbol">|</a> <a id="4707" href="Haskell.Law.Ord.Def.html#1144" class="Field">lte2gte</a> <a id="4715" href="Haskell.Law.Ord.Def.html#4646" class="Bound">y</a> <a id="4717" href="Haskell.Law.Ord.Def.html#4644" class="Bound">x</a>
  <a id="4721" class="Symbol">=</a> <a id="4723" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="4729" class="Comment">--------------------------------------------------</a>
<a id="4780" class="Comment">-- Postulated instances</a>

<a id="4805" class="Keyword">postulate</a> <a id="4815" class="Keyword">instance</a>
  <a id="iLawfulOrdNat"></a><a id="4826" href="Haskell.Law.Ord.Def.html#4826" class="Postulate">iLawfulOrdNat</a> <a id="4840" class="Symbol">:</a> <a id="4842" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4854" href="Agda.Builtin.Nat.html#203" class="Datatype">Nat</a>

  <a id="iLawfulOrdInteger"></a><a id="4861" href="Haskell.Law.Ord.Def.html#4861" class="Postulate">iLawfulOrdInteger</a> <a id="4879" class="Symbol">:</a> <a id="4881" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4893" href="Agda.Builtin.Int.html#245" class="Datatype">Integer</a>

  <a id="iLawfulOrdInt"></a><a id="4904" href="Haskell.Law.Ord.Def.html#4904" class="Postulate">iLawfulOrdInt</a> <a id="4918" class="Symbol">:</a> <a id="4920" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4932" href="Haskell.Prim.Int.html#367" class="Datatype">Int</a>

  <a id="iLawfulOrdWord"></a><a id="4939" href="Haskell.Law.Ord.Def.html#4939" class="Postulate">iLawfulOrdWord</a> <a id="4954" class="Symbol">:</a> <a id="4956" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="4968" href="Agda.Builtin.Word.html#208" class="Postulate">Word</a>

  <a id="iLawfulOrdDouble"></a><a id="4976" href="Haskell.Law.Ord.Def.html#4976" class="Postulate">iLawfulOrdDouble</a> <a id="4993" class="Symbol">:</a> <a id="4995" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5007" href="Agda.Builtin.Float.html#353" class="Postulate">Double</a>

  <a id="iLawfulOrdChar"></a><a id="5017" href="Haskell.Law.Ord.Def.html#5017" class="Postulate">iLawfulOrdChar</a> <a id="5032" class="Symbol">:</a> <a id="5034" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5046" href="Agda.Builtin.Char.html#238" class="Postulate">Char</a>

  <a id="iLawfulOrdUnit"></a><a id="5054" href="Haskell.Law.Ord.Def.html#5054" class="Postulate">iLawfulOrdUnit</a> <a id="5069" class="Symbol">:</a> <a id="5071" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5083" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>

  <a id="iLawfulOrdTuple₂"></a><a id="5088" href="Haskell.Law.Ord.Def.html#5088" class="Postulate">iLawfulOrdTuple₂</a> <a id="5105" class="Symbol">:</a> <a id="5107" class="Symbol">⦃</a> <a id="5109" href="Haskell.Law.Ord.Def.html#5109" class="Bound">iOrdA</a> <a id="5115" class="Symbol">:</a> <a id="5117" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="5121" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5123" class="Symbol">⦄</a> <a id="5125" class="Symbol">⦃</a> <a id="5127" href="Haskell.Law.Ord.Def.html#5127" class="Bound">iOrdB</a> <a id="5133" class="Symbol">:</a> <a id="5135" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="5139" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="5141" class="Symbol">⦄</a>
                   <a id="5162" class="Symbol">→</a> <a id="5164" class="Symbol">⦃</a> <a id="5166" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5178" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5180" class="Symbol">⦄</a> <a id="5182" class="Symbol">→</a> <a id="5184" class="Symbol">⦃</a> <a id="5186" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5198" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="5200" class="Symbol">⦄</a>
                   <a id="5221" class="Symbol">→</a> <a id="5223" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5235" class="Symbol">(</a><a id="5236" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5238" href="Haskell.Prim.Tuple.html#169" class="Record Operator">×</a> <a id="5240" href="Haskell.Prim.html#1193" class="Generalizable">b</a><a id="5241" class="Symbol">)</a>

  <a id="iLawfulOrdTuple₃"></a><a id="5246" href="Haskell.Law.Ord.Def.html#5246" class="Postulate">iLawfulOrdTuple₃</a> <a id="5263" class="Symbol">:</a> <a id="5265" class="Symbol">⦃</a> <a id="5267" href="Haskell.Law.Ord.Def.html#5267" class="Bound">iOrdA</a> <a id="5273" class="Symbol">:</a> <a id="5275" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="5279" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5281" class="Symbol">⦄</a> <a id="5283" class="Symbol">⦃</a> <a id="5285" href="Haskell.Law.Ord.Def.html#5285" class="Bound">iOrdB</a> <a id="5291" class="Symbol">:</a> <a id="5293" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="5297" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="5299" class="Symbol">⦄</a> <a id="5301" class="Symbol">⦃</a> <a id="5303" href="Haskell.Law.Ord.Def.html#5303" class="Bound">iOrdC</a> <a id="5309" class="Symbol">:</a> <a id="5311" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="5315" href="Haskell.Prim.html#1195" class="Generalizable">c</a> <a id="5317" class="Symbol">⦄</a>
                   <a id="5338" class="Symbol">→</a> <a id="5340" class="Symbol">⦃</a> <a id="5342" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5354" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5356" class="Symbol">⦄</a> <a id="5358" class="Symbol">→</a> <a id="5360" class="Symbol">⦃</a> <a id="5362" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5374" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="5376" class="Symbol">⦄</a> <a id="5378" class="Symbol">→</a> <a id="5380" class="Symbol">⦃</a> <a id="5382" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5394" href="Haskell.Prim.html#1195" class="Generalizable">c</a> <a id="5396" class="Symbol">⦄</a>
                   <a id="5417" class="Symbol">→</a> <a id="5419" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5431" class="Symbol">(</a><a id="5432" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5434" href="Haskell.Prim.Tuple.html#269" class="Datatype Operator">×</a> <a id="5436" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="5438" href="Haskell.Prim.Tuple.html#269" class="Datatype Operator">×</a> <a id="5440" href="Haskell.Prim.html#1195" class="Generalizable">c</a><a id="5441" class="Symbol">)</a>

  <a id="iLawfulOrdList"></a><a id="5446" href="Haskell.Law.Ord.Def.html#5446" class="Postulate">iLawfulOrdList</a> <a id="5461" class="Symbol">:</a> <a id="5463" class="Symbol">⦃</a> <a id="5465" href="Haskell.Law.Ord.Def.html#5465" class="Bound">iOrdA</a> <a id="5471" class="Symbol">:</a> <a id="5473" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="5477" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5479" class="Symbol">⦄</a> <a id="5481" class="Symbol">→</a> <a id="5483" class="Symbol">⦃</a> <a id="5485" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5497" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5499" class="Symbol">⦄</a> <a id="5501" class="Symbol">→</a> <a id="5503" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5515" class="Symbol">(</a><a id="5516" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5521" href="Haskell.Prim.html#1191" class="Generalizable">a</a><a id="5522" class="Symbol">)</a>

  <a id="iLawfulOrdEither"></a><a id="5527" href="Haskell.Law.Ord.Def.html#5527" class="Postulate">iLawfulOrdEither</a> <a id="5544" class="Symbol">:</a> <a id="5546" class="Symbol">⦃</a> <a id="5548" href="Haskell.Law.Ord.Def.html#5548" class="Bound">iOrdA</a> <a id="5554" class="Symbol">:</a> <a id="5556" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="5560" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5562" class="Symbol">⦄</a> <a id="5564" class="Symbol">→</a> <a id="5566" class="Symbol">⦃</a> <a id="5568" href="Haskell.Law.Ord.Def.html#5568" class="Bound">iOrdB</a> <a id="5574" class="Symbol">:</a> <a id="5576" href="Haskell.Prim.Ord.html#1003" class="Record">Ord</a> <a id="5580" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="5582" class="Symbol">⦄</a> <a id="5584" class="Symbol">→</a>  <a id="5587" class="Symbol">⦃</a> <a id="5589" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5601" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5603" class="Symbol">⦄</a> <a id="5605" class="Symbol">→</a> <a id="5607" class="Symbol">⦃</a> <a id="5609" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5621" href="Haskell.Prim.html#1193" class="Generalizable">b</a> <a id="5623" class="Symbol">⦄</a> <a id="5625" class="Symbol">→</a> <a id="5627" href="Haskell.Law.Ord.Def.html#526" class="Record">IsLawfulOrd</a> <a id="5639" class="Symbol">(</a><a id="5640" href="Haskell.Prim.Either.html#159" class="Datatype">Either</a> <a id="5647" href="Haskell.Prim.html#1191" class="Generalizable">a</a> <a id="5649" href="Haskell.Prim.html#1193" class="Generalizable">b</a><a id="5650" class="Symbol">)</a>
</pre></body></html>
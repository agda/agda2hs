<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Haskell.Law.Applicative.List</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="Haskell.Law.Applicative.List.html" class="Module">Haskell.Law.Applicative.List</a> <a id="37" class="Keyword">where</a>

<a id="44" class="Keyword">open</a> <a id="49" class="Keyword">import</a> <a id="56" href="Haskell.Prim.html" class="Module">Haskell.Prim</a>
<a id="69" class="Keyword">open</a> <a id="74" class="Keyword">import</a> <a id="81" href="Haskell.Prim.List.html" class="Module">Haskell.Prim.List</a>

<a id="100" class="Keyword">open</a> <a id="105" class="Keyword">import</a> <a id="112" href="Haskell.Prim.Applicative.html" class="Module">Haskell.Prim.Applicative</a>
<a id="137" class="Keyword">open</a> <a id="142" class="Keyword">import</a> <a id="149" href="Haskell.Prim.Functor.html" class="Module">Haskell.Prim.Functor</a>

<a id="171" class="Keyword">open</a> <a id="176" class="Keyword">import</a> <a id="183" href="Haskell.Law.Applicative.Def.html" class="Module">Haskell.Law.Applicative.Def</a>

<a id="212" class="Keyword">open</a> <a id="217" class="Keyword">import</a> <a id="224" href="Haskell.Law.Equality.html" class="Module">Haskell.Law.Equality</a>
<a id="245" class="Keyword">open</a> <a id="250" class="Keyword">import</a> <a id="257" href="Haskell.Law.Functor.List.html" class="Module">Haskell.Law.Functor.List</a>
<a id="282" class="Keyword">open</a> <a id="287" class="Keyword">import</a> <a id="294" href="Haskell.Law.List.html" class="Module">Haskell.Law.List</a>

<a id="312" class="Keyword">private</a>
  <a id="identityList"></a><a id="322" href="Haskell.Law.Applicative.List.html#322" class="Function">identityList</a> <a id="335" class="Symbol">:</a> <a id="337" class="Symbol">{</a><a id="338" href="Haskell.Law.Applicative.List.html#338" class="Bound">a</a> <a id="340" class="Symbol">:</a> <a id="342" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="345" class="Symbol">}</a> <a id="347" class="Symbol">→</a> <a id="349" class="Symbol">(</a><a id="350" href="Haskell.Law.Applicative.List.html#350" class="Bound">v</a> <a id="352" class="Symbol">:</a> <a id="354" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="359" href="Haskell.Law.Applicative.List.html#338" class="Bound">a</a><a id="360" class="Symbol">)</a> <a id="362" class="Symbol">→</a> <a id="364" class="Symbol">(</a><a id="365" href="Haskell.Prim.Applicative.html#483" class="Field">pure</a> <a id="370" href="Haskell.Prim.html#1296" class="Function">id</a> <a id="373" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="377" href="Haskell.Law.Applicative.List.html#350" class="Bound">v</a><a id="378" class="Symbol">)</a> <a id="380" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="382" href="Haskell.Law.Applicative.List.html#350" class="Bound">v</a>
  <a id="386" href="Haskell.Law.Applicative.List.html#322" class="Function">identityList</a> <a id="399" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="402" class="Symbol">=</a> <a id="404" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="411" href="Haskell.Law.Applicative.List.html#322" class="Function">identityList</a> <a id="424" class="Symbol">(</a><a id="425" href="Haskell.Law.Applicative.List.html#425" class="Bound">x</a> <a id="427" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="429" href="Haskell.Law.Applicative.List.html#429" class="Bound">xs</a><a id="431" class="Symbol">)</a>
    <a id="437" class="Keyword">rewrite</a> <a id="445" href="Haskell.Law.Applicative.List.html#322" class="Function">identityList</a> <a id="458" href="Haskell.Law.Applicative.List.html#429" class="Bound">xs</a>
    <a id="465" class="Symbol">=</a> <a id="467" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="compositionList"></a><a id="475" href="Haskell.Law.Applicative.List.html#475" class="Function">compositionList</a> <a id="491" class="Symbol">:</a> <a id="493" class="Symbol">{</a><a id="494" href="Haskell.Law.Applicative.List.html#494" class="Bound">a</a> <a id="496" href="Haskell.Law.Applicative.List.html#496" class="Bound">b</a> <a id="498" href="Haskell.Law.Applicative.List.html#498" class="Bound">c</a> <a id="500" class="Symbol">:</a> <a id="502" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="505" class="Symbol">}</a> <a id="507" class="Symbol">→</a> <a id="509" class="Symbol">(</a><a id="510" href="Haskell.Law.Applicative.List.html#510" class="Bound">u</a> <a id="512" class="Symbol">:</a> <a id="514" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="519" class="Symbol">(</a><a id="520" href="Haskell.Law.Applicative.List.html#496" class="Bound">b</a> <a id="522" class="Symbol">→</a> <a id="524" href="Haskell.Law.Applicative.List.html#498" class="Bound">c</a><a id="525" class="Symbol">))</a> <a id="528" class="Symbol">(</a><a id="529" href="Haskell.Law.Applicative.List.html#529" class="Bound">v</a> <a id="531" class="Symbol">:</a> <a id="533" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="538" class="Symbol">(</a><a id="539" href="Haskell.Law.Applicative.List.html#494" class="Bound">a</a> <a id="541" class="Symbol">→</a> <a id="543" href="Haskell.Law.Applicative.List.html#496" class="Bound">b</a><a id="544" class="Symbol">))</a> <a id="547" class="Symbol">(</a><a id="548" href="Haskell.Law.Applicative.List.html#548" class="Bound">w</a> <a id="550" class="Symbol">:</a> <a id="552" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="557" href="Haskell.Law.Applicative.List.html#494" class="Bound">a</a><a id="558" class="Symbol">)</a>
    <a id="564" class="Symbol">→</a> <a id="566" class="Symbol">((((</a><a id="570" href="Haskell.Prim.Applicative.html#483" class="Field">pure</a> <a id="575" href="Haskell.Prim.html#1330" class="Function Operator">_∘_</a><a id="578" class="Symbol">)</a> <a id="580" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="584" href="Haskell.Law.Applicative.List.html#510" class="Bound">u</a><a id="585" class="Symbol">)</a> <a id="587" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="591" href="Haskell.Law.Applicative.List.html#529" class="Bound">v</a><a id="592" class="Symbol">)</a> <a id="594" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="598" href="Haskell.Law.Applicative.List.html#548" class="Bound">w</a><a id="599" class="Symbol">)</a> <a id="601" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="603" class="Symbol">(</a><a id="604" href="Haskell.Law.Applicative.List.html#510" class="Bound">u</a> <a id="606" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="610" class="Symbol">(</a><a id="611" href="Haskell.Law.Applicative.List.html#529" class="Bound">v</a> <a id="613" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="617" href="Haskell.Law.Applicative.List.html#548" class="Bound">w</a><a id="618" class="Symbol">))</a>
  <a id="623" href="Haskell.Law.Applicative.List.html#475" class="Function">compositionList</a> <a id="639" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="642" class="Symbol">_</a>  <a id="645" class="Symbol">_</a>  <a id="648" class="Symbol">=</a> <a id="650" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="657" href="Haskell.Law.Applicative.List.html#475" class="Function">compositionList</a> <a id="673" class="Symbol">(</a><a id="674" href="Haskell.Law.Applicative.List.html#674" class="Bound">u</a> <a id="676" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="678" href="Haskell.Law.Applicative.List.html#678" class="Bound">us</a><a id="680" class="Symbol">)</a> <a id="682" href="Haskell.Law.Applicative.List.html#682" class="Bound">v</a> <a id="684" href="Haskell.Law.Applicative.List.html#684" class="Bound">w</a>
    <a id="690" class="Keyword">rewrite</a> <a id="698" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="702" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="704" href="Haskell.Law.List.html#4083" class="Function">concatMap-++-distr</a> <a id="723" class="Symbol">(</a><a id="724" href="Haskell.Prim.List.html#211" class="Function">map</a> <a id="728" class="Symbol">(</a><a id="729" href="Haskell.Law.Applicative.List.html#674" class="Bound">u</a> <a id="731" href="Haskell.Prim.html#1330" class="Function Operator">∘_</a><a id="733" class="Symbol">)</a> <a id="735" href="Haskell.Law.Applicative.List.html#682" class="Bound">v</a><a id="736" class="Symbol">)</a> <a id="738" class="Symbol">(((</a><a id="741" href="Haskell.Prim.Applicative.html#483" class="Field">pure</a> <a id="746" href="Haskell.Prim.html#1330" class="Function Operator">_∘_</a><a id="749" class="Symbol">)</a> <a id="751" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="755" href="Haskell.Law.Applicative.List.html#678" class="Bound">us</a><a id="757" class="Symbol">)</a> <a id="759" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="763" href="Haskell.Law.Applicative.List.html#682" class="Bound">v</a><a id="764" class="Symbol">)</a> <a id="766" class="Symbol">(λ</a> <a id="769" href="Haskell.Law.Applicative.List.html#769" class="Bound">f</a> <a id="771" class="Symbol">→</a> <a id="773" href="Haskell.Prim.List.html#211" class="Function">map</a> <a id="777" href="Haskell.Law.Applicative.List.html#769" class="Bound">f</a> <a id="779" href="Haskell.Law.Applicative.List.html#684" class="Bound">w</a><a id="780" class="Symbol">)</a>
      <a id="788" class="Symbol">|</a> <a id="790" href="Haskell.Law.Equality.html#401" class="Function">sym</a> <a id="794" href="Haskell.Prim.html#1480" class="Function Operator">$</a> <a id="796" href="Haskell.Law.List.html#1326" class="Function">map-&lt;*&gt;-recomp</a> <a id="811" href="Haskell.Law.Applicative.List.html#682" class="Bound">v</a> <a id="813" href="Haskell.Law.Applicative.List.html#684" class="Bound">w</a> <a id="815" href="Haskell.Law.Applicative.List.html#674" class="Bound">u</a>
      <a id="823" class="Symbol">|</a> <a id="825" href="Haskell.Law.Applicative.List.html#475" class="Function">compositionList</a> <a id="841" href="Haskell.Law.Applicative.List.html#678" class="Bound">us</a> <a id="844" href="Haskell.Law.Applicative.List.html#682" class="Bound">v</a> <a id="846" href="Haskell.Law.Applicative.List.html#684" class="Bound">w</a>
    <a id="852" class="Symbol">=</a> <a id="854" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> 

  <a id="interchangeList"></a><a id="863" href="Haskell.Law.Applicative.List.html#863" class="Function">interchangeList</a> <a id="879" class="Symbol">:</a> <a id="881" class="Symbol">{</a><a id="882" href="Haskell.Law.Applicative.List.html#882" class="Bound">a</a> <a id="884" href="Haskell.Law.Applicative.List.html#884" class="Bound">b</a> <a id="886" class="Symbol">:</a> <a id="888" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="891" class="Symbol">}</a> <a id="893" class="Symbol">→</a> <a id="895" class="Symbol">(</a><a id="896" href="Haskell.Law.Applicative.List.html#896" class="Bound">u</a> <a id="898" class="Symbol">:</a> <a id="900" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="905" class="Symbol">(</a><a id="906" href="Haskell.Law.Applicative.List.html#882" class="Bound">a</a> <a id="908" class="Symbol">→</a> <a id="910" href="Haskell.Law.Applicative.List.html#884" class="Bound">b</a><a id="911" class="Symbol">))</a> <a id="914" class="Symbol">→</a> <a id="916" class="Symbol">(</a><a id="917" href="Haskell.Law.Applicative.List.html#917" class="Bound">y</a> <a id="919" class="Symbol">:</a> <a id="921" href="Haskell.Law.Applicative.List.html#882" class="Bound">a</a><a id="922" class="Symbol">)</a>
    <a id="928" class="Symbol">→</a> <a id="930" class="Symbol">(</a><a id="931" href="Haskell.Law.Applicative.List.html#896" class="Bound">u</a> <a id="933" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="937" class="Symbol">(</a><a id="938" href="Haskell.Prim.Applicative.html#483" class="Field">pure</a> <a id="943" href="Haskell.Law.Applicative.List.html#917" class="Bound">y</a><a id="944" class="Symbol">))</a> <a id="947" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="949" class="Symbol">(</a><a id="950" href="Haskell.Prim.Applicative.html#483" class="Field">pure</a> <a id="955" class="Symbol">(</a><a id="956" href="Haskell.Prim.html#1480" class="Function Operator">_$</a> <a id="959" href="Haskell.Law.Applicative.List.html#917" class="Bound">y</a><a id="960" class="Symbol">)</a> <a id="962" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="966" href="Haskell.Law.Applicative.List.html#896" class="Bound">u</a><a id="967" class="Symbol">)</a>
  <a id="971" href="Haskell.Law.Applicative.List.html#863" class="Function">interchangeList</a> <a id="987" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="990" class="Symbol">_</a> <a id="992" class="Symbol">=</a> <a id="994" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1001" href="Haskell.Law.Applicative.List.html#863" class="Function">interchangeList</a> <a id="1017" class="Symbol">(</a><a id="1018" href="Haskell.Law.Applicative.List.html#1018" class="Bound">x</a> <a id="1020" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1022" href="Haskell.Law.Applicative.List.html#1022" class="Bound">xs</a><a id="1024" class="Symbol">)</a> <a id="1026" href="Haskell.Law.Applicative.List.html#1026" class="Bound">y</a>
      <a id="1034" class="Keyword">rewrite</a> <a id="1042" href="Haskell.Law.Applicative.List.html#863" class="Function">interchangeList</a> <a id="1058" href="Haskell.Law.Applicative.List.html#1022" class="Bound">xs</a> <a id="1061" href="Haskell.Law.Applicative.List.html#1026" class="Bound">y</a>
      <a id="1069" class="Symbol">=</a> <a id="1071" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="functorList"></a><a id="1079" href="Haskell.Law.Applicative.List.html#1079" class="Function">functorList</a> <a id="1091" class="Symbol">:</a> <a id="1093" class="Symbol">{</a><a id="1094" href="Haskell.Law.Applicative.List.html#1094" class="Bound">a</a> <a id="1096" href="Haskell.Law.Applicative.List.html#1096" class="Bound">b</a> <a id="1098" class="Symbol">:</a> <a id="1100" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="1103" class="Symbol">}</a> <a id="1105" class="Symbol">→</a> <a id="1107" class="Symbol">(</a><a id="1108" href="Haskell.Law.Applicative.List.html#1108" class="Bound">f</a> <a id="1110" class="Symbol">:</a> <a id="1112" href="Haskell.Law.Applicative.List.html#1094" class="Bound">a</a> <a id="1114" class="Symbol">→</a> <a id="1116" href="Haskell.Law.Applicative.List.html#1096" class="Bound">b</a><a id="1117" class="Symbol">)</a> <a id="1119" class="Symbol">→</a> <a id="1121" class="Symbol">(</a><a id="1122" href="Haskell.Law.Applicative.List.html#1122" class="Bound">x</a> <a id="1124" class="Symbol">:</a> <a id="1126" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="1131" href="Haskell.Law.Applicative.List.html#1094" class="Bound">a</a><a id="1132" class="Symbol">)</a>
    <a id="1138" class="Symbol">→</a> <a id="1140" class="Symbol">(</a><a id="1141" href="Haskell.Prim.Functor.html#361" class="Field">fmap</a> <a id="1146" href="Haskell.Law.Applicative.List.html#1108" class="Bound">f</a> <a id="1148" href="Haskell.Law.Applicative.List.html#1122" class="Bound">x</a><a id="1149" class="Symbol">)</a> <a id="1151" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1153" class="Symbol">((</a><a id="1155" href="Haskell.Prim.Applicative.html#483" class="Field">pure</a> <a id="1160" href="Haskell.Law.Applicative.List.html#1108" class="Bound">f</a><a id="1161" class="Symbol">)</a> <a id="1163" href="Haskell.Prim.Applicative.html#503" class="Field Operator">&lt;*&gt;</a> <a id="1167" href="Haskell.Law.Applicative.List.html#1122" class="Bound">x</a><a id="1168" class="Symbol">)</a>
  <a id="1172" href="Haskell.Law.Applicative.List.html#1079" class="Function">functorList</a> <a id="1184" class="Symbol">_</a> <a id="1186" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="1189" class="Symbol">=</a> <a id="1191" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="1198" href="Haskell.Law.Applicative.List.html#1079" class="Function">functorList</a> <a id="1210" href="Haskell.Law.Applicative.List.html#1210" class="Bound">f</a> <a id="1212" class="Symbol">(</a><a id="1213" href="Haskell.Law.Applicative.List.html#1213" class="Bound">x</a> <a id="1215" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1217" href="Haskell.Law.Applicative.List.html#1217" class="Bound">xs</a><a id="1219" class="Symbol">)</a>
      <a id="1227" class="Keyword">rewrite</a> <a id="1235" href="Haskell.Law.Applicative.List.html#1079" class="Function">functorList</a> <a id="1247" href="Haskell.Law.Applicative.List.html#1210" class="Bound">f</a> <a id="1249" href="Haskell.Law.Applicative.List.html#1217" class="Bound">xs</a>
        <a id="1260" class="Symbol">|</a> <a id="1262" href="Haskell.Law.List.html#1866" class="Function">++-[]</a> <a id="1268" class="Symbol">(</a><a id="1269" href="Haskell.Prim.List.html#211" class="Function">map</a> <a id="1273" href="Haskell.Law.Applicative.List.html#1210" class="Bound">f</a> <a id="1275" href="Haskell.Law.Applicative.List.html#1217" class="Bound">xs</a><a id="1277" class="Symbol">)</a>
        <a id="1287" class="Symbol">|</a> <a id="1289" href="Haskell.Law.List.html#1866" class="Function">++-[]</a> <a id="1295" class="Symbol">(</a><a id="1296" href="Haskell.Law.Applicative.List.html#1210" class="Bound">f</a> <a id="1298" href="Haskell.Law.Applicative.List.html#1213" class="Bound">x</a> <a id="1300" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1302" href="Haskell.Prim.List.html#211" class="Function">map</a> <a id="1306" href="Haskell.Law.Applicative.List.html#1210" class="Bound">f</a> <a id="1308" href="Haskell.Law.Applicative.List.html#1217" class="Bound">xs</a><a id="1310" class="Symbol">)</a>
      <a id="1318" class="Symbol">=</a> <a id="1320" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="1326" class="Keyword">instance</a>
  <a id="iLawfulApplicativeList"></a><a id="1337" href="Haskell.Law.Applicative.List.html#1337" class="Function">iLawfulApplicativeList</a> <a id="1360" class="Symbol">:</a> <a id="1362" href="Haskell.Law.Applicative.Def.html#243" class="Record">IsLawfulApplicative</a> <a id="1382" href="Agda.Builtin.List.html#147" class="Datatype">List</a>
  <a id="1389" href="Haskell.Law.Applicative.List.html#1337" class="Function">iLawfulApplicativeList</a> <a id="1412" class="Symbol">=</a> <a id="1414" class="Symbol">λ</a> <a id="1416" class="Keyword">where</a>
    <a id="1426" class="Symbol">.</a><a id="1427" href="Haskell.Law.Applicative.Def.html#408" class="Field">identity</a> <a id="1436" class="Symbol">→</a> <a id="1438" href="Haskell.Law.Applicative.List.html#322" class="Function">identityList</a>
    <a id="1455" class="Symbol">.</a><a id="1456" href="Haskell.Law.Applicative.Def.html#521" class="Field">composition</a> <a id="1468" class="Symbol">→</a> <a id="1470" href="Haskell.Law.Applicative.List.html#475" class="Function">compositionList</a>
    <a id="1490" class="Symbol">.</a><a id="1491" href="Haskell.Law.Applicative.Def.html#707" class="Field">homomorphism</a> <a id="1504" class="Symbol">_</a> <a id="1506" href="Haskell.Law.Applicative.List.html#1506" class="Bound">x</a> <a id="1508" class="Symbol">→</a> <a id="1510" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
    <a id="1519" class="Symbol">.</a><a id="1520" href="Haskell.Law.Applicative.Def.html#880" class="Field">interchange</a> <a id="1532" class="Symbol">→</a> <a id="1534" href="Haskell.Law.Applicative.List.html#863" class="Function">interchangeList</a>
    <a id="1554" class="Symbol">.</a><a id="1555" href="Haskell.Law.Applicative.Def.html#1015" class="Field">functor</a> <a id="1563" class="Symbol">→</a> <a id="1565" href="Haskell.Law.Applicative.List.html#1079" class="Function">functorList</a>
</pre></body></html>